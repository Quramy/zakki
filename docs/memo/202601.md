# 1/8

## n8n の脆弱性とそのメカニズム

昨日公開された CVE-2026-2185 という n8n の脆弱性について、その機序を解説した記事が下記に上がっていたので読んだ。
https://www.cyera.com/research-labs/ni8mare-unauthenticated-remote-code-execution-in-n8n-cve-2026-21858

そもそもの前提として、n8n は Node.js ベースのワークフロー自動化ツールであり、ユーザーが様々なアプリケーションやサービスを連携させるためのプラットフォームが提供されている。
昔でいう Node-RED のようなやつの令和版といったところか。

自分は n8n のアイコンとか見かけたことがある程度の「なんかワークフロー系のツールなのかな」くらいの知識だったけど、上記の記事によると、

> Unless you’ve been living under a rock for the last year, you’ve probably heard of n8n.

とのことのなので、相当俺はアンテナが腐ってるっぽい。これはこれでやばいなぁ。。。

閑話休題。
CVE-2026-2185 (愛称はは Ni8tmare) は最終的には管理者権限を不正に奪取したうえで RCE (リモートコード実行) まで行われる可能性のある脆弱性である。
したがって CVSS スコアも最高の 10.0 となっている。

実際に RCE まで達成させるためには、ある程度ワークフローや n8n に事前条件が必要であるが、元記事で書いているようなナレッジベース型の使い方をしていれば、比較的現実的に成立する可能性がある。

ポイントはこの 2 点のはず. 元記事では間に AI だのを挟んでいたが、そこは関係ない。

- n8n Form Node を使ってファイルアップロードが可能である
- アップロードしたファイルを閲覧する術がある

本来はユーザーがアップロードしたファイルが閲覧される、というものであるが、Ni8tmare をつくと n8n のサーバー内で秘匿されるべき情報を「自分がアップロードしたファイル」として閲覧できてしまう、というところがポイント。

n8n サーバーの認可は JWT で署名化された stateless cookie で行われており、その cookie の中身の作成に必要な情報 (ユーザー情報が入った sqlite の DB , JWT の署名鍵) は n8n サーバー内部に存在しているため、Ni8tmare によってこれらの情報を盗み出すことができれば、n8n サーバーの管理者権限を奪取できる。後は自分で「任意のコードを実行する Node 」を追加して実行すれば RCE 成立。

上述の「Ni8tmare をつくと n8n のサーバー内で秘匿されるべき情報を自分がアップロードしたファイルとして閲覧できてしまう」がどのように成立するのかも、元記事の前半でしっかり解説されていた。

1: n8n は Webhook の Request に対する Middleware (いわゆる Express ライクな Middleware の意味) で、Formidable が提供している Multipart Body Parser を利用している

```ts
if (contentType === "multipart/form-data") {
  req.body = await parseFormData(req); // これが Formidable の parser
} else {
  if (nodeVersion > 1) {
    if (
      contentType?.startsWith("application/json") ||
      contentType?.startsWith("text/plain") ||
      contentType?.startsWith("application/x-www-form-urlencoded") ||
      contentType?.endsWith("/xml") ||
      contentType?.endsWith("+xml")
    ) {
      await parseBody(req);
    }
  } else {
    await parseBody(req);
  }
}
```

ref: https://github.com/n8n-io/n8n/blob/454c85609fb6431ac59a656c68140b7ad1fe680c/packages/cli/src/webhooks/webhook-helpers.ts#L879-L894

Content-Type が `multipart/form-data` の場合、 `req.body.files` オブジェクト以下にアップロードされたファイルの情報が格納されていることになる。
一方で、`application/json` のような Content-Type の場合は `req.body` は通常の body parser が利用される。

したがって、以下のような JSON を `application/json` の Content-Type で送信した場合も、Multipart form-data で `field-0` にファイルをアップロードして送信した場合も `req.body.files["field-0"].filepath` というキーが存在することになる。

```json
{
  "files": {
    "field-0": {
      "filepath": "hoge.txt"
    }
  }
}
```

2: Formidable は Server local temp dir にファイルを保存する

Formidalble は Multipart form-data の file 部分について、一時的にサーバーの temp dir に保存するようになっている。

Formidalble parse 後の `file.filepath` 属性が示すのは、その temp file path 。

```ts
export interface File {
  // The size of the uploaded file in bytes.
  // If the file is still being uploaded (see `'fileBegin'` event),
  // this property says how many bytes of the file have been written to disk yet.
  file.size: number;

  // The path this file is being written to. You can modify this in the `'fileBegin'` event in
  // case you are unhappy with the way formidable generates a temporary path for your files.
  file.filepath: string;

  // The name this file had according to the uploading client.
  file.originalFilename: string | null;

  // 以下略
}
```

ref: https://github.com/node-formidable/formidable?tab=readme-ov-file#file

3: n8n の一部の Node は `req.body.files` を元にファイルコピー処理を行っている

以下の `copyBinaryFile` 関数部分。

```ts
export async function prepareFormReturnItem(
  context: IWebhookFunctions,
  formFields: FormFieldsParameter,
  mode: "test" | "production",
  useWorkflowTimezone: boolean = false
) {
  // 中略
  returnItem.binary![binaryPropertyName] =
    await context.nodeHelpers.copyBinaryFile(
      file.filepath,
      file.originalFilename ?? file.newFilename,
      file.mimetype
    );
  // 中略
}
```

ref: https://github.com/n8n-io/n8n/blob/c8d604d2c466dd84ec24f4f092183d86e43f2518/packages/nodes-base/nodes/Form/utils/utils.ts#L401

この `prepareFormReturnItem` は例えば Form Node Webhook の処理で呼ばれている。

https://github.com/n8n-io/n8n/blob/c8d604d2c466dd84ec24f4f092183d86e43f2518/packages/nodes-base/nodes/Form/Form.node.ts#L385

`copyBinaryFile` の実体は設定やワークフローよって異なるが、要するにファイルのコピーである。たとえば次の `objectStoreService` による実装であれば S3 とか minio にコピーされる。

e.g. https://github.com/n8n-io/n8n/blob/master/packages/core/src/binary-data/object-store.manager.ts#L71

これらを 3 つを組みわせると、

```json
{
  "files": {
    "field-0": {
      "filepath": "/secref_file.txt"
    }
  }
}
```

のような `application/json` Content-Type のリクエストが `prepareFormReturnItem` に渡った場合、`/secref_file.txt` というサーバー内の秘匿されるべきファイルが `copyBinaryFile` によって外部ストレージにコピーされてしまう、ということになる。

実際、`prepareFormReturnItem` はまさにその問題を抱えていたため、今回の Ni8tmare に繋がった。

[この diff](https://github.com/n8n-io/n8n/commit/c8d604d2c466dd84ec24f4f092183d86e43f2518#diff-39ac99709c6ad7f5afcecf27714dbea6fb7fbcc8fda0a9e04a2e1ec05a92f473) を見ると、まさに `prepareFormReturnItem` でリクエストの Content-Type が `multipart/form-data` であることをチェックするように修正されていることがわかる。

## Tailwind CSS のレイオフ問題

https://github.com/tailwindlabs/tailwindcss.com/pull/2388#issuecomment-3717222957

> しかし現実は、AI が私たちのビジネスに与えた壊滅的な影響により、昨日エンジニアリングチームの 75%が職を失ったのです。そして、コミュニティのためにこのような楽しい無料の活動に費やす時間は、ビジネスを立て直し、まだここにいる社員が毎月きちんと給料をもらえるようにするための時間ではないのです。

Tailwind CSS は Tailwind Labs という企業がメンテしている。
Tailwind Labs は Tailwind Plus(旧 Tailwind UI) をライセンス販売するという収益モデルだが、AI の台頭と AI が Tailwind CSS を積極的に利用してきた結果の帰結が 75% のエンジニアレイオフというのは中々のインパクト。

AI が出力しやすいことが、人間が読みやすいことには繋がっておらず、またそもそもの Vanilla な CSS との乖離も激しいことを考えるといつまで経っても Tailwind は好きになれないが、それとは別にして AI を中心としたコミュニティに指示されたことが OSS の持続性を損なうというのはなぁ。。。

---

# 1/13

## Zodios で TS2589 エラー

おしごとにて。

openapi-zod-client を使って OpenAPI の YAML から Zodios のクライアントを自動生成したら以下のエラーに遭遇。

```
TS2589: Type instantiation is excessively deep and possibly infinite
```

エンドポイントの数を削ると解消される。

- OpenAPI で `$ref` が多用されている事が問題かと思い、Response などを inline 展開するなどを試したが、あまり効果がなかった。
- https://github.com/astahmer/openapi-zod-client/issues/308 が関係しているかと思ったが、Description に記載されているように Handlebars のテンプレートを変更しても解消されず。

---

# 1/14

## Node.js のセキュリティアップデート

2025 年末からペンディングとなっていた Node.js のセキュリティアップデートが公開された。

https://nodejs.org/en/blog/vulnerability/december-2025-security-releases

うち、Severity が High のものは以下の 3 件

- Timeout-based race conditions make Uint8Array/Buffer.alloc non-zerofilled (CVE-2025-55131) - (High)
- Bypass File System Permissions using crafted symlinks (CVE-2025-55130) - (High)
- Node.js HTTP/2 server crashes with unhandled error when receiving malformed HEADERS frame (CVE-2025-59465) - (High)

特に 3 番目のものについては、 Async Local Storage が Uncaught Error (Stack overflow) を起こす可能性があり、 Next.js や 各種 APM (e.g. Datadog, NewRelic) がリクエストコンテキストの維持に ALS を利用する都合上、影響範囲は大きめ。
この件についての詳細な記事も別途上がっていた。

https://nodejs.org/en/blog/vulnerability/january-2026-dos-mitigation-async-hooks

脆弱性とは直接関係ないが、上記の記事を読んでいて、 Node.js v24 以降では ALS の実装が `async_hooks` ベースのものから V8 `AsyncContextFrame` という機能をベースとしたものに差し替えられていることを初めて知った。

---

# 1/15

## コンポーネント作成を AI に任せる場合のワークフローについてもやもや考えてみる

GPT に壁打ちしながら整理。

> ## Agent×VRT（Figma 一致）ワークフローまとめ（理解＋補足）
>
> ### 前提
>
> - Agent には人間のような高度な「目」はない。
> - そのため「検知・診断・合否判定」をワークフロー側で補う必要がある。
>
> ### 目的
>
> - 新規作成時：Figma（Design Golden）に対して “十分に一致” を担保する
> - 既存変更時：Regression Golden に対して “意図しない崩れ” を検知する
>
> ---
>
> ## 1. 間違っていることを伝える（検知＝機械が担当）
>
> - Pixel diff / SSIM / LPIPS を併用し、見た目のズレをスコアで検知する
> - 単一指標に寄せず、複数指標で「レイアウト」「知覚的差分」をカバーする
> - 合否の最終判断（Pass/Fail）は原則「機械ルール」または「人間レビュー」で行う
>   - 判定を AI に任せると再現性が落ち、運用がブレやすい
>
> ---
>
> ## 2. 何が間違っているかを伝える（診断材料＝機械が提供）
>
> - 画像由来の局在化
>   - diff ヒートマップ、差分 bbox（どの領域がズレているか）
> - DOM/スタイル由来の説明（構造比較の現実解）
>   - Figma ノードツリー vs DOM ツリーの同型比較は破綻しがち
>   - 代わりに「部位（root/label/icon…）単位」の期待値 vs 実測を比較する
>     - getComputedStyle：padding / gap / font / color / shadow / radius…
>     - bounding box：サイズ、距離、整列（中央寄せ、アイコン間隔など）
>   - token 逸脱（ハードコード値）も静的解析で検出すると安定する
>
> ---
>
> ## 3. Agent にやらせること（修正＝ AI が担当）
>
> - 検知結果（スコア）＋局在化（ヒートマップ/bbox）＋ DOM 差分（style/距離）を入力として
>   - 差分のカテゴリ分け（余白/タイポ/色/影/整列…）
>   - 原因推定（token 不一致、制約不足、状態再現漏れ等）
>   - 修正案生成（CSS/Token/レイアウト修正）→ 再計測のループ
> - 「合否判定」は AI に任せず、AI は「直す」ことに集中させる
>
> ---
>
> ## 4. 運用を安定させるコツ（ゲート設計）
>
> - Gate1：レイアウト崩れ検知（例：SSIM）
> - Gate2：知覚差分の許容判断（例：LPIPS、色差、タイポ/spacing の DOM 検査）
> - Gate3：グレーのみ人間レビュー（diff 画像と AI 診断付き）
> - 目的は「AI が延々と微調整」しない仕組みを作ること

---

# 1/16

## ラスタからベクタ画像を取得

あまりそんな例はないかもしれないが、 Figma のとあるノードがラスタ画像で提供されていたが、アニメーションさせる都合で SVG に変換したい、というケースに遭遇した。
Rect, Circle のみで構成できそうな画像であったものの、それぞれのサイズや位置がわからなくてどうしようと思いつつ、 GPT に PNG 渡して「 SVG に変換して」と頼んだらやってのけてくれた。

---

# 1/19

## Waku の 1.0 Alpha リリース

昨年末に 1.0 Alpha リリースされていた。 Public API は Stable 扱いとのこと。

https://waku.gg/blog/waku-v1-alpha

## HTML の geolocation 要素について

https://developer.chrome.com/blog/geolocation-html-element

## Safari TP 234 で grid-lanes 実装

https://webkit.org/blog/17660/introducing-css-grid-lanes/

Grid Lanes の実装、ちょうど去年にめちゃくちゃ調べてた頃に TP として上がってたみたい。

## Web Almanac 2025

https://almanac.httparchive.org/en/2025/

[CSS Tricks](https://css-tricks.com/http-archive-2025-web-almanac/) 経由で見つけた。

Font や Web Assembly など、様々な切り口で技術要素がどのように Web で利用されているかを分析したもの。

コンテンツがかなり多いので読みきれてないが、かなり面白そう。

---

# 1/20

## `@vercel/og` の内部実装

`@vercel/og` パッケージが、以下に OG Image を生成しているかについて、同僚と盛り上がった。

- https://github.com/vercel/satori で、HTML / CSS を SVG に変換
- SVG を更に https://github.com/thx/resvg-js で PNG に変換

という流れ。
