# 1/8

## n8n の脆弱性とそのメカニズム

昨日公開された CVE-2026-2185 という n8n の脆弱性について、その機序を解説した記事が下記に上がっていたので読んだ。
https://www.cyera.com/research-labs/ni8mare-unauthenticated-remote-code-execution-in-n8n-cve-2026-21858

そもそもの前提として、n8n は Node.js ベースのワークフロー自動化ツールであり、ユーザーが様々なアプリケーションやサービスを連携させるためのプラットフォームが提供されている。
昔でいう Node-RED のようなやつの令和版といったところか。

自分は n8n のアイコンとか見かけたことがある程度の「なんかワークフロー系のツールなのかな」くらいの知識だったけど、上記の記事によると、

> Unless you’ve been living under a rock for the last year, you’ve probably heard of n8n.

とのことのなので、相当俺はアンテナが腐ってるっぽい。これはこれでやばいなぁ。。。

閑話休題。
CVE-2026-2185 (愛称はは Ni8tmare) は最終的には管理者権限を不正に奪取したうえで RCE (リモートコード実行) まで行われる可能性のある脆弱性である。
したがって CVSS スコアも最高の 10.0 となっている。

実際に RCE まで達成させるためには、ある程度ワークフローや n8n に事前条件が必要であるが、元記事で書いているようなナレッジベース型の使い方をしていれば、比較的現実的に成立する可能性がある。

ポイントはこの 2 点のはず. 元記事では間に AI だのを挟んでいたが、そこは関係ない。

- n8n Form Node を使ってファイルアップロードが可能である
- アップロードしたファイルを閲覧する術がある

本来はユーザーがアップロードしたファイルが閲覧される、というものであるが、Ni8tmare をつくと n8n のサーバー内で秘匿されるべき情報を「自分がアップロードしたファイル」として閲覧できてしまう、というところがポイント。

n8n サーバーの認可は JWT で署名化された stateless cookie で行われており、その cookie の中身の作成に必要な情報 (ユーザー情報が入った sqlite の DB , JWT の署名鍵) は n8n サーバー内部に存在しているため、Ni8tmare によってこれらの情報を盗み出すことができれば、n8n サーバーの管理者権限を奪取できる。後は自分で「任意のコードを実行する Node 」を追加して実行すれば RCE 成立。

上述の「Ni8tmare をつくと n8n のサーバー内で秘匿されるべき情報を自分がアップロードしたファイルとして閲覧できてしまう」がどのように成立するのかも、元記事の前半でしっかり解説されていた。

1: n8n は Webhook の Request に対する Middleware (いわゆる Express ライクな Middleware の意味) で、Formidable が提供している Multipart Body Parser を利用している

```ts
if (contentType === "multipart/form-data") {
  req.body = await parseFormData(req); // これが Formidable の parser
} else {
  if (nodeVersion > 1) {
    if (
      contentType?.startsWith("application/json") ||
      contentType?.startsWith("text/plain") ||
      contentType?.startsWith("application/x-www-form-urlencoded") ||
      contentType?.endsWith("/xml") ||
      contentType?.endsWith("+xml")
    ) {
      await parseBody(req);
    }
  } else {
    await parseBody(req);
  }
}
```

ref: https://github.com/n8n-io/n8n/blob/454c85609fb6431ac59a656c68140b7ad1fe680c/packages/cli/src/webhooks/webhook-helpers.ts#L879-L894

Content-Type が `multipart/form-data` の場合、 `req.body.files` オブジェクト以下にアップロードされたファイルの情報が格納されていることになる。
一方で、`application/json` のような Content-Type の場合は `req.body` は通常の body parser が利用される。

したがって、以下のような JSON を `application/json` の Content-Type で送信した場合も、Multipart form-data で `field-0` にファイルをアップロードして送信した場合も `req.body.files["field-0"].filepath` というキーが存在することになる。

```json
{
  "files": {
    "field-0": {
      "filepath": "hoge.txt"
    }
  }
}
```

2: Formidable は Server local temp dir にファイルを保存する

Formidalble は Multipart form-data の file 部分について、一時的にサーバーの temp dir に保存するようになっている。

Formidalble parse 後の `file.filepath` 属性が示すのは、その temp file path 。

```ts
export interface File {
  // The size of the uploaded file in bytes.
  // If the file is still being uploaded (see `'fileBegin'` event),
  // this property says how many bytes of the file have been written to disk yet.
  file.size: number;

  // The path this file is being written to. You can modify this in the `'fileBegin'` event in
  // case you are unhappy with the way formidable generates a temporary path for your files.
  file.filepath: string;

  // The name this file had according to the uploading client.
  file.originalFilename: string | null;

  // 以下略
}
```

ref: https://github.com/node-formidable/formidable?tab=readme-ov-file#file

3: n8n の一部の Node は `req.body.files` を元にファイルコピー処理を行っている

以下の `copyBinaryFile` 関数部分。

```ts
export async function prepareFormReturnItem(
  context: IWebhookFunctions,
  formFields: FormFieldsParameter,
  mode: "test" | "production",
  useWorkflowTimezone: boolean = false
) {
  // 中略
  returnItem.binary![binaryPropertyName] =
    await context.nodeHelpers.copyBinaryFile(
      file.filepath,
      file.originalFilename ?? file.newFilename,
      file.mimetype
    );
  // 中略
}
```

ref: https://github.com/n8n-io/n8n/blob/c8d604d2c466dd84ec24f4f092183d86e43f2518/packages/nodes-base/nodes/Form/utils/utils.ts#L401

この `prepareFormReturnItem` は例えば Form Node Webhook の処理で呼ばれている。

https://github.com/n8n-io/n8n/blob/c8d604d2c466dd84ec24f4f092183d86e43f2518/packages/nodes-base/nodes/Form/Form.node.ts#L385

`copyBinaryFile` の実体は設定やワークフローよって異なるが、要するにファイルのコピーである。たとえば次の `objectStoreService` による実装であれば S3 とか minio にコピーされる。

e.g. https://github.com/n8n-io/n8n/blob/master/packages/core/src/binary-data/object-store.manager.ts#L71

これらを3つを組みわせると、

```json
{
  "files": {
    "field-0": {
      "filepath": "/secref_file.txt"
    }
  }
}
```

のような `application/json` Content-Type のリクエストが `prepareFormReturnItem` に渡った場合、`/secref_file.txt` というサーバー内の秘匿されるべきファイルが `copyBinaryFile` によって外部ストレージにコピーされてしまう、ということになる。

実際、`prepareFormReturnItem` はまさにその問題を抱えていたため、今回の Ni8tmare に繋がった。

[この diff](https://github.com/n8n-io/n8n/commit/c8d604d2c466dd84ec24f4f092183d86e43f2518#diff-39ac99709c6ad7f5afcecf27714dbea6fb7fbcc8fda0a9e04a2e1ec05a92f473) を見ると、まさに `prepareFormReturnItem` でリクエストの Content-Type が `multipart/form-data` であることをチェックするように修正されていることがわかる。

## Tailwind CSS のレイオフ問題

https://github.com/tailwindlabs/tailwindcss.com/pull/2388#issuecomment-3717222957

> しかし現実は、AIが私たちのビジネスに与えた壊滅的な影響により、昨日エンジニアリングチームの75%が職を失ったのです。そして、コミュニティのためにこのような楽しい無料の活動に費やす時間は、ビジネスを立て直し、まだここにいる社員が毎月きちんと給料をもらえるようにするための時間ではないのです。

Tailwind CSS は Tailwind Labs という企業がメンテしている。
Tailwind Labs は Tailwind Plus(旧 Tailwind UI) をライセンス販売するという収益モデルだが、AI の台頭と AI が Tailwind CSS を積極的に利用してきた結果の帰結が 75% のエンジニアレイオフというのは中々のインパクト。

AI が出力しやすいことが、人間が読みやすいことには繋がっておらず、またそもそもの Vanilla な CSS との乖離も激しいことを考えるといつまで経っても Tailwind は好きになれないが、それとは別にして AI を中心としたコミュニティに指示されたことが OSS の持続性を損なうというのはなぁ。。。
