# 1/8

## n8n の脆弱性とそのメカニズム

昨日公開された CVE-2026-2185 という n8n の脆弱性について、その機序を解説した記事が下記に上がっていたので読んだ。
https://www.cyera.com/research-labs/ni8mare-unauthenticated-remote-code-execution-in-n8n-cve-2026-21858

そもそもの前提として、n8n は Node.js ベースのワークフロー自動化ツールであり、ユーザーが様々なアプリケーションやサービスを連携させるためのプラットフォームが提供されている。
昔でいう Node-RED のようなやつの令和版といったところか。

自分は n8n のアイコンとか見かけたことがある程度の「なんかワークフロー系のツールなのかな」くらいの知識だったけど、上記の記事によると、

> Unless you’ve been living under a rock for the last year, you’ve probably heard of n8n.

とのことのなので、相当俺はアンテナが腐ってるっぽい。これはこれでやばいなぁ。。。

閑話休題。
CVE-2026-2185 (愛称はは Ni8tmare) は最終的には管理者権限を不正に奪取したうえで RCE (リモートコード実行) まで行われる可能性のある脆弱性である。
したがって CVSS スコアも最高の 10.0 となっている。

実際に RCE まで達成させるためには、ある程度ワークフローや n8n に事前条件が必要であるが、元記事で書いているようなナレッジベース型の使い方をしていれば、比較的現実的に成立する可能性がある。

ポイントはこの 2 点のはず. 元記事では間に AI だのを挟んでいたが、そこは関係ない。

- n8n Form Node を使ってファイルアップロードが可能である
- アップロードしたファイルを閲覧する術がある

本来はユーザーがアップロードしたファイルが閲覧される、というものであるが、Ni8tmare をつくと n8n のサーバー内で秘匿されるべき情報を「自分がアップロードしたファイル」として閲覧できてしまう、というところがポイント。

n8n サーバーの認可は JWT で署名化された stateless cookie で行われており、その cookie の中身の作成に必要な情報 (ユーザー情報が入った sqlite の DB , JWT の署名鍵) は n8n サーバー内部に存在しているため、Ni8tmare によってこれらの情報を盗み出すことができれば、n8n サーバーの管理者権限を奪取できる。後は自分で「任意のコードを実行する Node 」を追加して実行すれば RCE 成立。

上述の「Ni8tmare をつくと n8n のサーバー内で秘匿されるべき情報を自分がアップロードしたファイルとして閲覧できてしまう」がどのように成立するのかも、元記事の前半でしっかり解説されていた。

1: n8n は Webhook の Request に対する Middleware (いわゆる Express ライクな Middleware の意味) で、Formidable が提供している Multipart Body Parser を利用している

```ts
if (contentType === "multipart/form-data") {
  req.body = await parseFormData(req); // これが Formidable の parser
} else {
  if (nodeVersion > 1) {
    if (
      contentType?.startsWith("application/json") ||
      contentType?.startsWith("text/plain") ||
      contentType?.startsWith("application/x-www-form-urlencoded") ||
      contentType?.endsWith("/xml") ||
      contentType?.endsWith("+xml")
    ) {
      await parseBody(req);
    }
  } else {
    await parseBody(req);
  }
}
```

ref: https://github.com/n8n-io/n8n/blob/454c85609fb6431ac59a656c68140b7ad1fe680c/packages/cli/src/webhooks/webhook-helpers.ts#L879-L894

Content-Type が `multipart/form-data` の場合、 `req.body.files` オブジェクト以下にアップロードされたファイルの情報が格納されていることになる。
一方で、`application/json` のような Content-Type の場合は `req.body` は通常の body parser が利用される。

したがって、以下のような JSON を `application/json` の Content-Type で送信した場合も、Multipart form-data で `field-0` にファイルをアップロードして送信した場合も `req.body.files["field-0"].filepath` というキーが存在することになる。

```json
{
  "files": {
    "field-0": {
      "filepath": "hoge.txt"
    }
  }
}
```

2: Formidable は Server local temp dir にファイルを保存する

Formidalble は Multipart form-data の file 部分について、一時的にサーバーの temp dir に保存するようになっている。

Formidalble parse 後の `file.filepath` 属性が示すのは、その temp file path 。

```ts
export interface File {
  // The size of the uploaded file in bytes.
  // If the file is still being uploaded (see `'fileBegin'` event),
  // this property says how many bytes of the file have been written to disk yet.
  file.size: number;

  // The path this file is being written to. You can modify this in the `'fileBegin'` event in
  // case you are unhappy with the way formidable generates a temporary path for your files.
  file.filepath: string;

  // The name this file had according to the uploading client.
  file.originalFilename: string | null;

  // 以下略
}
```

ref: https://github.com/node-formidable/formidable?tab=readme-ov-file#file

3: n8n の一部の Node は `req.body.files` を元にファイルコピー処理を行っている

以下の `copyBinaryFile` 関数部分。

```ts
export async function prepareFormReturnItem(
  context: IWebhookFunctions,
  formFields: FormFieldsParameter,
  mode: "test" | "production",
  useWorkflowTimezone: boolean = false
) {
  // 中略
  returnItem.binary![binaryPropertyName] =
    await context.nodeHelpers.copyBinaryFile(
      file.filepath,
      file.originalFilename ?? file.newFilename,
      file.mimetype
    );
  // 中略
}
```

ref: https://github.com/n8n-io/n8n/blob/c8d604d2c466dd84ec24f4f092183d86e43f2518/packages/nodes-base/nodes/Form/utils/utils.ts#L401

この `prepareFormReturnItem` は例えば Form Node Webhook の処理で呼ばれている。

https://github.com/n8n-io/n8n/blob/c8d604d2c466dd84ec24f4f092183d86e43f2518/packages/nodes-base/nodes/Form/Form.node.ts#L385

`copyBinaryFile` の実体は設定やワークフローよって異なるが、要するにファイルのコピーである。たとえば次の `objectStoreService` による実装であれば S3 とか minio にコピーされる。

e.g. https://github.com/n8n-io/n8n/blob/master/packages/core/src/binary-data/object-store.manager.ts#L71

これらを 3 つを組みわせると、

```json
{
  "files": {
    "field-0": {
      "filepath": "/secref_file.txt"
    }
  }
}
```

のような `application/json` Content-Type のリクエストが `prepareFormReturnItem` に渡った場合、`/secref_file.txt` というサーバー内の秘匿されるべきファイルが `copyBinaryFile` によって外部ストレージにコピーされてしまう、ということになる。

実際、`prepareFormReturnItem` はまさにその問題を抱えていたため、今回の Ni8tmare に繋がった。

[この diff](https://github.com/n8n-io/n8n/commit/c8d604d2c466dd84ec24f4f092183d86e43f2518#diff-39ac99709c6ad7f5afcecf27714dbea6fb7fbcc8fda0a9e04a2e1ec05a92f473) を見ると、まさに `prepareFormReturnItem` でリクエストの Content-Type が `multipart/form-data` であることをチェックするように修正されていることがわかる。

## Tailwind CSS のレイオフ問題

https://github.com/tailwindlabs/tailwindcss.com/pull/2388#issuecomment-3717222957

> しかし現実は、AI が私たちのビジネスに与えた壊滅的な影響により、昨日エンジニアリングチームの 75%が職を失ったのです。そして、コミュニティのためにこのような楽しい無料の活動に費やす時間は、ビジネスを立て直し、まだここにいる社員が毎月きちんと給料をもらえるようにするための時間ではないのです。

Tailwind CSS は Tailwind Labs という企業がメンテしている。
Tailwind Labs は Tailwind Plus(旧 Tailwind UI) をライセンス販売するという収益モデルだが、AI の台頭と AI が Tailwind CSS を積極的に利用してきた結果の帰結が 75% のエンジニアレイオフというのは中々のインパクト。

AI が出力しやすいことが、人間が読みやすいことには繋がっておらず、またそもそもの Vanilla な CSS との乖離も激しいことを考えるといつまで経っても Tailwind は好きになれないが、それとは別にして AI を中心としたコミュニティに指示されたことが OSS の持続性を損なうというのはなぁ。。。

---

# 1/13

## Zodios で TS2589 エラー

おしごとにて。

openapi-zod-client を使って OpenAPI の YAML から Zodios のクライアントを自動生成したら以下のエラーに遭遇。

```
TS2589: Type instantiation is excessively deep and possibly infinite
```

エンドポイントの数を削ると解消される。

- OpenAPI で `$ref` が多用されている事が問題かと思い、Response などを inline 展開するなどを試したが、あまり効果がなかった。
- https://github.com/astahmer/openapi-zod-client/issues/308 が関係しているかと思ったが、Description に記載されているように Handlebars のテンプレートを変更しても解消されず。

---

# 1/14

## Node.js のセキュリティアップデート

2025 年末からペンディングとなっていた Node.js のセキュリティアップデートが公開された。

https://nodejs.org/en/blog/vulnerability/december-2025-security-releases

うち、Severity が High のものは以下の 3 件

- Timeout-based race conditions make Uint8Array/Buffer.alloc non-zerofilled (CVE-2025-55131) - (High)
- Bypass File System Permissions using crafted symlinks (CVE-2025-55130) - (High)
- Node.js HTTP/2 server crashes with unhandled error when receiving malformed HEADERS frame (CVE-2025-59465) - (High)

特に 3 番目のものについては、 Async Local Storage が Uncaught Error (Stack overflow) を起こす可能性があり、 Next.js や 各種 APM (e.g. Datadog, NewRelic) がリクエストコンテキストの維持に ALS を利用する都合上、影響範囲は大きめ。
この件についての詳細な記事も別途上がっていた。

https://nodejs.org/en/blog/vulnerability/january-2026-dos-mitigation-async-hooks

脆弱性とは直接関係ないが、上記の記事を読んでいて、 Node.js v24 以降では ALS の実装が `async_hooks` ベースのものから V8 `AsyncContextFrame` という機能をベースとしたものに差し替えられていることを初めて知った。

---

# 1/15

## コンポーネント作成を AI に任せる場合のワークフローについてもやもや考えてみる

GPT に壁打ちしながら整理。

> ## Agent×VRT（Figma 一致）ワークフローまとめ（理解＋補足）
>
> ### 前提
>
> - Agent には人間のような高度な「目」はない。
> - そのため「検知・診断・合否判定」をワークフロー側で補う必要がある。
>
> ### 目的
>
> - 新規作成時：Figma（Design Golden）に対して “十分に一致” を担保する
> - 既存変更時：Regression Golden に対して “意図しない崩れ” を検知する
>
> ---
>
> ## 1. 間違っていることを伝える（検知＝機械が担当）
>
> - Pixel diff / SSIM / LPIPS を併用し、見た目のズレをスコアで検知する
> - 単一指標に寄せず、複数指標で「レイアウト」「知覚的差分」をカバーする
> - 合否の最終判断（Pass/Fail）は原則「機械ルール」または「人間レビュー」で行う
>   - 判定を AI に任せると再現性が落ち、運用がブレやすい
>
> ---
>
> ## 2. 何が間違っているかを伝える（診断材料＝機械が提供）
>
> - 画像由来の局在化
>   - diff ヒートマップ、差分 bbox（どの領域がズレているか）
> - DOM/スタイル由来の説明（構造比較の現実解）
>   - Figma ノードツリー vs DOM ツリーの同型比較は破綻しがち
>   - 代わりに「部位（root/label/icon…）単位」の期待値 vs 実測を比較する
>     - getComputedStyle：padding / gap / font / color / shadow / radius…
>     - bounding box：サイズ、距離、整列（中央寄せ、アイコン間隔など）
>   - token 逸脱（ハードコード値）も静的解析で検出すると安定する
>
> ---
>
> ## 3. Agent にやらせること（修正＝ AI が担当）
>
> - 検知結果（スコア）＋局在化（ヒートマップ/bbox）＋ DOM 差分（style/距離）を入力として
>   - 差分のカテゴリ分け（余白/タイポ/色/影/整列…）
>   - 原因推定（token 不一致、制約不足、状態再現漏れ等）
>   - 修正案生成（CSS/Token/レイアウト修正）→ 再計測のループ
> - 「合否判定」は AI に任せず、AI は「直す」ことに集中させる
>
> ---
>
> ## 4. 運用を安定させるコツ（ゲート設計）
>
> - Gate1：レイアウト崩れ検知（例：SSIM）
> - Gate2：知覚差分の許容判断（例：LPIPS、色差、タイポ/spacing の DOM 検査）
> - Gate3：グレーのみ人間レビュー（diff 画像と AI 診断付き）
> - 目的は「AI が延々と微調整」しない仕組みを作ること

---

# 1/16

## ラスタからベクタ画像を取得

あまりそんな例はないかもしれないが、 Figma のとあるノードがラスタ画像で提供されていたが、アニメーションさせる都合で SVG に変換したい、というケースに遭遇した。
Rect, Circle のみで構成できそうな画像であったものの、それぞれのサイズや位置がわからなくてどうしようと思いつつ、 GPT に PNG 渡して「 SVG に変換して」と頼んだらやってのけてくれた。

---

# 1/19

## Waku の 1.0 Alpha リリース

昨年末に 1.0 Alpha リリースされていた。 Public API は Stable 扱いとのこと。

https://waku.gg/blog/waku-v1-alpha

## HTML の geolocation 要素について

https://developer.chrome.com/blog/geolocation-html-element

## Safari TP 234 で grid-lanes 実装

https://webkit.org/blog/17660/introducing-css-grid-lanes/

Grid Lanes の実装、ちょうど去年にめちゃくちゃ調べてた頃に TP として上がってたみたい。

## Web Almanac 2025

https://almanac.httparchive.org/en/2025/

[CSS Tricks](https://css-tricks.com/http-archive-2025-web-almanac/) 経由で見つけた。

Font や Web Assembly など、様々な切り口で技術要素がどのように Web で利用されているかを分析したもの。

コンテンツがかなり多いので読みきれてないが、かなり面白そう。

---

# 1/20

## `@vercel/og` の内部実装

`@vercel/og` パッケージが、以下に OG Image を生成しているかについて、同僚と盛り上がった。

- https://github.com/vercel/satori で、HTML / CSS を SVG に変換
- SVG を更に https://github.com/thx/resvg-js で PNG に変換

という流れ。

---

# 1/21

## Vim

今開いてるバッファのパスを Agent に教える、というシーンがあまりにも多いので、以下のコマンドを map に追加した。

```vim
:let @* = expand('%')
```

---

# 1/22

## gh コマンドの gitHub.com と GHES 切り替え

元々 gh コマンドは github.com の方でしか使っておらず、 GHES で管理されているレポジトリでは利用していなかったが、AI Agent に PR 情報などを取得させるために GHES でも gh コマンドを利用したいシーンが増えてきた。
こうなると、カレントワーキングディレクトリの git レポジトリがどちらで管理されているかによって、自動で gh コマンドのホストを解決させたいわけだが、少し小細工をしないと無理。

同じ悩みは皆持っているもので、 "gh コマンド github com GHES 切り替え" などでググると色々出てくる。

https://qiita.com/yamause/items/b91308633404042b977c にある通り、 gh コマンドは環境変数 `GH_HOST` を見て接続先を決定しているため、これを利用することにした。

```sh
# .zshrc に以下を追記しておく

if [ "$(git config --get user.email)" = "$GHES_EMAIL" ]; then
  export GH_HOST=$GHES_HOST
fi
```

github.com と GHES でログインアドレスが異なるため、これを利用するようにしている。
Global の Git Config では github.com のメアドを設定しておき、 GHES 管理のレポジトリについては、レポジトリレベルで ./.git/config に `user.name` と `user.email` を設定しておくイメージ。

本当は alias か何かで `gh` 実行時に都度評価する方がいいのだろうが、自分のユースケースだとそこまでは問題にならないのでまずはこれで様子見。

## react-grab 使ってみた

以前から少しだけ気になっていた https://www.react-grab.com/ を試しに使ってみた。

確かにブラウザから、コンポーネントや要素の、ソースコード上の位置を教えることができる、というんはあるが、思ったほど便利でもない。

1. Vim と Claude Code の双方を Terminal で開いているため、エージェントにファイル名を伝えたいだけであれば、昨日用意した `let @* = expand('%')` に割り当てた nmap を実行し、Claude Code の TUI にペーストする方がキーボードのみの操作で済む分速い
2. エージェントに要素の位置を伝えたところで、後続のタスクがそこまでうまく回ってない。スタイル修正のようなシーンで利用 grab を利用したいが、その UI 自体が既に Figma MCP を参照させて作らせた以上、修正指示を出してもそれ以上のことをしてくれない。かといって、「この要素の色は Design Token のこれこれで〜」をプロンプトに書くのもだるい。それであれば自分でスタイル編集する方がまだまだ効率がいい

---

# 1/27

## コーディングエージェントとシステムプロンプト

https://qiita.com/cozyupk/items/bf5637f40d59e18c4d5e を読んでいて、以下の部分でなるほど、と思った。

> さもないと、次のようなことをしてしまう恐れがあります。
>
> - （実はシステムプロンプトと矛盾している）指示が効かないことでハマったり思い悩んだりする。
> - AI(LLM)が 「クソコード」 しか生成しないものと思い込んでしまう。
> - それがヴァイブコーディングや AI(LLM)の本質だと勘違いしてしまう。
> - 実際には「システムプロンプト」と戦っているのに、AI(LLM)と戦っていると勘違いしてしまう。
> - 勘違いしたまま、X やブログでその感触を吹聴してしまう。(私もやらかしています w)
>
> そして、後にも書きますが、「システムプロンプトに反する指示を書いたとしても、エージェントは警告なしでその指示を受け流したり曖昧に動作したりすることが多い」 というところが非常に厄介なところです。
>
> かつ、「システムプロンプト自体は非公開」 であり、「システムプロンプト内にも後から上書き指示が効く領域と上書き指示が効かない領域がある」 のも話を多少複雑にしています。

実際、Claude Code + Opus 4.5 に、以下を訪ねたところ、「リファクタリングはやらない」(= ボーイスカウトはしない) と返答があった。

```md
次の点でキミのシステムプロンプトに従った考え方を書いて

- コード修正のボリュームに関する指示
```

> ⏺ システムプロンプトに基づく「コード修正のボリュームに関する考え方」をまとめます：
>
> ---
>
> コード修正は最小限に
>
> 基本原則
>
> - 依頼された変更のみを行う - 必要な修正だけを実施し、「ついでに」の改善は避ける
> - シンプルさを維持する - 最小限の複雑さで現在のタスクを完了させる
>
> 具体的な指針
>
> やるべきこと
>
> - バグ修正なら、そのバグだけを直す
> - 機能追加なら、その機能だけを実装する
> - 変更したコードに必要なコメントだけを書く
>
> やるべきでないこと
>
> - 周辺コードの「ついでの」リファクタリング
> - 変更していないコードへの docstring/型注釈の追加
> - 起こりえないシナリオへのエラーハンドリング
> - 1 回しか使わない処理のためのヘルパー関数作成
> - 将来の仮想的な要件に備えた設計
> - 不要な設定オプションや拡張性の追加
>
> 判断基準
>
> 3 行の類似コード > 早すぎる抽象化
>
> 同じようなコードが 3 行あっても、それを共通化するヘルパーを作るより、そのまま残す方が良い場合が多い。
>
> 削除について
>
> - 使われていないコードは完全に削除する
> - \_unused へのリネームや// removed コメントは不要
> - 後方互換性のためのハックは避ける
>
> ---
>
> 要するに「今必要なことだけをやる」という考え方です。

確かに仕事での機能開発においては、大概のケースで上記の指針で正しいのだけど、リファクタや負債解消を行いたい際には、上記のシステムプロントと相反している可能性があることは念頭に置いておくと良さそうではある。
