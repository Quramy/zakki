# 9/3

## Storycap のメンテナンス

発端は https://github.com/reg-viz/storycap/issues/896 の issue.

「最新の Chromium (128) で Storycap が Puppeteer の起動に失敗する」という内容で、マジだとすると割と問題なため、重い腰を上げて調査に乗り出す。

と思ったら、直近の CI がそもそもコケにコケているので、まずは必要最小限レポジトリを綺麗にするところから。

### jest と併用するとバグる

以前にも見たような気がするが、Jest で `compositeStories` を利用した際に

```
Cannot find module 'storybook/internal/preview-api'
```

というエラーが出てしまう。

Storycap の Managed Mode でしか起きないため、 Preview 経由で Storyshots の Decorator を import しているのが直接原因であることはわかるんだが、なんでこんなエラーが起きるのかがわからない。

諦めて CI で Jest 回すのを一旦停止。

### yargs upgrade

以前に typed-css-modules でも同じ対応をしたことあるが、そのときの PR を引っ張り出して対応方法を思い出す。

https://github.com/reg-viz/storycap/pull/898/files

Node.js の下限を v20 にするのであれば、Node.js 組み込みの args parser 使えばよいのでは？と思うが、型当てたりが面倒そうなので結局やっていない。

### 調査

本題の https://github.com/reg-viz/storycap/issues/896 について:

結論から書くと、自分では 「Puppeteer の Launch に失敗する」を再現することはできなかった。

しかし、同じ Issue のコメントにあるタイムアウトエラーについては、一部再現。

> I encountered a similar issue in my project after the Chrome version of GitHub Actions was updated yesterday. The following error caused Storycap to stop working:
>
> TimeoutError: Navigation timeout of 60000 ms exceeded
>
> As a temporary solution, it can be fixed using the previous version of Chrome.

一部、というのは特定の状態でしか起きない。

確認できた再現条件は下記:

- Linux 向けに Build された Chromium (v128 以降) であること(mac だと再現しない)
- Storybook を Production build していること(bundler は Vite 版で確認)

Storycap は最初に Preview API をぶっ叩いて Story 一覧を取得するため、 Preview iframe HTML をロードする.

```ts
await page.goto(storybookPreviewURL, {
  timeout: 60_000,
  waitUntil: "domcontentloaded",
});
```

この `goto` メソッド呼び出しで Timeout Error が発生していた。
Storybook を serve している Web Server(`http-server` コマンド) のログも眺めていたが、アセットの応答を完了仕切っている様子なので、`domcontentload` どころか `onload` まで完了していてもおかしくなさそうな挙動。通常どおりサブリソースの読み込みが行われていることは明らかなので、上記の `goto` にかかる `await` を外したところ、現象が解消したため、まずはこれを Fix PR として作成。

https://github.com/reg-viz/storycap/pull/902

「なぜ Navigation Timeout が発生するようになったのか」の根本解決にいたってないままなので、あまり気分のよいものではないが。。。

---

# 9/4

## Storycap w/ Chromium 128 がコケる問題

昨日に引き続き、https://github.com/reg-viz/storycap/issues/896 の件。

ありがたいことに、昨日出した pre patch version を試してくれた方が「直った！」の旨をコメントしてくれた。もともと issue に参加していた方とは別の人だったけど、即レスつけてもらえて本当に感謝しかない。

ということで、原因がわからないので釈然としていない気持ちは残っているものの、Fix PR を merge して released.
あとは問題が終息してくれるのをまつだけ。

Storycap, なんだかんだ Process 周りが複雑なせいもあって、こういう問題に対する解決コストがすごく高くなっちゃってるんだよなぁ。。。
prisma-fabbrica 辺りと比べると、「見るか」となるハードルが全然違うというか。

## Remix の RSC 対応

KCD が https://x.com/kentcdodds/status/1831272059726369236 で投稿していた。

リンクされているのは Vite の PR: https://github.com/vitejs/vite/pull/16471

この PR からさらにリンクされている Vite の "Environment API" というところを読むと、以下のように書いてあった。

> Since Vite 2, there were two implicit Environments (client and ssr). Plugin Hooks received a ssr boolean in the last options parameter to identify the target environment for each processed module.

Vite の使い方を全然しらなかったのだけど、Vite は SSR / Browser という 2 値でのみ「環境」を表現していて、且つ Vite plugin には「環境がいずれなのか」が bool 値で渡されていたとのこと。

確かに RSC への対応を考えると、バンドラのレイヤで "react-server" Condition (Condition という言い方は Node.js が定めた言い方なので、それにとらわれなければ "Environment" の方がしっくりくる) を処理しなくてはならない。

Next.js が Turbopack / webpack に対して、Server 用のバンドルを作る際に "react-server" を Community Condition として設定しているのと同様のことを、Remix の Vite Plugin が行う必要がある。

これを考慮すると、そもそもの Vite 側が Community Condition 相当を使えるようにしなくてはいけない、ということで得心した。

---

# 9/5

## AWS Lambda の裏側を理解する

https://dev.classmethod.jp/articles/devio-osaka-2024-lambda-coldstart/

この資料にかなり細かく記載されていた。

- Worker ( Bare Metal EC2 Instance)
  - Firecracker(ハイパバイザ)
    - MicroVM Kernel (VM, Amazon Linux)
      - Lambda Sandbox
        - Execution Environment
          - Ephemeral Storage ( `/tmp`)
          - Lambda Function

ref: https://docs.aws.amazon.com/whitepapers/latest/security-overview-aws-lambda/lambda-executions.html

---

# 9/10

## Next.js v14.2.9

https://github.com/vercel/next.js/releases/tag/v14.2.9

v14.2.8 で割と致命的なやらかし (特に https://github.com/vercel/next.js/issues/69756 など) があったが、さすがにすぐ fix が入った。

## JavaScript の `?=` 演算子と try catch

https://javascript.plainenglish.io/say-goodbye-to-try-catch-with-this-new-ecmascript-operator-e2b798c7b7a8

## GraphQL Federated Schema の今後

https://graphql.org/conf/2024/schedule/75386a4288d49dcb4aba5b54e475de43/?name=Panel%3A%20The%20Composite%20Schemas%20Working%20Group に以下のようにあったので、調査の詳しい内容を読みたくなる:

> Gartner reports that by 2027, production use of federated GraphQL in enterprise systems will grow sixfold

https://www.apollographql.com/resources/gartner-when-to-use-graphql-to-accelerate-api-delivery の先から Gartner の資料 DL form に飛べる.

- [Postman の 2023 調査資料](https://www.postman.com/state-of-api/api-technologies/#api-technologies)
  - SOAP と GraphQL の Usage が初めて逆転した
    - 逆に 2022 までは SOAP > GraphQL だったということらしい。
    - それだけ過去に採用した技術を剥がすというのは大変だということなんだろうな。
- [Walmart の Federated GraphQL について. 2020](https://medium.com/walmartglobaltech/federated-graphql-walmart-bfc85c2553de)
  - 2020 なので、少し古めの内容
  - Apollo Federation 使ってる
  - Query Planning (GraphQL における Query Planning って何？) の話題あり.
- [infoQ に掲載された Netflix の事例](https://www.infoq.com/articles/federated-GraphQL-platform-Netflix/)

## Findy GraphQL イベント

https://findy.connpass.com/event/328076/ の登壇 :memo:

自分以外の LT:

### GraphQL 導入への技術選定

https://speakerdeck.com/matsudamper/graphqldao-ru-henoji-shu-xuan-ding

- Native App の BFF として REST -> GraphQL
- Signed Query について触れられていた
  - PQ は S3 に upload (世代管理は無制限) とのことなので、運用負荷で考えると Signed Query の方が向いているかもしれない

### エラーレスポンス設計から考える、0→1 開発における GraphQL への向き合い方

(メモ取る余裕なし)

---

# 9/11

## Next.js と dd-trace の悪夢ふたたび

一旦自分の中では終息していたつもりの instrumentation.ts と dd-trace の関係が再び良く分からなくなってきた。

https://github.com/DataDog/dd-trace-js/issues/3457#issuecomment-2338110740 にて、「 `logInjection` はちゃんと動くの？」と聞かれて、ちょっと調べてみようと思ったのが地獄の一丁目だった。

tracer を init したときに winston や pino などのロガーに Patch を当ててると踏んで、いつもの SC external package にこれらを追加すればいいっしょ、、と思ったのだが、そう甘くはない模様。

確かに `dd` オブジェクトは Inject されるが、肝心の `dd.trace_id` や `dd.span_id` が含まれていない。

init した側で `http.client` の Request Hook で span から Trace ID をたどると表示されるので、Tracer が動作していないということはない。

## `fetch` API の計装

Datadog: fecth patch, Sentry-node: Node.js Diagnostics Channel でそれぞれ計装を実装していたわけだけど、そもそもとして、以下のような現状の情勢がある:

- `fetch` API: Web 標準 API として WinterCG が標準化
- Tracing: Open Telemetry が事実上のスタンダード

Open Telemetry に限らず、分散トレースを実装する場合は HTTP Client の Header に Trace ID や Span ID を付与するように計装するのが基本。
どこでも動かせる `fetch` API が「ランタイムに依らずに計装が可能」とできるんだろうか？という疑問が湧いてきた。

Datadog の Instrumentation 手法を「モンキーパッチだ」と言って批判することは簡単なんだけど、じゃぁ Sentry の方法は Deno や Bun や Cloudflare Workers で動作すんの？という。

とりあえず OTel の実装を紐解いてみると、`fetch` 用と銘打っている計装はやっぱり `global` を汚染する方法になっている。
ref: https://github.com/open-telemetry/opentelemetry-js/blob/main/experimental/packages/opentelemetry-instrumentation-fetch/src/fetch.ts#L468-L480

一方で undici 用の計装も提供していて、こちらは Diagnostics Channel での実装。
ref: https://github.com/open-telemetry/opentelemetry-js-contrib/blob/main/plugins/node/instrumentation-undici/src/undici.ts#L105-L119

実装としては Diagnostics Channel を使う方が綺麗ではあるけれど、Node.js にしたところで `fetch` API の `Request`, `Response` interface (hono や msw でよく見かけるアレ) ではなく、 undici の内部実装としての `Request`, `Response` オブジェクトが渡ってくるだけ。
まぁ `globalThis.fetch` が Node.js で利用できるようになった事自体が割と最近目の話ではあるから仕方ないのか？という気もするが。

Diagnostics Channel それ自体か、これに類するものが無いと、標準的な Instrumentation は達成できず、Bun や Deno に対して 計装を提供する側が個別にフックポイントを見つけては実装する世界にしかならない。
さもなければつべこべ言わずに global にパッチを当てることを受け入れろ、というふうになりそうな。。。

なお、Deno も Bun も Diagnostics Channel そのものは実装されているが、`fetch` を Subscribe できるかどうかは不明(Node.js の undici も built-in-channel ではないため)

- https://docs.deno.com/runtime/reference/node/#built-in-module-support
- https://bun.sh/docs/runtime/nodejs-apis

Instrumentation を実装しようとした場合、Trace や Span の Context を情報を計装が参照することになるが、これはまぁ ALS で必要十分そうなのよな。

https://github.com/wintercg/proposal-common-minimum-api/blob/main/asynclocalstorage.md

Diagnostics Channel かどうかはさておき、「 `fetch` API を監視できる標準的な仕組」が必要そうに思えるけど、どこを探したらいいんだろ？ WinterCG の Common Minimum APIs にはそういう Issue なさそうだし。OTel 側なのか？

## 「人間をリソースと呼ぶことの何が問題なのか」

https://ohbarye.hatenablog.jp/entry/2024/09/11/human-resource-failure

TL で流れてきたはてブのエントリ。
「人的資源」に代表される、社員・労働者を「リソース」と呼称することに対しての見解、解説が丁寧に書かれている。

自分としては、そもそも以下のような対立関係があること自体が初見というか、「そんなこと気にしたこともなかった」という鈍感状態。

> 「モノ扱いしないでほしい」vs「とは言っても経営管理上はヒト・モノ・カネ・情報はリソースでしょ」

このエントリの本筋には実のところさして興味もなかったし、読了後も興味はないままなのだけど、以下の一節で連想した事柄があった。

> （余談）呼称が問題を生むのか、問題が呼称に現れるのかについては因果性のジレンマである

問題と言葉の因果関係というか、ある問題を指し表すために創出された呼称が一人歩きを始め、当初の意図とは異なる意味を持ってしまた例としての「技術的負債」の話を思い出した。

https://t-wada.hatenablog.jp/entry/ward-explains-debt-metaphor

技術的負債についても、人によって受け取られ方が違うという認識を持ってしまい、「誤解を招くのであればもう使わない」と決めた term の一つ。
今回の「人的資源」を自分の禁止辞書に含めるかはさておき、言葉って難しい。
