# 9/3

## Storycap のメンテナンス

発端は https://github.com/reg-viz/storycap/issues/896 の issue.

「最新の Chromium (128) で Storycap が Puppeteer の起動に失敗する」という内容で、マジだとすると割と問題なため、重い腰を上げて調査に乗り出す。

と思ったら、直近の CI がそもそもコケにコケているので、まずは必要最小限レポジトリを綺麗にするところから。

### jest と併用するとバグる

以前にも見たような気がするが、Jest で `compositeStories` を利用した際に

```
Cannot find module 'storybook/internal/preview-api'
```

というエラーが出てしまう。

Storycap の Managed Mode でしか起きないため、 Preview 経由で Storyshots の Decorator を import しているのが直接原因であることはわかるんだが、なんでこんなエラーが起きるのかがわからない。

諦めて CI で Jest 回すのを一旦停止。

### yargs upgrade

以前に typed-css-modules でも同じ対応をしたことあるが、そのときの PR を引っ張り出して対応方法を思い出す。

https://github.com/reg-viz/storycap/pull/898/files

Node.js の下限を v20 にするのであれば、Node.js 組み込みの args parser 使えばよいのでは？と思うが、型当てたりが面倒そうなので結局やっていない。

### 調査

本題の https://github.com/reg-viz/storycap/issues/896 について:

結論から書くと、自分では 「Puppeteer の Launch に失敗する」を再現することはできなかった。

しかし、同じ Issue のコメントにあるタイムアウトエラーについては、一部再現。

> I encountered a similar issue in my project after the Chrome version of GitHub Actions was updated yesterday. The following error caused Storycap to stop working:
>
> TimeoutError: Navigation timeout of 60000 ms exceeded
>
> As a temporary solution, it can be fixed using the previous version of Chrome.

一部、というのは特定の状態でしか起きない。

確認できた再現条件は下記:

- Linux 向けに Build された Chromium (v128 以降) であること(mac だと再現しない)
- Storybook を Production build していること(bundler は Vite 版で確認)

Storycap は最初に Preview API をぶっ叩いて Story 一覧を取得するため、 Preview iframe HTML をロードする.

```ts
await page.goto(storybookPreviewURL, {
  timeout: 60_000,
  waitUntil: "domcontentloaded",
});
```

この `goto` メソッド呼び出しで Timeout Error が発生していた。
Storybook を serve している Web Server(`http-server` コマンド) のログも眺めていたが、アセットの応答を完了仕切っている様子なので、`domcontentload` どころか `onload` まで完了していてもおかしくなさそうな挙動。通常どおりサブリソースの読み込みが行われていることは明らかなので、上記の `goto` にかかる `await` を外したところ、現象が解消したため、まずはこれを Fix PR として作成。

https://github.com/reg-viz/storycap/pull/902

「なぜ Navigation Timeout が発生するようになったのか」の根本解決にいたってないままなので、あまり気分のよいものではないが。。。

---

# 9/4

## Storycap w/ Chromium 128 がコケる問題

昨日に引き続き、https://github.com/reg-viz/storycap/issues/896 の件。

ありがたいことに、昨日出した pre patch version を試してくれた方が「直った！」の旨をコメントしてくれた。もともと issue に参加していた方とは別の人だったけど、即レスつけてもらえて本当に感謝しかない。

ということで、原因がわからないので釈然としていない気持ちは残っているものの、Fix PR を merge して released.
あとは問題が終息してくれるのをまつだけ。

Storycap, なんだかんだ Process 周りが複雑なせいもあって、こういう問題に対する解決コストがすごく高くなっちゃってるんだよなぁ。。。
prisma-fabbrica 辺りと比べると、「見るか」となるハードルが全然違うというか。

## Remix の RSC 対応

KCD が https://x.com/kentcdodds/status/1831272059726369236 で投稿していた。

リンクされているのは Vite の PR: https://github.com/vitejs/vite/pull/16471

この PR からさらにリンクされている Vite の "Environment API" というところを読むと、以下のように書いてあった。

> Since Vite 2, there were two implicit Environments (client and ssr). Plugin Hooks received a ssr boolean in the last options parameter to identify the target environment for each processed module.

Vite の使い方を全然しらなかったのだけど、Vite は SSR / Browser という 2 値でのみ「環境」を表現していて、且つ Vite plugin には「環境がいずれなのか」が bool 値で渡されていたとのこと。

確かに RSC への対応を考えると、バンドラのレイヤで "react-server" Condition (Condition という言い方は Node.js が定めた言い方なので、それにとらわれなければ "Environment" の方がしっくりくる) を処理しなくてはならない。

Next.js が Turbopack / webpack に対して、Server 用のバンドルを作る際に "react-server" を Community Condition として設定しているのと同様のことを、Remix の Vite Plugin が行う必要がある。

これを考慮すると、そもそもの Vite 側が Community Condition 相当を使えるようにしなくてはいけない、ということで得心した。

---

# 9/5

## AWS Lambda の裏側を理解する

https://dev.classmethod.jp/articles/devio-osaka-2024-lambda-coldstart/

この資料にかなり細かく記載されていた。

- Worker ( Bare Metal EC2 Instance)
  - Firecracker(ハイパバイザ)
    - MicroVM Kernel (VM, Amazon Linux)
      - Lambda Sandbox
        - Execution Environment
          - Ephemeral Storage ( `/tmp`)
          - Lambda Function

ref: https://docs.aws.amazon.com/whitepapers/latest/security-overview-aws-lambda/lambda-executions.html

---

# 9/10

## Next.js v14.2.9

https://github.com/vercel/next.js/releases/tag/v14.2.9

v14.2.8 で割と致命的なやらかし (特に https://github.com/vercel/next.js/issues/69756 など) があったが、さすがにすぐ fix が入った。

## JavaScript の `?=` 演算子と try catch

https://javascript.plainenglish.io/say-goodbye-to-try-catch-with-this-new-ecmascript-operator-e2b798c7b7a8

## GraphQL Federated Schema の今後

https://graphql.org/conf/2024/schedule/75386a4288d49dcb4aba5b54e475de43/?name=Panel%3A%20The%20Composite%20Schemas%20Working%20Group に以下のようにあったので、調査の詳しい内容を読みたくなる:

> Gartner reports that by 2027, production use of federated GraphQL in enterprise systems will grow sixfold

https://www.apollographql.com/resources/gartner-when-to-use-graphql-to-accelerate-api-delivery の先から Gartner の資料 DL form に飛べる.

- [Postman の 2023 調査資料](https://www.postman.com/state-of-api/api-technologies/#api-technologies)
  - SOAP と GraphQL の Usage が初めて逆転した
    - 逆に 2022 までは SOAP > GraphQL だったということらしい。
    - それだけ過去に採用した技術を剥がすというのは大変だということなんだろうな。
- [Walmart の Federated GraphQL について. 2020](https://medium.com/walmartglobaltech/federated-graphql-walmart-bfc85c2553de)
  - 2020 なので、少し古めの内容
  - Apollo Federation 使ってる
  - Query Planning (GraphQL における Query Planning って何？) の話題あり.
- [infoQ に掲載された Netflix の事例](https://www.infoq.com/articles/federated-GraphQL-platform-Netflix/)

## Findy GraphQL イベント

https://findy.connpass.com/event/328076/ の登壇 :memo:

自分以外の LT:

### GraphQL 導入への技術選定

https://speakerdeck.com/matsudamper/graphqldao-ru-henoji-shu-xuan-ding

- Native App の BFF として REST -> GraphQL
- Signed Query について触れられていた
  - PQ は S3 に upload (世代管理は無制限) とのことなので、運用負荷で考えると Signed Query の方が向いているかもしれない

### エラーレスポンス設計から考える、0→1 開発における GraphQL への向き合い方

(メモ取る余裕なし)
