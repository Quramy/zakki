# 12/9

## npm の Trusted Publishing

Classic Token の Revoke に伴い、いくつかのパッケージの CI を変更して Trusted Publishing を行うように変更。

https://docs.npmjs.com/trusted-publishers

上記のドキュメント通りに進めれば問題ないのだが、設定でドハマリした。

npm パッケージ側の設定として、以下の入力が必須である。

1. GitHub Organization (= User) 名
1. GitHub Repository 名
1. Workflow ファイル名

これらは Case Sensitive で入力する必要があるのだけど、最初、`quramy` と Organization 名に入力していたため、OIDC 認証が通らずに `npm publish` が失敗し続けた。
npm のアカウント名は `quramy` に正規化されていることもあって、ついつい先頭小文字で入力してしまっていたことに中々気づけなかった。

---

# 12/10

## Vitest の isolate の謎

Vitest の実行時間が遅い場合に「 `--no-isolate` を付与しろ」というのはよく聞く話である。

実際、自分の周囲でも複数の人から「isolate 外したら速くなった(が不安定になってしまった)」という趣旨の話を聞いたことがあった。

[公式の docs](https://vitest.dev/guide/improving-performance.html#test-isolation) でも以下のように書いてある。

> In this case disabling isolation will improve the speed of your tests.

そもそも、何がどのように「分離」されるのか、きちんと説明できるだろうか。

ドキュメントからは少し読み解きづらいが、`isolate` オプションが意味するところは「各テストファイルごとに新しいプロセスを fork するか否か」である。
厳密にはプロセス or スレッドが `pool` オプションで変わるが、ここではデフォルトの `pool: 'forks'` の場合のみを考える。

一方で Jest の場合は https://github.com/jestjs/jest/tree/v30.2.0/packages/jest-worker で似たような制御がされるわけだが、こちらは一度 Worker が作成したプロセスが (クラッシュなどしない限りは) 複数のテストファイルで再利用される挙動である。jest-worker もデフォルトでは `child_process` をなので、スレッドや `vmThread` ではなくプロセスベースの並列化であるのは Vitest と同様。

要するにだ、今まで Jest を使って数百ファイルのテストを実行していたプロジェクトが Vitest に移行して性能が下がるのは至極当たり前の話、ということである。

仮に `--max-workers=4` 程度の環境で 100 個の `*.test.ts` があるような場合、以下のようになり、プロセス生成の回数が文字通り桁違いだ。

- Vitest のデフォルト挙動: 100 回プロセスが fork される
- Jest のデフォルト挙動: 4 回プロセスが fork される

そもそも通常は Jest の `enableWorkerThreads` を ON にすることはあまりないだろうから、 Vitest に移行したとしても `pool` はデフォルト値のままだろうから、大概のプロジェクトで同じような話になるわけだ。

こうなってくると「Jest より Vitest の方が速い」という話自体が疑わしい。
なお、雑に Google の検索画面から 「jest vitest 比較」と入力して AI(おそらく Gemini) が出力した結果を見ても、Vitest が Jest に比べて「非常に高速である」と書いてきている。
トランスパイルレイヤで Vite の恩恵が受けられるというのは理解できるが、実プロジェクトのボトルネックがそこではない場合、 `pool` で `vmThreads` を指定したり、 `--no-isolate` を指定するなどをしない Vitest は高速化されない、というのが実情のはず。

もちろん、Jest からの移行直後に性能が悪いからといって Vitest を否定するつもりはなく、ネイティブで ESM を使えたり、ブラウザモードを簡単に用意できるなどの Jest にはない魅力がある点は変わらないが、こと性能に関する話としては少しフェアではないと感じた次第。

なお、Vitest が v0 系のころから GitHub の Issue 上では取り沙汰されていたトピックである模様。 https://github.com/vitest-dev/vitest/issues/579

以下は Copilot で Vitest の `isolate` 有無の挙動差異を説明させた出力の断片。

> 前提
>
> - テストファイル数 = 10（F1…F10）
> - maxWorkers は指定の値（1, 2, 4, 10）で固定
> - 「fork」はプロセスを生成することを指す（P1, P2, …）
> - 同一プロセス上で複数ファイルを実行する場合、isolate: false ではプロセスを再利用する。isolate: true ではファイル実行後にそのプロセスは終了（＝次のファイルのために別の fork を行う前提）。
> - 全ファイルの実行時間は均等で、ファイルが終わるタイミングで次のファイルが割り当てられる単純化モデルを用いる（実運用では時間差が出る）。
> - pool = 'forks' のみを考える。fileParallelism 等の別設定は無視する。
>
> ケース A: maxWorkers = 1
>
> - isolate: true
>
>   - 同時プロセス数の上限 = 1（ピーク同時 = 1）
>   - 各ファイルごとに新しい fork を行う → 合計 fork 回数 = 10
>   - タイムライン（縦が時間、横がプロセス）:
>
>     T1: fork P1 → P1 runs F1  
>     T2: P1 exits; fork P2 → P2 runs F2  
>     T3: P2 exits; fork P3 → P3 runs F3  
>     ...
>     T10: P10 runs F10
>
>   - 要約：peak concurrent = 1、total forks = 10
>
> - isolate: false
>
>   - maxWorkers = 1 なのでプロセスは 1 つだけ作る（P1） → 合計 fork 回数 = 1
>   - タイムライン:
>
>     T1: fork P1 → P1 runs F1  
>     T2: P1 runs F2  
>     T3: P1 runs F3  
>     ...  
>     T10: P1 runs F10
>
>   - 要約：peak concurrent = 1、total forks = 1（プロセス再利用）
>
> ケース B: maxWorkers = 2
>
> - isolate: true
>
>   - 同時に最大 2 プロセスが走る。合計 fork 回数 = 10（ファイル数）
>   - タイムライン（例、各タイムスロットで 2 ファイル消化）:
>
>     T1: fork P1 → P1:F1 ; fork P2 → P2:F2  
>     T2: P1 exits → fork P3 → P3:F3 ; P2 exits → fork P4 → P4:F4  
>     T3: fork P5 → P5:F5 ; fork P6 → P6:F6  
>     T4: fork P7 → P7:F7 ; fork P8 → P8:F8  
>     T5: fork P9 → P9:F9 ; fork P10 → P10:F10
>
>   - 要約：peak concurrent = 2、total forks = 10（必要に応じて新規 fork が繰り返される）
>
> - isolate: false
>
>   - 最初に maxWorkers (=2) のプロセスを作って使い回す → 合計 fork 回数 = min(2,10) = 2
>   - タイムライン:
>
>     T1: fork P1 → P1:F1 ; fork P2 → P2:F2  
>     T2: P1 reused → P1:F3 ; P2 reused → P2:F4  
>     T3: P1 reused → P1:F5 ; P2 reused → P2:F6  
>     T4: P1:F7 ; P2:F8  
>     T5: P1:F9 ; P2:F10
>
>   - 要約：peak concurrent = 2、total forks = 2（プロセス再利用）
>
> ケース C: maxWorkers = 4
>
> - isolate: true
>
>   - peak concurrent = 4、total forks = 10
>   - タイムライン（概念）:
>
>     T1: fork P1:F1, P2:F2, P3:F3, P4:F4  
>     T2: いずれか終了 → fork P5:F5 (その位置で新しいプロセスが生成される)  
>     T3: fork P6:F6, ... 進行して最終的に P10:F10 を生成
>
>   - 要約：peak concurrent = 4、total forks = 10（最大 4 つ同時、残りは都度新規 fork）
>
> - isolate: false
>
>   - peak concurrent = 4、total forks = min(4,10) = 4
>   - タイムライン（再利用）:
>
>     T1: fork P1:F1, P2:F2, P3:F3, P4:F4  
>     T2: P1 reuse → P1:F5 ; P2 reuse → P2:F6 ; ... 最終的に F10 を割付け
>
>   - 要約：peak concurrent = 4、total forks = 4（最初に 4 つ作り使い回す）
>
> ケース D: maxWorkers >= 10（例: 10）
>
> - isolate: true
>
>   - peak concurrent = min(10,10) = 10、total forks = 10
>   - タイムライン: T1 に P1..P10 を fork して同時実行（すべて独立）
>   - 要約：peak concurrent = 10、total forks = 10
>
> - isolate: false
>   - peak concurrent = min(10,10) = 10、total forks = 10
>   - タイムライン: T1 に P1..P10 を fork して同時実行（ただし再利用は発生しないが fork 回数は同じ）
>   - 要約：peak concurrent = 10、total forks = 10
>
> 数値まとめ（10 ファイルの場合）
>
> - isolate: true なら total forks = ファイル数（=10）（maxWorkers は「同時に何個立つか」に影響するが、最終的に各ファイル用にプロセスが作られるため合計は常に 10）
> - isolate: false なら total forks = min(maxWorkers, ファイル数)（プロセスは最大 maxWorkers 個しか作られず、再利用される）

---

# 12/16

## TanStack Start と Next.js App Router の比較

https://ondrejvelisek.github.io/tanstack-start-new-competitor-to-nextjs/

## React Grab と AI Agent

https://github.com/aidenybai/react-grab 自体 を始めて知った。

https://www.react-grab.com/blog/agent を読むと、 Agent に「この Component に対して、〇〇を〜」という指示を与える際の「この Component」部分を補助することができる模様。

元々はブラウザ上から Agent に対して指示を与えるための UI から発展させたのかな？

## Chromium の Accessibility Tree について

https://www.maxdesign.com.au/articles/two-trees.html

## TypeScript 7.0 の進捗周り

https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/

## Safari 26.2 で CSS の `field-sizing` が正式サポート

https://webkit.org/blog/17640/webkit-features-for-safari-26-2 より。

今年の 7 月頃に Safari Technology Preview で実装されていた `field-sizing` が正式サポートされた。
「textarea で `onChange` で都度都度 height を再計算する」という不毛な JavaScript から解放される日が近い。
もちろん Safari 26 が Widely Available になるまでの時間がかかるものの。

## `::spelling-error` と `::grammar-error` 疑似要素

上記の https://webkit.org/blog/17640/webkit-features-for-safari-26-2 で言及があったので。

それぞれ UA が判断したスペルミス・文法ミスが生じているテキストの区間を表す。
テキストの区間、という意味では `::selection` 疑似要素と似ている。

この疑似要素で指定可能な Properties もおよそ `::selection` で指定可能なものと似ているが、 例えば `outline` は `::selection` では指定不可能だが、 `::spelling-error` では指定可能であるといった細かい差異は存在している。

---

# 12/17

## Macbook 初期構築メモ

私用の Macbook pro を買い替えたので初期構築メモ

- Chrome install
- Better Touch Tool install
- Karabiner Elements install
- ITerm2 install

---

# 12/19

## 東京 Node 学園 47 時限目参加

### フロントエンドエキスパートチームの解散は「いい話」なのか？ by mugi

- 内容の :memo:
  - そもそも自分たちでチームを畳むことが「いい話」だけなわけがない
  - 支援と情報発信などを 1:1 とする健全性指標として定める
  - 支援割合がめちゃくちゃ高くなってしまう
  - FE の採用が増えるにつれ、エキスパートと そうではない FE との違いがわからなくなる

---

# 12/24

## uv 入門

https://note.com/nobita2041/n/n8262414a5782

---

# 12/26

## mac setup の続き

### brew の install

```sh
cd ~
mkdir opt
mkdir opt/homebrew
cd opt
curl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C homebrew
```

---

# 12/27

## Vim の +python3 ビルドが通らない

`--enable-python3interp` を有効にして build したいものの、configure が通らない。

```sh
./configure \
--prefix=/Users/quramy/opt/local \
--with-features=huge \
--enable-python3interp \
--enable-fail-if-missing
```

上記を実行すると、以下のような Python の config dir がない、と言われる

```txt
checking Python's install prefix... (cached) /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9
checking Python's execution prefix... (cached) /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9
checking Python's include path... (cached) /Library/Python/3.9/include
checking Python's include path... (cached) /Library/Python/3.9/include
(cached) checking Python's configuration directory... (cached)
can't find it!
```

brew で install した Python3 の場所を明示的に与えてみるも、

```sh
./configure \
--prefix=/Users/quramy/opt/local \
--with-features=huge \
--enable-python3interp \
--with-python3-command="$HOME/opt/homebrew/bin/python3" \
--with-python3-config-dir="$HOME/opt/homebrew/opt/python@3.14/Frameworks/Python.framework/Versions/3.14" \
--enable-fail-if-missing
```

以下のようにデフォルトの Python3 を読みにいってしまってる節がある。

```
checking Python's execution prefix... (cached) /Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9
checking Python's include path... (cached) /Library/Python/3.9/include
checking Python's include path... (cached) /Library/Python/3.9/include
(cached) checking Python's configuration directory... (cached) /Users/quramy/opt/homebrew/opt/python@3.14/Frameworks/Python.framework/Versions/3.14
cat: /Users/quramy/opt/homebrew/opt/python@3.14/Frameworks/Python.framework/Versions/3.14/Makefile: No such file or directory
checking Python3's dll name...
checking if -pthread should be used... no
checking if compile and link flags for Python 3 are sane... no: PYTHON3 DISABLED
configure: error: could not configure python3
```
