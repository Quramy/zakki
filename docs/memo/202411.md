# 11/1

## Change Data Capture

DB の同期を取るような文脈で CDC という略語があることを知った。

## Netlify と OpenNext

https://www.netlify.com/blog/netlify-joins-opennext

## RSC Payload と `AsyncIterable`や `ReadableStream`

React 側では https://github.com/facebook/react/pull/28847 で RSC ペイロードに `ReadableStream` と `AsyncIterable` を渡せるようになっている。
この PR の Merge タイミングが 2024.04.17 なので、 React v19 RC には乗っているのだと思う。

Next.js の v15 Stable に伴って、この機能も使えるようになったことになる。

Next.js の 14.x 系 Stable は React 19 を取り込まなかったからなのか、v14.2.16 などで試すと以下のエラーメッセージが出る。

```
Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like Symbol.asyncIterator are not supported.
```

これ、利用する機会あるんかなー。

`AsyncIterator` 使えるということは、ちょっとずつ SC を generate するようなことが原理的にはできそうだけど、React のコードとしてそれってどう書けばいいんだ？

sebmarkbage が PR Description で書いている以下部分もよくわからんし。

> AsyncIterables can also be returned as children of Server Components and then they're conceptually the same as fragment arrays/iterables. They can't actually be used as children in Fizz/Fiber but there's a separate plan for that.

## Web Stream API

RSC Payload に Readable Stream が使える、というのに付随して、そもそも Web Stream API ってなんだっけ、、、となった。

そういえば Web 標準に Stream があるらしい、というのは聞いてたけど、触ったことが一回も無かった。

とりあえず、Node.js で Web Stream をゴニョゴニョする話については、結構前に `@yosuke_furukawa` 会長が発表していたので、これを読む。

https://speakerdeck.com/yosuke_furukawa/whatwg-stream-falsehua

---

# 11/6

## Next.js と i18n

おしごとで i18n 対応が発生しそうな気配を察したので、軽く下調べ。

https://www.npmjs.com/package/i18next というライブラリの趨勢が強そうなので、まずはこいつを素振りする。

Next.js に組み込むには https://github.com/i18next/next-i18next というアダプタがあるにはあるのだが、こいつは完全に Pages Router 専用らしい。

App Router については https://locize.com/blog/next-app-dir-i18n/ で方法が紹介されている。

掻い摘んで書くと、

- SC と CC で `useTransalation` を別物として定義する
  - SC 用: react-i18next の `useTransalation` に Signature を似せた async 関数
  - CC 用: react-i18next が提供する `useTransalation` hook を少しラップして SSR 対応を入れたバージョン

いずれも、以下のような感じで使わせる想定。

```tsx
// SC の場合

import { useTranslation } from "@/lib/i18n";

export async function AwesomeComponent({ lng }: { lng: string }) {
  const { t } = await useTranslation(lng, "awesome-component");
  return (
    <>
      <h1>{t("title")}</h1>
    </>
  );
}

// CC の場合
("use client");

import { useTranslation } from "@/lib/i18n/client";

export async function AwesomeComponent({ lng }: { lng: string }) {
  const { t } = useTranslation(lng, "awesome-component");
  return (
    <>
      <h1>{t("title")}</h1>
    </>
  );
}
```

https://github.com/i18next/next-app-dir-i18next-example-ts に完品のコードがあったので、これを真似しつつやってみた。

https://github.com/Quramy/next-js-i18n-example

ほぼ locize の Blog 通りではあるが、言語ごとのリソースを Collocate するように変更してみた。

```
src/app
├── [lng]
│   ├── _components
│   │   └── Footer
│   │       ├── index.locale.en.json
│   │       ├── index.locale.ja.json
│   │       └── index.tsx
│   ├── globals.css
│   ├── layout.tsx
│   ├── page.locale.en.json
│   ├── page.locale.ja.json
│   ├── page.tsx
│   └── second-page
│       ├── page.locale.en.json
│       ├── page.locale.ja.json
│       └── page.tsx
└── i18n
    ├── client.ts
    ├── index.ts
    └── settings.ts
```

---

# 11/7

## i18next の Resource Collocation

https://github.com/i18next/i18next-resources-to-backend で Dynamic Import で Resource を取れるようになったはいいが、CC から使っている場合に Dynamic Import に対応する webpack require 取得が大量に発生してしまいそうな気がする。

Collocate した Resource を Route ごとに Composite できないと、Routing したときのパフォーマンス劣化しそう。Relay Compiler のようなものが必要になってしまう。

折り合いつけるとすると、`components` や 各 Feature 毎程度で Resource のファイルを分割しつつ、そこから参照するようなことにしかできないのかなぁ。。

## Event Source API が意外と便利ではないという話

https://zenn.dev/teramotodaiki/scraps/f016ed832d6f0d によると、以下とのこと。

> WHATWG の spec には書かれていないようなのですが（？）、EventSource では GET 以外のメソッドでリクエストを送れないんですよね。HTTP メソッドを指定するオプションがないようです。詳しいことは僕にもよく分かりません。

OpenAI API のような、今までの対話をガッと送りつけるような API の場合に、GET に縛られるのはつらそうである。

これ以外にも、接続断の場合の再送要求が発生するというのも、昨今の LLM 系と組み合わせるには都合が悪そう。

## tsimp と TypeScript 5.6 問題が解決していた

https://github.com/tapjs/tsimp/issues/29

---

# 11/8

## Ollama

ローカルで LLM API を利用したアプリケーションを組むのに使えそう。

https://github.com/ollama/ollama

---

# 11/12

## `ReadableStream` と `AsyncIterable`

WHATWG の spec だと、 `ReadableStream` は Async Iterable であることが規定されているが、
https://streams.spec.whatwg.org/#rs-asynciterator

Safari だと駄目。

https://caniuse.com/mdn-api_readablestream_--asynciterator

以下のような polyfill を当てるなりする必要がある。

```ts
ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
  const reader = this.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) return;
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
};
```

ref: https://stackoverflow.com/questions/76700924/ts2504-type-readablestreamuint8array-must-have-a-symbol-asynciterator

---

# 11/13

## Next.js Route Handlers が Streaming に対応していない件

今日も今日とて、text/event-stream 周りのお勉強。

Vercel AI SDK の Document を読んでいたところ、Next.js Pages Router で AI SDK を使う際に、Pages Router の API Routes ではなく、App Router の Route Handlers でサンプルが書かれていた。

https://sdk.vercel.ai/docs/getting-started/nextjs-pages-router#create-a-route-handler

```
src/
  app/
    api/
      chat/
        route.ts
  pages/
    chat.tsx
```

API Routes or Route Handlers の違いについて、今まではシグネチャが Node.js 寄りなのか、Web Standard 寄りなのか程度にしか思っていなかったが、Route Handlers の方がストリームのサポートの意味で優れている、という理由があるとのこと。

> As long as you are on Next.js 13+, you can use Route Handlers (using the App Router) alongside the Pages Router. This is recommended to enable you to use the Web APIs interface/signature and to better support streaming.

というよりも https://github.com/vercel/next.js/discussions/67026 を読むと、そもそも API Routes ではストリームがサポートされていないとある。

別に何が何でも API Routes で event-stream をやりたいわけじゃないのでいいのだが、気になったので自分でも試してみた。

まずは比較用に Next.js を廃して Node.js の `http.ServerResponse#write` でチャンクを書き込むパターン。

```js
/* server.mjs */

import { setTimeout } from "node:timers/promises";
import express from "express";

const app = express();

app.post("/api/express-stream", async (req, res) => {
  await setTimeout(300);

  res.writeHead(200, {
    "transfer-encoding": "chunked",
    "content-type": "text/event-stream",
    "access-control-allow-origin": "*",
  });

  const encoder = new TextEncoder();

  for (let i = 0; i < 10; i++) {
    res.write(encoder.encode(`data: ${JSON.stringify({ count: i })}\n\n`));
    await setTimeout(100);
  }

  res.end();
});

app.listen(4000, () => {
  console.log("server started");
});
```

ブラウザから以下の `fetch` 呼び出しを行う:

```ts
const res = await fetch("http://localhost:4000/api/express-stream", {
  method: "POST",
});

if (!res.ok) return;
const body = res.body;
if (!body) return;
const reader = body.getReader();
const decoder = new TextDecoder("utf8");
while (true) {
  const { value, done } = await reader.read();
  if (done) break;
  const chunk = decoder.decode(value, { stream: true });
  console.log(chunk);
}
```

Devtool の Event Stream は以下のようになる。期待通り、約 100 msec 毎に Time が打刻される。

| Type    | Data          | Time         |
| :------ | :------------ | :----------- |
| message | `{"count":0}` | 20:01:19.241 |
| message | `{"count":1}` | 20:01:19.665 |
| message | `{"count":2}` | 20:01:19.766 |
| message | `{"count":3}` | 20:01:19.877 |
| message | `{"count":4}` | 20:01:19.972 |
| message | `{"count":5}` | 20:01:20.075 |
| message | `{"count":6}` | 20:01:20.175 |
| message | `{"count":7}` | 20:01:20.277 |
| message | `{"count":8}` | 20:01:20.383 |
| message | `{"count":9}` | 20:01:20.484 |

続いて、件の API Routes 版。ハンドラの中身は先程の Express のハンドラと同一コード。

```ts
/* src/pages/api/api-routes-stream.ts */

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<unknown>
) {
  if (req.method !== "POST") {
    return res.status(404).end();
  }

  await setTimeout(300);

  res.writeHead(200, {
    "transfer-encoding": "chunked",
    "content-type": "text/event-stream",
  });

  const encoder = new TextEncoder();

  for (let i = 0; i < 10; i++) {
    res.write(encoder.encode(`data: ${JSON.stringify({ count: i })}\n\n`));
    await setTimeout(100);
  }

  res.end();
}
```

同じように Devtool で打刻された時刻を確認すると、先程の Express の場合とは異なり、すべて同一時刻となる。

| Type    | Data          | Time         |
| :------ | :------------ | :----------- |
| message | `{"count":0}` | 20:10:43.680 |
| message | `{"count":1}` | 20:10:43.680 |
| message | `{"count":2}` | 20:10:43.680 |
| message | `{"count":3}` | 20:10:43.680 |
| message | `{"count":4}` | 20:10:43.680 |
| message | `{"count":5}` | 20:10:43.680 |
| message | `{"count":6}` | 20:10:43.680 |
| message | `{"count":7}` | 20:10:43.680 |
| message | `{"count":8}` | 20:10:43.680 |
| message | `{"count":9}` | 20:10:43.680 |

確かに Next.js サーバー側で Outgoing Message の中身がバッファされて、end されたタイミングで吐き出すように手が入っているとしか思えない動き。Next.js のコード読んでみたけど、どの辺でここの処理してるかは追えず。
