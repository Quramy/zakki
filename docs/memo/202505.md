# 5/7

## Navigation API でブラウザバックのキャンセル

手元の Chrome で試しただけだが、ブラウザバック (`navigationType = "traverse"`) であったとしても、キャンセルできる。

```js
navigation.addEventListener("navigate", (event) => {
  event.preventDefault();
});
```

フォーム系の要件で頻出する「form が dirty なときにページ離脱前に確認を取る」というのも、以下のように実現できるということになる。

```js
navigation.addEventListener("navigate", (event) => {
  if (shouldConfirm(event) && !confirm("本当に離脱しますか")) {
    event.preventDefault();
  }
});
```

流石にこれは Polyfill でどうこうできる範囲じゃないと思うので、各ブラウザに実装が乗った前提での方式だけども。

## Next.js の `router.back()` と View Transition を協調動作できない

やりたいことは「ブラウザバック時にも View Transition Animation を効かせる」ということで、React に Transition Type を指定する目的で以下のようなコードを書いてみた。

```js
/* layout.tsx */

"use client";

import {
  ViewTransition,
  startTransition,
  useEffect,
  addTransitionType,
} from "react";

export default function ({ children }) {
  useEffect(() => {
    const ctrl = new AbortController();
    navigate.addEventListener(
      "navigate",
      (event) => {
        if (!shouldStartViewTransition(event)) return;
        event.intercept({
          async handler() {
            startTransition(() => {
              addTransitionType("back");
            });
          },
        });
      },
      { signal: ctrl.signal }
    );
    return () => ctrl.abort();
  }, []);

  return (
    <ViewTransition
      default={{
        default: "auto",
        back,
        forward,
      }}
    >
      {children}
    </ViewTransition>
  );
}
```

Navigation API 側で明示的に React の Transition を開始させた上で Transition Type を指定しておけば、後は Next.js と React がよしなにやってくれるんでは、という期待であるが、そうはならない。

というよりも、そもそも以下のコードのレベルでも View Transition にならない（ `back` ではなく `push` だと期待通りの動作になる )

```js
startTransition(() => {
  router.back();
});
```

また、Next.js の App Router の実装を見た感じでも、Pop State 時に明示的に Transition を使っているように見える。

https://github.com/vercel/next.js/blob/v15.4.0-canary.7/packages/next/src/client/components/app-router.tsx#L421-L429

ただ、該当行のコメントを読む感じ、そもそも Router の Cache が効いてる場合に Transition として扱う事自体に否定的に読めるし、まぁ 個人的にも back / forward に対してアニメーションがいるか？という気はする。

それはそうとして、なんで View Transition にならないんだろう。。。
考えられられるパターンとしては、Next.js 側が Traverse に対する更新処理を明示的に Transition 外で扱っているようなパターンかしら。
上記のコメントを鑑みると、そのような分岐が入っていても変ではないかもしれない。

## Astro と RSC の比較

おしごとで Astro をやるかもしれないので、ちょっと予習しておこうと思ったら、Dan Abramov 先生が RSC と Astro を比較する blog を書いていた:
https://overreacted.io/rsc-for-astro-developers/

なんなら `.astro` なるファイルがサーバーで処理される、ということすら初めて知った。

`npm create astro@latest` してかるーくお触りだけしておいた。

触り心地の First Impression でいうと、Vue っぽさが強い。 .astro が .vue と似ているところに引っ張られているだけだが。

Server side MVC との類似のほうが強く、 `client:load` のような Directive で Server から Client の世界に情報や Component (インタラクション) を持ち出せる点が従来の MVC との差異。

React や Vue との Integration を行わずとも Astro 単独で Client Component を用意することは可能であるが、`<script>` タグを描画できる、というだけなので、 インタラクティブな Component を作ろうとすると、生 DOM との戦いが待っているため、「Server で Render した HTML を ブラウザで DOM 操作する」という意味では JSP + jQuery と大差ない。
試しに、アコーディオン的な Client Component を Astro (というより生 DOM) で書いてみたが、`querySelector` や DOM 操作でうんざりした。なんなら jQuery の方がマシまである。
これを考えると、流石に Client Component 作る上では何かしらの UI Framework Integration が無いと厳しいが、仮に「Client Component は React」とという標準化をすると、Server Component (= .astro) と Client Component(react .tsx) で、コンテキストスイッチが発生することになる。
それだったら最初から React に寄せて、すなわち RSC を使った方が気が楽だと思うのだけど。

Dan 先生の blog における以下の箇所と似た肌感なのかもしれない。

> Sometimes, you might write a bunch of Astro Components and later realize that you’re gonna need to move that UI into Client Islands (tweaking the syntax along the way) or even duplicate it because some dynamic UI also wants to drive them. With RSC, you can extract the shared parts and import them from both sides.
> It is less important to think through “this part will mostly be dynamic” or “this part will mostly be static” for every piece of UI because you can always add or remove 'use client' and/or move it up or down the import chain with little friction. You do decide where to “cut the door”, but there’s no “converting” back and forth.
