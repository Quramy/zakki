# 2/3

## ブラウザバック時の form の値が restore される問題

Gemini 相手に HTML Living Standard を壁打ち。途中何回も嘘付いてきたので、やつの回答の精査に時間がかかった。

ある input 要素に autocomplete="off" を付与したページが存在していたとする。
このページに「戻る」動作を行った場合、値の復帰が UA によって実行されるかどうかは以下の通り:

- A: bfcache が有効な場合: UA による値の復帰は仕様上行われない。 bfcache からの復元において、reset されるべき仕様が MUST で存在しているため[^1]
- B: bfcache が無効な場合: UA による値の復帰は行われない可能性が高い。autocomplete="off" であるフォーム要素の値の記憶が推奨されていないため[^2]

[^1]: "For each formControl of form controls in document with an autofill field name of "off", invoke the reset algorithm for formControl." と bfcache からの Reactivate flow に明記されている. https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-document
[^2]: "When an element's autofill field name is "off", the user agent should not remember the control's data" とある. https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill-processing-model

---

# 2/4

## 続・ブラウザバック時の form の値が restore される問題

昨日に引き続き調査。

[Updating the document](https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-document) が UA で実行される際の、6.4.4 "Restore persisted state given entry." が、form の値復元のトリガーとなっているはず。

興味があるのは、 以下のようにな Next.js のアプリケーションで UA による form の値復元が起こった場合に、それを検知できるのか？という点。

```jsx
/* app/page.tsx */

export default function FormPage() {
  const checked = useState(false);
  return (
    <form>
      <input
        type="checkbox"
        checked={checked}
        onChange={(e) => setChecked(e.target.checked)}
      />
    </form>
  );
}
```

Restoration が起こっても、HTMLInputElement の Changed Event は発火しない。
真面目に Restoration を検知するのであれば、 form-associated custom element を作成し、`formStateRestoreCallback` を実装するくらいしかタイミングを知る術はないし、(仮にそれができたところで) React で Custom Element を Host Component と同じ様に扱うのが相当厳しいはず。

例えば Restoration が React Dom の Hydration よりも前に生じることが確定しているのであれば、マウント時に `useLayoutEffect` なりで ref callback なりで DOM の値を読んで setState すればいいだけのはず。
ただ、Hydration よりも前に Restoration が起こったなら Hydration Error になりそうなものだけど。

厳密な検証ではないものの、手元で `formStateRestoreCallback` を実装した Custom Element を設置した感じ、Client Side での 初回 Rendering よりも前に `formStateRestoreCallback` が呼ばれているが、Hydration Error が発生する節もなく混乱している。
自分の検証方法の何かが間違っていそう。

---

# 2/5

## AI Agent と VRT

reg-suit や Storycap を運用する際の課題として、VRT 前段のスクショが遅い(= 件数が多いので CI 圧迫しがち) というのは頻出である。
`git diff` の情報を元に「変更が生じる可能性のある Story ファイル」を推定させることができれば、この課題の解消になるかもしれない、ということを考えた。

手元で claude code の SKILL として、今までのツール(Storycap と reg-cli) を使った VRT フローを作成してみた。
肝はやはり、ファイル差分を元に story を絞るところで、これは確実にレポジトリのコード規約の知識が必要になる箇所なので、plugin や user レベルで使える SKILL になることはない。

今回は SKILL 作成の planning 時にレポジトリの構成を読み込ませて、story 抽出ルールを SKILL.md に焼き付けるような形となった。

動作そのものはするが「いい感じかどうか」を検証しようとすると、`git diff` のパターンを複数用意して試す必要があるため、現段階での評価はむずかしい。

というか、Agent の挙動にガチャの余地があるから、作成した SKILL の評価って難しいよなぁ。

---

# 2/9

## React の ViewTransition 是非

https://frontendmasters.com/blog/reacts-viewtransition-element/

## AI のバグ解決能力

https://www.developerway.com/posts/debugging-with-ai

Claude Opus 4.5 にバグのあるアプリを与えてデバッグの過程を観察する、という内容。

「AI が提示した解は疑ってかかれよ」という話以上でも以下でもない気がする。

関係ないが、なんで TanStack 入れてるんだろう？というのが気になってしまった。
2 つめのバグが Suspense 周りの話のようだけど( `useSuspenseQuery` とか書いてるので)、普通に Next.js だけでやればいいのでは。

## Bun 1.3.8 で Markdown を built-in サポート

https://bun.com/blog/bun-v1.3.8

X でも少し前からポツポツ話題になっていた模様。

## WebAssembly 10th Anniversary

https://bytecodealliance.org/articles/ten-years-of-webassembly-a-retrospective

---

# 2/12

## tRPC で `useQuery` の HTTP Method を変更するには

`methodOverride` というオプションが HTTP Link に存在しているのでこれを利用すればよさそう (実際には試していない)。

https://trpc.io/docs/client/links/httpLink#httplink-options

特定の Router についてのみ上書きしたい、ということであれば、前段に Split Link をはさみ、 `methodOverride` を設定した HTTP Link とそうでない HTTP Link の両方を貼ればよい

---

# 2/13

## Oxlint の JS Plugin

kazupon さんが https://speakerdeck.com/kazupon/oxlint-js-plugins で発表していた。

p35 辺りが Arena Allocation や Rust - JS 間の AST Transfer 関連 (overloookmotel さんが頑張ってた部分) の内容なので胸熱。
