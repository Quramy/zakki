# 2/3

## ブラウザバック時の form の値が restore される問題

Gemini 相手に HTML Living Standard を壁打ち。途中何回も嘘付いてきたので、やつの回答の精査に時間がかかった。

ある input 要素に autocomplete="off" を付与したページが存在していたとする。
このページに「戻る」動作を行った場合、値の復帰が UA によって実行されるかどうかは以下の通り:

- A: bfcache が有効な場合: UA による値の復帰は仕様上行われない。 bfcache からの復元において、reset されるべき仕様が MUST で存在しているため[^1]
- B: bfcache が無効な場合: UA による値の復帰は行われない可能性が高い。autocomplete="off" であるフォーム要素の値の記憶が推奨されていないため[^2]

[^1]: "For each formControl of form controls in document with an autofill field name of "off", invoke the reset algorithm for formControl." と bfcache からの Reactivate flow に明記されている. https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-document
[^2]: "When an element's autofill field name is "off", the user agent should not remember the control's data" とある. https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill-processing-model

---

# 2/4

## 続・ブラウザバック時の form の値が restore される問題

昨日に引き続き調査。

[Updating the document](https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-document) が UA で実行される際の、6.4.4 "Restore persisted state given entry." が、form の値復元のトリガーとなっているはず。

興味があるのは、 以下のようにな Next.js のアプリケーションで UA による form の値復元が起こった場合に、それを検知できるのか？という点。

```jsx
/* app/page.tsx */

export default function FormPage() {
  const checked = useState(false);
  return (
    <form>
      <input
        type="checkbox"
        checked={checked}
        onChange={(e) => setChecked(e.target.checked)}
      />
    </form>
  );
}
```

Restoration が起こっても、HTMLInputElement の Changed Event は発火しない。
真面目に Restoration を検知するのであれば、 form-associated custom element を作成し、`formStateRestoreCallback` を実装するくらいしかタイミングを知る術はないし、(仮にそれができたところで) React で Custom Element を Host Component と同じ様に扱うのが相当厳しいはず。

例えば Restoration が React Dom の Hydration よりも前に生じることが確定しているのであれば、マウント時に `useLayoutEffect` なりで ref callback なりで DOM の値を読んで setState すればいいだけのはず。
ただ、Hydration よりも前に Restoration が起こったなら Hydration Error になりそうなものだけど。

厳密な検証ではないものの、手元で `formStateRestoreCallback` を実装した Custom Element を設置した感じ、Client Side での 初回 Rendering よりも前に `formStateRestoreCallback` が呼ばれているが、Hydration Error が発生する節もなく混乱している。
自分の検証方法の何かが間違っていそう。

---

# 2/5

## AI Agent と VRT

reg-suit や Storycap を運用する際の課題として、VRT 前段のスクショが遅い(= 件数が多いので CI 圧迫しがち) というのは頻出である。
`git diff` の情報を元に「変更が生じる可能性のある Story ファイル」を推定させることができれば、この課題の解消になるかもしれない、ということを考えた。

手元で claude code の SKILL として、今までのツール(Storycap と reg-cli) を使った VRT フローを作成してみた。
肝はやはり、ファイル差分を元に story を絞るところで、これは確実にレポジトリのコード規約の知識が必要になる箇所なので、plugin や user レベルで使える SKILL になることはない。

今回は SKILL 作成の planning 時にレポジトリの構成を読み込ませて、story 抽出ルールを SKILL.md に焼き付けるような形となった。

動作そのものはするが「いい感じかどうか」を検証しようとすると、`git diff` のパターンを複数用意して試す必要があるため、現段階での評価はむずかしい。

というか、Agent の挙動にガチャの余地があるから、作成した SKILL の評価って難しいよなぁ。

---

# 2/9

## React の ViewTransition 是非

https://frontendmasters.com/blog/reacts-viewtransition-element/

## AI のバグ解決能力

https://www.developerway.com/posts/debugging-with-ai

Claude Opus 4.5 にバグのあるアプリを与えてデバッグの過程を観察する、という内容。

「AI が提示した解は疑ってかかれよ」という話以上でも以下でもない気がする。

関係ないが、なんで TanStack 入れてるんだろう？というのが気になってしまった。
2 つめのバグが Suspense 周りの話のようだけど( `useSuspenseQuery` とか書いてるので)、普通に Next.js だけでやればいいのでは。

## Bun 1.3.8 で Markdown を built-in サポート

https://bun.com/blog/bun-v1.3.8

X でも少し前からポツポツ話題になっていた模様。

## WebAssembly 10th Anniversary

https://bytecodealliance.org/articles/ten-years-of-webassembly-a-retrospective

---

# 2/12

## tRPC で `useQuery` の HTTP Method を変更するには

`methodOverride` というオプションが HTTP Link に存在しているのでこれを利用すればよさそう (実際には試していない)。

https://trpc.io/docs/client/links/httpLink#httplink-options

特定の Router についてのみ上書きしたい、ということであれば、前段に Split Link をはさみ、 `methodOverride` を設定した HTTP Link とそうでない HTTP Link の両方を貼ればよい

---

# 2/13

## Oxlint の JS Plugin

kazupon さんが https://speakerdeck.com/kazupon/oxlint-js-plugins で発表していた。

p35 辺りが Arena Allocation や Rust - JS 間の AST Transfer 関連 (overloookmotel さんが頑張ってた部分) の内容なので胸熱。

---

# 2/17

## ts-graphql-plugin メンテ

思い立って Not merged な Renovate PR を片付けていく作業を行った。
TypeScript の Upgrade を一年近く止めてしまっていたのはほんとに良くなかった。

https://github.com/Quramy/ts-graphql-plugin/issues/1443 という Issue が一年前に上げられていて、5.7 系から `info.project.documentRegistry` だと Document Registry にアクセスできなくなっていた。
`@internal` ついてる field にアクセスしてるこっちが悪い、という話なのだけど、Document Registry にアクセスできないと File Acquire のタイミングを Lang Service から監視できないことになって、Global Fragment Registration が結果的に動かくなって致命的。
`info.project.projectService` からは Document Registry にアクセスできるので、そこからアクセスするように修正。

---

# 2/20

## Interop 2026

今年の Interop が WebKit blog や web.dev で紹介されていた。

- https://webkit.org/blog/17818/announcing-interop-2026/
- https://web.dev/blog/interop-2026?hl=en

気になった箇所は以下:

- Navigation API: 去年も重点領域であったが、今年も引き続き。特に [Interceptor の `precommitHandler`](https://developer.mozilla.org/en-US/docs/Web/API/NavigationPrecommitController) が言及されている。
  - `precommitHandler` は、Navigation API の Interceptor が Navigation を捕捉した際に呼び出される callback で、これを利用することで、Navigation の commit 前に任意の処理を挟むことができる。
- CSS Scroll Snap: Baseline に入ってなかったっけ？と思ったが、「しかし、多くの古い CSS 仕様と同様に、初期バージョンが既にブラウザに実装されている間に仕様が何度も変更されたことで、相互運用性が大きく欠如していました。Web 標準がはるかに成熟した今こそ、相互運用性を改善する時です」とのこと
- JSPI Wasm: 初見だった。 https://v8.dev/blog/jspi によると、JSPI は JavaScript Promise Integration の略。同期関数主体で書いた C/C++ のコードを WASM 化して、それを JavaScript 側から非同期関数として呼び出したい、というニーズに対応させるためのもの。
- CSS Media pseudo-classes: これも初見だった。 `<audio>` や `<video>` で利用可能な擬似クラス。 `:playing` や `:paused` など。
- View Transitions: 去年は Same Document が対象だったが、今年は Cross Document を対象とするとのこと

## Navigation API

web.dev に紹介記事が上がっていた。

https://web.dev/blog/baseline-navigation-api?hl=en

Navigation API それ自体をアプリケーション開発者が直接利用する、ということはまずないと思っていて、フレームワークがラップして提供する形になるはずだが、実際にそれをやろうしているフレームワークってもうあるんだろうか？
軽く Gemini に壁打ちしてみたけど、特に有効な回答得られれず。 Remix 辺りが手を出すのだろうか？

## ts-graphql-plugin を vitest に移行

ほぼほぼ claude code に任せた

https://github.com/Quramy/ts-graphql-plugin/pull/1565

何箇所か `require` を利用している箇所で詰まっていたが、自己解決できていたが、1 test ファイルだけ claude の修正案が怪しく、自分で修正した箇所あり。
やってみて思うのだが、自分で手を動かしてないので vitest.config の中身や書き方について、全然知識が定着しない。
設定ファイルの書き方を真面目に覚えるべきか否かは賛否分かれそうだが、こういうところをおざなりにして進めてしまうと、Agent を正しく導くスキルが最終的に足りなくなってしまうような気もしている。
