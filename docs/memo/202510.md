# 10/1

## JavaScript の Hashbang Comment Syntax

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#hashbang_comments

```js
#!/usr/bin/env node

console.log("Hello, world!");
```

Script や Module の先頭行でのみ `#!` から始まる行は Comment として扱われることが仕様上決まっているとのこと。
CLI 作るときに当たり前のように使っていたけど、確かにこれ Lexer がちゃんと認識してないと変だもんな。

## Set の集合演算系メソット

これも先日の State of JS 2025 で知らなかった メソッド名があったので、以下をよみつつおさらい。

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Set#set_%E3%81%AE%E5%90%88%E6%88%90

### `union`

和集合

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.union(B); // { 'a', 'b', 'c', 'd' }
```

### `intersection`

積集合

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.intersection(B); // { 'c' }
```

### `difference`

差集合

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.difference(B); // { 'a', 'b' }
B.difference(A); // { 'd' }
```

### `symmetricDifference`

日本語では「対称差」。

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.symmetricDifference(B); // { 'a', 'b', 'd' }
```

### `isDisjointFrom`

互いに素か否か

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);
const C = new Set(["d", "e", "f"]);

A.isDisjointFrom(B); // false
A.isDisjointFrom(C); // true
```

### `isSubsetOf`, `isSupersetOf`

読んだまま.

---

# 10/2

## React 19.2

https://react.dev/blog/2025/10/01/react-19-2

---

# 10/8

## Dev Container お触り

https://docs.claude.com/en/docs/claude-code/devcontainer

手順としては以下。

1. `.devcontainer` に Claude code 本家のサンプル突っ込む
2. `devcontainer up --workspace-folder .` で起動

npm の `devcotainer` パッケージ使わずに Compose なりで起動する方法もあるっぽいが、いちいちそのために compose.yaml 書くのが面倒だったので試していない。

Claude 触ってないときは別に Dev Container までいらないかな、という気持ちなんだが、これ触ってから気づいたけど `node_modules` もホスト - コンテナ間で共有される都合でバイナリ系のパッケージがズレる問題が発生する。

本格的に使うのであれば、開発は常に Dev Container 内で行うとするなりをした方が楽かも。

また、 monorepos で試す場合に Repository Root と Workspace Root がズレることになるが、この場合 `.devcontainer` Dir どこに置くのが正解なんだろ？

```text
# Pattern A

<repo-root>/
  .devcontainer/
    devcontainer.json
    Dockerfile
  backend/
    build.gradle
    CLAUDE.md
  frontend/
    package.json
    CLAUDE.md
```

```text
# Pattern B

<repo-root>/
  backend/
    .devcontainer/
      devcontainer.json
      Dockerfile
    build.gradle
    CLAUDE.md
  frontend/
    .devcontainer/
      devcontainer.json
      Dockerfile
    package.json
    CLAUDE.md
```

---

# 10/10

## Chrome devtool MCP

- https://developer.chrome.com/blog/chrome-devtools-mcp?hl=en
- https://github.com/ChromeDevTools/chrome-devtools-mcp/?tab=readme-ov-file#chrome-devtools-mcp

多分だけど、CDP をラップして MCP サーバ化したもの。CDP Client が MCP サーバーに相当する。

## CSS の Shape Outside

https://css-tricks.com/getting-creative-with-shape-outside/

## アーキテクト不在での Agentic Coding

一見するとまともそうに見えるが、酷い組み合わせのアーキテクチャで、プロダクトコードが量産されるスピードだけが数倍になるという地獄絵図を目の当たりにした。

---

# 10/15

## Storybook v9.1 に Upgrade

メインで触っているプロジェクトの SB を v8 から v9 へ Upgrade した。

ref: https://storybook.js.org/docs/releases/migration-guide

基本的には `npx storybook@latest upgrade` で Code mod が走るが、細かい箇所は手動修正が必要。

`parameters` を Interface Merge しているときに、以前は `@storybook/csf` に対して Augmentation していたのを `@storybook/react` に対して行うように変更する必要があった。

```ts
// Before
declare module "@storybook/csf" {
  interface Parameters {
    awesomeParams: {
      // ...
    };
  }
}

// After
declare module "@storybook/react" {
  interface Parameters {
    awesomeParams: {
      // ...
    };
  }
}
```

また、`fn` や `userEvent` などのテスト系の import 元が `@storybook/test` から `storybook/test` に変わっている。基本的には Code mod が対処してくれるが、 `*.stories.tsx` でない共通ファイルなど (decorator とか) から使っていた箇所は手動で書き換えた。

```ts
// Before
import { fn } from "@storybook/test";

// After
import { fn } from "storybook/test";
```

修正内容としては大したことないのだけど、手癖として `@storybook/test` で覚えちゃってるので慣れるのにちょい時間かかりそう。

---

# 10/16

## CSS Grid のメンタルモデル

WebKit blog の "CSS Grid: A helpful mental model and the power of grid lines" という記事が良かった。

https://webkit.org/blog/17474/css-grid-a-helpful-mental-model-and-the-power-of-grid-lines/

Spread Sheet のアナロジーから CSS Grid の説明を出発して、 `grid-rows` / `grid-columns` の辺りで grid の line number を意識させる構造。

改めて MDN の https://developer.mozilla.org/ja/docs/Web/CSS/CSS_grid_layout/Basic_concepts_of_grid_layout を呼んでみたが、 WebKit blog の方が入口としてはわかりやすい印象。

## Web Components Custom Elements Manifest

そういうものがある、ということを以下の記事で知った。

https://daverupert.com/2025/10/custom-elements-manifest-killer-feature/

Web Components だしなぁ、、、正直興味ないんだよな。。。
Machine Readable Format なので、 MCP 辺りから提供したり読んだりして云々、という世界線なんだろうか？

## Web Components 要不要論争

上の記事とは特に関係はないが、SolidJS 作者の @RyanCarniato さんが Web Components を批判している記事を同僚に紹介してもらったので読んだ。

https://dev.to/ryansolid/web-components-are-not-the-future-48bh

@RyanCarniato さん、以前にも Web Components に対して懐疑的な内容を記事にしていた:

https://dev.to/ryansolid/maybe-web-components-are-not-the-future-hfh

どの UI フレームワークを使っているにせよ、「Component が DOM 要素である」ことを出発点として扱うという Web Components の制約が非常に都合が悪い、というのが主張の根幹。
Off Screen Rendering だったり SSR に思いをはせれば確かにそうだよな、と思う。
Web Components , すなわち DOM インターフェイスを基準として考えると、フレームワークやライブラリはそのインターフェイス(たとえば DOM Events とか)をポリフィルしたりラップしたりする必要性が出てきて、それがランタイム上のオーバーヘッドにもなり得る。

で、今回の @RyanCarniato さんの記事に対する反論投稿が https://dev.to/claviska/web-components-are-not-the-future-theyre-the-present-347m という記事。
著者の方の出自はよくわからないけど、 dev.to の他記事を見る感じ、 Web Components による UI ライブラリを作ったり Web Components そのもののの啓蒙記事を数年に渡って投稿している方。
こちらの反論記事については「Component が DOM 要素である」に対する具体的な反論については言及されておらず、「Web Components は プラットフォームレベルでサポートされるのだから、フレームワークやライブラリにロックインされない。自由に選択できる」という主張のみに終始している感がある。

## Bun 1.3

https://bun.sh/blog/bun-v1.3

HTML import から SQL の実行までなんでもできるよ、というのはさておき、`Bun.stripANSi()` が SIMD で 6 倍程度速くなったとのこと。

妙に気になったので実装 PR を読んでみた。

```cpp
    auto it = start;
    // Search for escape sequences using SIMD
    // [Implementation note: aligning `it` did not improve performance]
    for (; end - it >= stride; it += stride) {
        const auto chunk = SIMD::load(reinterpret_cast<const SIMDType*>(it));
        const auto chunkMasked = SIMD::bitAnd(chunk, escMask);
        const auto chunkIsEsc = SIMD::equal(chunkMasked, escVector);
        if (const auto index = SIMD::findFirstNonZeroIndex(chunkIsEsc)) {
            return it + *index;
        }
    }
```

ref: https://github.com/oven-sh/bun/pull/21801/files#diff-b96c8e01edb7acc6ff2e26723fcccba888b82a3b9d62c38411396aa2b5fc1ab6R43-R50

確かに stride 幅の文字を一気に SIMD 命令のみで処理している。bit 演算でマスクしているのはなんとなく雰囲気でわかるけど、その後の部分はちょっとよくわからないけど。
