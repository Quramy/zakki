# 10/1

## JavaScript の Hashbang Comment Syntax

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#hashbang_comments

```js
#!/usr/bin/env node

console.log("Hello, world!");
```

Script や Module の先頭行でのみ `#!` から始まる行は Comment として扱われることが仕様上決まっているとのこと。
CLI 作るときに当たり前のように使っていたけど、確かにこれ Lexer がちゃんと認識してないと変だもんな。

## Set の集合演算系メソット

これも先日の State of JS 2025 で知らなかった メソッド名があったので、以下をよみつつおさらい。

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Set#set_%E3%81%AE%E5%90%88%E6%88%90

### `union`

和集合

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.union(B); // { 'a', 'b', 'c', 'd' }
```

### `intersection`

積集合

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.intersection(B); // { 'c' }
```

### `difference`

差集合

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.difference(B); // { 'a', 'b' }
B.difference(A); // { 'd' }
```

### `symmetricDifference`

日本語では「対称差」。

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);

A.symmetricDifference(B); // { 'a', 'b', 'd' }
```

### `isDisjointFrom`

互いに素か否か

```js
const A = new Set(["a", "b", "c"]);
const B = new Set(["c", "d"]);
const C = new Set(["d", "e", "f"]);

A.isDisjointFrom(B); // false
A.isDisjointFrom(C); // true
```

### `isSubsetOf`, `isSupersetOf`

読んだまま.

---

# 10/2

## React 19.2

https://react.dev/blog/2025/10/01/react-19-2

---

# 10/8

## Dev Container お触り

https://docs.claude.com/en/docs/claude-code/devcontainer

手順としては以下。

1. `.devcontainer` に Claude code 本家のサンプル突っ込む
2. `devcontainer up --workspace-folder .` で起動

npm の `devcotainer` パッケージ使わずに Compose なりで起動する方法もあるっぽいが、いちいちそのために compose.yaml 書くのが面倒だったので試していない。

Claude 触ってないときは別に Dev Container までいらないかな、という気持ちなんだが、これ触ってから気づいたけど `node_modules` もホスト - コンテナ間で共有される都合でバイナリ系のパッケージがズレる問題が発生する。

本格的に使うのであれば、開発は常に Dev Container 内で行うとするなりをした方が楽かも。

また、 monorepos で試す場合に Repository Root と Workspace Root がズレることになるが、この場合 `.devcontainer` Dir どこに置くのが正解なんだろ？

```text
# Pattern A

<repo-root>/
  .devcontainer/
    devcontainer.json
    Dockerfile
  backend/
    build.gradle
    CLAUDE.md
  frontend/
    package.json
    CLAUDE.md
```

```text
# Pattern B

<repo-root>/
  backend/
    .devcontainer/
      devcontainer.json
      Dockerfile
    build.gradle
    CLAUDE.md
  frontend/
    .devcontainer/
      devcontainer.json
      Dockerfile
    package.json
    CLAUDE.md
```

---

# 10/10

## Chrome devtool MCP

- https://developer.chrome.com/blog/chrome-devtools-mcp?hl=en
- https://github.com/ChromeDevTools/chrome-devtools-mcp/?tab=readme-ov-file#chrome-devtools-mcp

多分だけど、CDP をラップして MCP サーバ化したもの。CDP Client が MCP サーバーに相当する。

## CSS の Shape Outside

https://css-tricks.com/getting-creative-with-shape-outside/

## アーキテクト不在での Agentic Coding

一見するとまともそうに見えるが、酷い組み合わせのアーキテクチャで、プロダクトコードが量産されるスピードだけが数倍になるという地獄絵図を目の当たりにした。

---

# 10/15

## Storybook v9.1 に Upgrade

メインで触っているプロジェクトの SB を v8 から v9 へ Upgrade した。

ref: https://storybook.js.org/docs/releases/migration-guide

基本的には `npx storybook@latest upgrade` で Code mod が走るが、細かい箇所は手動修正が必要。

`parameters` を Interface Merge しているときに、以前は `@storybook/csf` に対して Augmentation していたのを `@storybook/react` に対して行うように変更する必要があった。

```ts
// Before
declare module "@storybook/csf" {
  interface Parameters {
    awesomeParams: {
      // ...
    };
  }
}

// After
declare module "@storybook/react" {
  interface Parameters {
    awesomeParams: {
      // ...
    };
  }
}
```

また、`fn` や `userEvent` などのテスト系の import 元が `@storybook/test` から `storybook/test` に変わっている。基本的には Code mod が対処してくれるが、 `*.stories.tsx` でない共通ファイルなど (decorator とか) から使っていた箇所は手動で書き換えた。

```ts
// Before
import { fn } from "@storybook/test";

// After
import { fn } from "storybook/test";
```

修正内容としては大したことないのだけど、手癖として `@storybook/test` で覚えちゃってるので慣れるのにちょい時間かかりそう。

---

# 10/16

## CSS Grid のメンタルモデル

WebKit blog の "CSS Grid: A helpful mental model and the power of grid lines" という記事が良かった。

https://webkit.org/blog/17474/css-grid-a-helpful-mental-model-and-the-power-of-grid-lines/

Spread Sheet のアナロジーから CSS Grid の説明を出発して、 `grid-rows` / `grid-columns` の辺りで grid の line number を意識させる構造。

改めて MDN の https://developer.mozilla.org/ja/docs/Web/CSS/CSS_grid_layout/Basic_concepts_of_grid_layout を呼んでみたが、 WebKit blog の方が入口としてはわかりやすい印象。

## Web Components Custom Elements Manifest

そういうものがある、ということを以下の記事で知った。

https://daverupert.com/2025/10/custom-elements-manifest-killer-feature/

Web Components だしなぁ、、、正直興味ないんだよな。。。
Machine Readable Format なので、 MCP 辺りから提供したり読んだりして云々、という世界線なんだろうか？

## Web Components 要不要論争

上の記事とは特に関係はないが、SolidJS 作者の @RyanCarniato さんが Web Components を批判している記事を同僚に紹介してもらったので読んだ。

https://dev.to/ryansolid/web-components-are-not-the-future-48bh

@RyanCarniato さん、以前にも Web Components に対して懐疑的な内容を記事にしていた:

https://dev.to/ryansolid/maybe-web-components-are-not-the-future-hfh

どの UI フレームワークを使っているにせよ、「Component が DOM 要素である」ことを出発点として扱うという Web Components の制約が非常に都合が悪い、というのが主張の根幹。
Off Screen Rendering だったり SSR に思いをはせれば確かにそうだよな、と思う。
Web Components , すなわち DOM インターフェイスを基準として考えると、フレームワークやライブラリはそのインターフェイス(たとえば DOM Events とか)をポリフィルしたりラップしたりする必要性が出てきて、それがランタイム上のオーバーヘッドにもなり得る。

で、今回の @RyanCarniato さんの記事に対する反論投稿が https://dev.to/claviska/web-components-are-not-the-future-theyre-the-present-347m という記事。
著者の方の出自はよくわからないけど、 dev.to の他記事を見る感じ、 Web Components による UI ライブラリを作ったり Web Components そのもののの啓蒙記事を数年に渡って投稿している方。
こちらの反論記事については「Component が DOM 要素である」に対する具体的な反論については言及されておらず、「Web Components は プラットフォームレベルでサポートされるのだから、フレームワークやライブラリにロックインされない。自由に選択できる」という主張のみに終始している感がある。

## Bun 1.3

https://bun.sh/blog/bun-v1.3

HTML import から SQL の実行までなんでもできるよ、というのはさておき、`Bun.stripANSi()` が SIMD で 6 倍程度速くなったとのこと。

妙に気になったので実装 PR を読んでみた。

```cpp
    auto it = start;
    // Search for escape sequences using SIMD
    // [Implementation note: aligning `it` did not improve performance]
    for (; end - it >= stride; it += stride) {
        const auto chunk = SIMD::load(reinterpret_cast<const SIMDType*>(it));
        const auto chunkMasked = SIMD::bitAnd(chunk, escMask);
        const auto chunkIsEsc = SIMD::equal(chunkMasked, escVector);
        if (const auto index = SIMD::findFirstNonZeroIndex(chunkIsEsc)) {
            return it + *index;
        }
    }
```

ref: https://github.com/oven-sh/bun/pull/21801/files#diff-b96c8e01edb7acc6ff2e26723fcccba888b82a3b9d62c38411396aa2b5fc1ab6R43-R50

確かに stride 幅の文字を一気に SIMD 命令のみで処理している。bit 演算でマスクしているのはなんとなく雰囲気でわかるけど、その後の部分はちょっとよくわからないけど。

---

# 10/17

## CSS Masonry Layout から Item Flow が登場する流れと仕様標準化プロセス

https://css-tricks.com/masonry-watching-a-css-feature-evolve/ の記事で CSS Masonry Layout (CSS Grid Module Level 3) について存在を初めて知った。この記事やそこから辿れる web.dev や WebKit blog も眺めていたら大分こみいった内容であった。

そもそもの Masonry は「石積」という意味。レンガを並べて積んで作る壁のようなイメージ。"Pinterest Layout" という愛称もあるとのこと。どちらも初耳だったけど。。

> It’s called the “Pinterest layout” for the obvious reason that it’s the hallmark of Pinterest’s feed.

FireFox, Safari, Chrome の順でそれぞれの Canary Channel などで実験的な実装としてプロトタイプが提供されていた。

- Safari が実装してリリースした際の blog: https://webkit.org/blog/15269/help-us-invent-masonry-layouts-for-css-grid-level-3/
- Chrome が実装してリリースした際の blog: https://developer.chrome.com/blog/masonry-update?hl=en

FireFox, Safari は Grid Module の一部として Masonry Layout を実装しているが、 Chrome は Grid とは別のモジュールとして、すなわち `display: masonry` という仕様案を CSS WG に提案した上で実装を提供している。

個人的な肌感としては、[先日の WebKit の blog](https://webkit.org/blog/17474/css-grid-a-helpful-mental-model-and-the-power-of-grid-lines/) でもあった通り、 Grid に対するメンタルモデルは格子状の表的なものとして捉えているため、 Chrome 陣営が言う「Masonry は Grid とは別のレイアウトである」という方がしっくり来る。

逆に WebKit 側の [実装例](https://webkit.org/demos/grid3/photos/) の以下 CSS を見たときに、行方向のトラックが定まってないのに 「これは Grid である」という CSS になっていることに違和感を覚えた。

```css
main {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(14rem, 1fr));
  grid-template-rows: masonry;
  gap: 1rem;
}
```

結果 CSS WG は `display: masonry` を使うか `display: grid` に押し込めるのかの 2 択を迫られた、、、と思っていたらさらに第三の選択肢として Item flow という概念導入の機運が高まっている。
ref: https://webkit.org/blog/16587/item-flow-part-1-a-new-unified-concept-for-layout/

Item Flow が何を指しているのか、現時点ではよく理解できていないけど、上記の WebKit blog からの W3C TAG の言葉を孫引きすると以下の通り:

> > Overall, we think masonry, grid, and wrapping-flexbox should be incorporated into a unified set of properties. Chrome’s [New Masonry Layout] proposal splits apart property sets too eagerly, but even the WebKit [originally Mozilla | Just Use Grid] proposal seems to miss a chance to develop more-general properties.
>
> Wow. Incorporate Flexbox, Grid and Masonry into a unified set of properties? What would that even look like?

Grid と Masonry だけでなく、Flex も同じもので表現できる、ということの模様。

`flex-flow` とか `grid-auto-flow` の個別 Property のより汎用的な概念として `item-flow` が持ち込まれる。Flex で `item-flow: row wrap balance normal` とすると、従来の `flex-flow: row wrap` では実現できなかった「各 Item の大きさをいい感じに均等化した上で折り返す」という挙動が実現できるかもしれない。
概念的には `display: grid; item-pack: collapse` が Masonry Layout を実現できるということらしいのだが、じゃぁ Chrome 側の `display: masonry` の案が完全に消えたかというとそうでもなく、 CSS Grid Module Level 3 WD の最新としては 「 `display: something` (TODO) 」のような記載になっていて、ちょっとここの経緯がまだよくわからない。

いずれにせよ、各ブラウザベンダが Masonry をそれぞれ Canary で Prototype を実装しそれぞれの異なる草案をぶつけ合ったからこそ、CSS WG は Item Flow を標準化する方向に進めたとも言える。
この流れそれ自体が仕様標準化の過程として一定の価値がある、というのが前述の CSS Tricks の記事の趣旨。

---

# 10/21

## Next.js v16 で Runtime Config が削除される件

https://nextjs.org/blog/next-16-beta#removals にひっそりと書いてあった。

別にがっつり使っていたわけではないが、手元の Next.js を v15.5 系に上げた際に、Jest を走らせたら大量に以下の Warning が出力されて気がついた。

```
Runtime config is deprecated and will be removed in Next.js 16. Please remove the usage of "next/config" from your project.
```

自分で使ってないのになんで？と思ったが、 `@storybook/nextjs` が Project Annotation を設定する箇所から `next/config` を import していた。
以下の PR で プロジェクトの Next.js が v16 以上 の場合には import しないように修正されてる模様。 `@storybook/nextjs` のバージョンでいうと v9.10.11 辺りか？
https://github.com/storybookjs/storybook/pull/32547
