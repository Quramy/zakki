# 5/2

## reg-suit のメンテと GCP

自分のクレカ更新したときに Google の課金情報を更新するのを忘れていたせいで、抱えている GCP Project のいくつかが停止されていた。
このせいで、reg-suit の開発用に使っている GCS にアクセスできなくなり、CI が全落ちしていて reg-suit の Deploy に支障をきたしていたため、アカウントを正常化して Fail していたいくつかの PR を re-run した。

---

# 5/7

## Excalidraw

いわゆる Miro のような UI を OSS として切り出したパッケージ。

https://docs.excalidraw.com/

Canvas にアクセスする コアな部分は [Rough.js](https://roughjs.com) を利用していて、エディタ部分などを React で実装している。

---

# 5/8

## microCMS と fetch failed

Node.js で miscro-cms-sdk 使っている箇所で `Network Error. Details: TypeError: fetch failed` だけのログが Error Tracking されていて先に進めなくなる問題。
大方 `getaddrinfo` で DNS が詰まったとかその手の問題だとは思うのだけど、裏を取ろうにも caused by が一切表示されないのは困る。

https://github.com/microcmsio/microcms-js-sdk/issues/82

## Colocated fragment stub

Apollo Client もしくは graphql-codegen で `useFragment` している Component のテストを考えると「`makeFragmentData` に食わせるスタブデータをどう作成・管理していくか」というネタに行き着く。

「データは Component と対で管理する」が大原則なわけだから、スタブデータも Component のディレクトリに配置したいし、`useFragment` がネストしているのであれば、Query が Compose されるのと同じように、スタブデータも Composition したい。

以前に、自前で スタブデータ用の factory を自前で作って Compose するような構成を採用したことがある。

```ts
// components/ChildComponent/stub.ts

import type { DocumentType } from "~/gql";
import type { childFragmentDocument } from ".";

export const getChildFragmentData = () => {
  const data = {
    // データ
  } satisfies DocumentType<childFragmentDocument>;
  return data;
};
```

```tsx
// components/ChildComponent/index.stories.tsx

import type { Meta, StoryObj } from "@storybook/react";
import { ChildComponent } from ".";
import { getChildFragmentData } from "./stub";

const meta = {
  title: "ChildComponent",
  component: ChildComponent,
} satisfies Meta;

type Story = StoryObj<typeof meta>;

export const Default = {
  args: {
    data: getChildFragmentData(),
  },
} satisfies Story;
```

```ts
// components/ParentComponent/stub.ts

import type { DocumentType } from "~/gql";
import { getChildFragmentData } from "~/components/ChildComponent/stub";
import type { parentFragmentDocument } from ".";

export const getParentFragmentData = () => {
  const childFragmentData = getChildFragmentData();
  const data = {
    child: childFragmentData,
    // データ
  } satisfies DocumentType<parentFragmentDocument>;
};
```

```tsx
// components/ChildComponent/index.stories.tsx

import type { Meta, StoryObj } from "@storybook/react";
import { ChildComponent } from ".";
import { getParentFragmentData } from "./stub";

const meta = {
  title: "ParentComponent",
  component: ParentComponent,
} satisfies Meta;

type Story = StoryObj<typeof meta>;

export const Default = {
  args: {
    data: getParentFragmentData(),
  },
} satisfies Story;
```

上記における stub.ts の部分が自前の factory であり、 https://www.mizdra.net/entry/2023/09/28/174037 における以下に相当している。

> ダミーレスポンスを作成する補助関数 (factory みたいなやつ) を自作している人が多いんじゃないかと思います。

mizdra さんと自分でスタンスが異なるところがあるとすると、mizdra さんは GraphQL の Type(Schema) に対する factory を考えて、自分は Fragment(Operation) に対する factory を考えているという点。

ただ、Fragment は Type を特化した型でしかないので、Type Factory のヘルパがあれば自分のユースケースは原理的には満たせるはずだけど、いずれにせよ触って確かめてみたほうがいいだろうな。

---

# 5/10

## TypeScript 5.5 の `--isolated-declarations` と JSR

TypeScript 5.5 の --isolated-declarations について、https://devblogs.microsoft.com/typescript/announcing-typescript-5-5-beta/#isolated-declarations を読んだときは「なんでこんな話出てきたんだろ？」という気持ちだったけど、https://jsr.io/docs/about-slow-types やここからリンクされている https://github.com/jsr-io/jsr/issues/444#issuecomment-2079772908 を読んで腹落ちしてきた。

確かに JSR では 如何に高速に d.ts を出力するかというテーマが効いてくるので、型定義を分散して処理できるというのが重視されてくる。

`--isolated-declarations` が推奨かというと、少なくとも TypeScript サイドとしては中立的なスタンス。

> We also feel it is worth calling out that isolatedDeclarations should be adopted on a case-by-case basis. There are some developer ergonomics that are lost when using isolatedDeclarations

---

# 5/13

## Excalidraw のコードを読む

https://github.com/excalidraw/excalidraw

- 要素の描画周り:
  - https://github.com/excalidraw/excalidraw/blob/master/packages/excalidraw/renderer/renderElement.ts
    - renderElement という関数が実体か
    - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/renderer/staticScene.ts#L386 から呼び出されている
      - Static Scene と Interactive Scene とやらに大別される
      - これらは描画される canvas が異なる
      - Static は 楕円や矩形などの elements
      - Interactive はオブジェクト選択時の四角形などのこと
    - 実際に要素を描画しているのは https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/renderer/renderElement.ts#L290 あたり
      - https://roughjs.com/ を利用している
- ツールなどの状態管理
  - AppState に集約されている
    - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/types.ts#L221
    - `updateData` を経由するが、 https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/manager.tsx#L157-L168 により perform が呼び出されるだけ
    - この場合は https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/actionProperties.tsx#L298-L315 が実体ということになる。
    - AppState の変更だけでなく、elements の更新も行われる
  - 例: オブジェクトの背景色: `currentItemBackgroundColor` が LayerUI から更新される流れ:
    - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/actionProperties.tsx#L331
      - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/components/ColorPicker/ColorPicker.tsx#L251
- Undo/Redo まわり
  - Undo の場合、対応している action はここ: https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/actionHistory.tsx#L53-L60
  - ロジックは https://github.com/excalidraw/excalidraw/blob/master/packages/excalidraw/history.ts
- https://github.com/excalidraw/excalidraw/blob/master/packages/excalidraw/components/App.tsx がやばい
  - canvas の pointer down handler だけでこれ。。。https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/components/App.tsx#L5666-L5973
