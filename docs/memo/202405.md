# 5/2

## reg-suit のメンテと GCP

自分のクレカ更新したときに Google の課金情報を更新するのを忘れていたせいで、抱えている GCP Project のいくつかが停止されていた。
このせいで、reg-suit の開発用に使っている GCS にアクセスできなくなり、CI が全落ちしていて reg-suit の Deploy に支障をきたしていたため、アカウントを正常化して Fail していたいくつかの PR を re-run した。

---

# 5/7

## Excalidraw

いわゆる Miro のような UI を OSS として切り出したパッケージ。

https://docs.excalidraw.com/

Canvas にアクセスする コアな部分は [Rough.js](https://roughjs.com) を利用していて、エディタ部分などを React で実装している。

---

# 5/8

## microCMS と fetch failed

Node.js で miscro-cms-sdk 使っている箇所で `Network Error. Details: TypeError: fetch failed` だけのログが Error Tracking されていて先に進めなくなる問題。
大方 `getaddrinfo` で DNS が詰まったとかその手の問題だとは思うのだけど、裏を取ろうにも caused by が一切表示されないのは困る。

https://github.com/microcmsio/microcms-js-sdk/issues/82

## Colocated fragment stub

Apollo Client もしくは graphql-codegen で `useFragment` している Component のテストを考えると「`makeFragmentData` に食わせるスタブデータをどう作成・管理していくか」というネタに行き着く。

「データは Component と対で管理する」が大原則なわけだから、スタブデータも Component のディレクトリに配置したいし、`useFragment` がネストしているのであれば、Query が Compose されるのと同じように、スタブデータも Composition したい。

以前に、自前で スタブデータ用の factory を自前で作って Compose するような構成を採用したことがある。

```ts
// components/ChildComponent/stub.ts

import type { DocumentType } from "~/gql";
import type { childFragmentDocument } from ".";

export const getChildFragmentData = () => {
  const data = {
    // データ
  } satisfies DocumentType<childFragmentDocument>;
  return data;
};
```

```tsx
// components/ChildComponent/index.stories.tsx

import type { Meta, StoryObj } from "@storybook/react";
import { ChildComponent } from ".";
import { getChildFragmentData } from "./stub";

const meta = {
  title: "ChildComponent",
  component: ChildComponent,
} satisfies Meta;

type Story = StoryObj<typeof meta>;

export const Default = {
  args: {
    data: getChildFragmentData(),
  },
} satisfies Story;
```

```ts
// components/ParentComponent/stub.ts

import type { DocumentType } from "~/gql";
import { getChildFragmentData } from "~/components/ChildComponent/stub";
import type { parentFragmentDocument } from ".";

export const getParentFragmentData = () => {
  const childFragmentData = getChildFragmentData();
  const data = {
    child: childFragmentData,
    // データ
  } satisfies DocumentType<parentFragmentDocument>;
};
```

```tsx
// components/ChildComponent/index.stories.tsx

import type { Meta, StoryObj } from "@storybook/react";
import { ChildComponent } from ".";
import { getParentFragmentData } from "./stub";

const meta = {
  title: "ParentComponent",
  component: ParentComponent,
} satisfies Meta;

type Story = StoryObj<typeof meta>;

export const Default = {
  args: {
    data: getParentFragmentData(),
  },
} satisfies Story;
```

上記における stub.ts の部分が自前の factory であり、 https://www.mizdra.net/entry/2023/09/28/174037 における以下に相当している。

> ダミーレスポンスを作成する補助関数 (factory みたいなやつ) を自作している人が多いんじゃないかと思います。

mizdra さんと自分でスタンスが異なるところがあるとすると、mizdra さんは GraphQL の Type(Schema) に対する factory を考えて、自分は Fragment(Operation) に対する factory を考えているという点。

ただ、Fragment は Type を特化した型でしかないので、Type Factory のヘルパがあれば自分のユースケースは原理的には満たせるはずだけど、いずれにせよ触って確かめてみたほうがいいだろうな。

---

# 5/10

## TypeScript 5.5 の `--isolated-declarations` と JSR

TypeScript 5.5 の --isolated-declarations について、https://devblogs.microsoft.com/typescript/announcing-typescript-5-5-beta/#isolated-declarations を読んだときは「なんでこんな話出てきたんだろ？」という気持ちだったけど、https://jsr.io/docs/about-slow-types やここからリンクされている https://github.com/jsr-io/jsr/issues/444#issuecomment-2079772908 を読んで腹落ちしてきた。

確かに JSR では 如何に高速に d.ts を出力するかというテーマが効いてくるので、型定義を分散して処理できるというのが重視されてくる。

`--isolated-declarations` が推奨かというと、少なくとも TypeScript サイドとしては中立的なスタンス。

> We also feel it is worth calling out that isolatedDeclarations should be adopted on a case-by-case basis. There are some developer ergonomics that are lost when using isolatedDeclarations

---

# 5/13

## Excalidraw のコードを読む

https://github.com/excalidraw/excalidraw

- 要素の描画周り:
  - https://github.com/excalidraw/excalidraw/blob/master/packages/excalidraw/renderer/renderElement.ts
    - renderElement という関数が実体か
    - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/renderer/staticScene.ts#L386 から呼び出されている
      - Static Scene と Interactive Scene とやらに大別される
      - これらは描画される canvas が異なる
      - Static は 楕円や矩形などの elements
      - Interactive はオブジェクト選択時の四角形などのこと
    - 実際に要素を描画しているのは https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/renderer/renderElement.ts#L290 あたり
      - https://roughjs.com/ を利用している
- ツールなどの状態管理
  - AppState に集約されている
    - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/types.ts#L221
    - `updateData` を経由するが、 https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/manager.tsx#L157-L168 により perform が呼び出されるだけ
    - この場合は https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/actionProperties.tsx#L298-L315 が実体ということになる。
    - AppState の変更だけでなく、elements の更新も行われる
  - 例: オブジェクトの背景色: `currentItemBackgroundColor` が LayerUI から更新される流れ:
    - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/actionProperties.tsx#L331
      - https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/components/ColorPicker/ColorPicker.tsx#L251
- Undo/Redo まわり
  - Undo の場合、対応している action はここ: https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/actions/actionHistory.tsx#L53-L60
  - ロジックは https://github.com/excalidraw/excalidraw/blob/master/packages/excalidraw/history.ts
- https://github.com/excalidraw/excalidraw/blob/master/packages/excalidraw/components/App.tsx がやばい
  - canvas の pointer down handler だけでこれ。。。https://github.com/excalidraw/excalidraw/blob/273ba803d96322a7a2fff61d684ac8dc77fcb636/packages/excalidraw/components/App.tsx#L5666-L5973

---

# 5/14

## CSS の `light-dark` function

https://webkit.org/blog/15383/webkit-features-in-safari-17-5/ を眺めている過程で知った。

https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/light-dark

以下のように、Color Scheme に対応した値を書けるということらしい。

```css
:root {
  color-scheme: light dark;
  --background: light-dark(black, white);
  --text: light-dark(white, darkslategray);
}
body {
  background: var(--background);
  color: var(--text);
}
```

---

# 5/15

## MinIO の Docker Compose

```yaml
version: "3"
services:
  minio:
    image: minio/minio:latest
    ports:
      - 9000:9000
      - 9001:9001
    volumes:
      - ./.data/minio/data:/export
      - ./.data/minio/config:/root/.minio
    environment:
      MINIO_ROOT_USER: minio
      MINIO_ROOT_PASSWORD: minio123
    command: server /export --console-address ":9001"
  createbuckets:
    image: minio/mc
    depends_on:
      - minio
    entrypoint: >
      /bin/sh -c "
      until (/usr/bin/mc config host add myminio http://minio:9000 minio minio123) do echo '...waiting...' && sleep 1; done;
      /usr/bin/mc mb myminio/mybucket;
      /usr/bin/mc policy download myminio/mybucket;
      exit 0;
      "
```

## iPhone/iPad での input 要素からのカメラアクセスと画像フォーマット

タブレットからカメラを起動して画像をアップロードするような Web アプリについて、カメラで撮影された画像の回転ってどう扱われるんだっけ？というのが気になったので調べた。

雑に MDN の https://developer.mozilla.org/ja/docs/Web/HTML/Element/input/file に手持ちの iPad からアクセスして確認してみる。

結果は以下:

- サイトを landscape で開いた状態でカメラ起動, portrait となるように回転してから撮影: portrait の画像として認識される
- サイトを portrait で開いた状態でカメラ起動, portrait となるように回転してから撮影: landscape の画像として認識される

https://medium.com/wassa/handle-image-rotation-on-mobile-266b7bd5a1e6 には、EXIF が利用されると書いてある。
この記事は結構古いため、iOS における写真の形式は JPEG だったころと思うが、現在の HEIF 形式でも基本的にはメタデータは EXIF に保存されているとのこと。

これは今更ながら初めて知ったのだけど、デバイス上は HEIF であったとしても、Safari で ファイル選択した瞬間に JPEG に変換されている模様。

https://qiita.com/noboru_i/items/c7a1cb5200ea1ddda751

ただ、この挙動についての webkit なり Apple なりの仕様らしき文書は見つけることができなかった。

EXIF の扱いという意味では、アップロード後に別形式に変換書ける(webp とか PNG とか) に EXIF の情報を正しく扱っていれば基本的には問題無さそう。

試しに iPad で撮影した portrait な画像を sharp で webp にしてみたところ、ものの見事に 90 度傾いてしまったが、引数無しの `rotate` を挟むことで、EXIF の向きに従ってアウトプットしてくれた。

```js
import sharp from "sharp";

const resizeWidth = 200;

async function resizeBuffer(inputBuffer: Buffer) {
  const outputBuffer = await sharp(inputBuffer)
    .rotate() // これ
    .resize(resizeWidth)
    .webp();
  return outputBuffer;
}
```

> Rotate the output image by either an explicit angle or auto-orient based on the EXIF Orientation tag.

https://sharp.pixelplumbing.com/api-operation#rotate

ブラウザでアップロードする前に選択したファイルを Preview する場合は Canvas を利用することになるため、こちらでもリサイズ時の挙動を確認してみた。
以下のコードを Chrome と iPad Safari で確認してみたが、こちらは特に回転方向を気にせずとも EXIF 通りの向きで描画される。

```js
const resizeWidth = 200;

document
  .querySelector("input[type='file']")
  .addEventListener("change", async (event) => {
    const file = event.target.files[0];
    const canvas = document.querySelector("canvas");
    const context = canvas.getContext("2d");
    const image = await createImageBitmap(file, {
      resizeWidth,
      resizeQuality: "high",
    });
    context.drawImage(image, 0, 0);
    canvas.width = image.width;
    canvas.height = image.height;
    image.close();
  });
```

なお、mac Chrome から HEIF ファイルを選択してみると、sharp / `createImageBitmap` ともに動作しない（もちろん mac 上では Preview アプリで表示可能な画像)。
sharp については https://github.com/libvips/libvips を突っ込めば decode できるらしいが、こちらは未検証。
