# 6/4

## Apollo Client と `useFragment` と Storybook

Fragment Colocation な Apollo Client アプリケーションでいい感じに Storybook を書いていく方法について、素振りしてみた。

https://github.com/Quramy/apollo-client-storybook-example

基本的な戦略として「Component の依存関係: Fragment の依存関係」と「Test Fixture の依存関係」が対となるようにする。

- React `PostSummary` Component -> `UserAvatar` Component
- GraphQL: `PostSummary_Post` fragment -> `UserAvatar_User` fragment

であるのであれば、以下を成立させたい。

- Fragment Stub Factory: `Post` type fragment factory -> `User` type fragment factory

中間階層の Fragment Container である `PostSummary` が以下のようであったとして、

```tsx
/* src/components/PostSummary/index.tsx */

import { graphql, type DocumentType } from "../../gql";

import { useFragment } from "@apollo/client";

import { User } from "../User";

export const fragment = graphql(`
  fragment PostSummary_Post on Post {
    id
    title
    author {
      id
      ...User_User
    }
  }
`);

type Props = {
  readonly id: string;
};

export function PostSummary({ id }: Props) {
  const { complete, data: post } = useFragment<DocumentType<typeof fragment>>({
    fragment,
    fragmentName: "PostSummary_Post",
    from: {
      __typename: "Post",
      id,
    },
  });

  if (!complete) return null;

  return (
    <>
      <a href={`/posts/${post.id}`}>{post.title}</a>
      written by <User id={post.author.id} />
    </>
  );
}
```

`PostSummary_Post` fragment のデータを提供するファクトリ関数を graphql-codegen-typescript-fabbrica で用意しておく。

```ts
/* src/components/PostSummary/stub.ts */

import { definePostFactory, dynamic } from "../../__generated__/fabbrica";

import { UserFragmentFactory } from "../User/stub";

export const PostFragmentFactory = definePostFactory({
  defaultFields: {
    __typename: "Post",
    title: dynamic(({ seq }) => `Awesome blog post ${seq}`),
    id: dynamic(({ seq }) => `post${seq}`),
    author: dynamic(async () => await UserFragmentFactory.build()),
  },
});
```

ここで `UserFragmentFactory` は `User` Component で管理されるフィクスチャ。

用意した `PostFragmentFactory` と `PostSummary` Component へ流し込むには、Storybook の Loaders / Decorators を用いる。

```tsx
/* src/components/PostSummary/index.stories.tsx */

import type { Meta, StoryObj } from "@storybook/react";

import {
  createCachePreloader,
  preloadedCacheDecorator,
} from "../../support/storybook/apollo";

import { PostSummary, fragment } from ".";
import { PostFragmentFactory } from "./stub";

const meta = {
  title: "components/PostSummary",
  component: PostSummary,
  decorators: [preloadedCacheDecorator],
  loaders: [
    createCachePreloader()
      .preloadFragment({
        fragment,
        fragmentName: "PostSummary_Post",
        data: PostFragmentFactory.build({
          id: "post001",
          title: "Apollo Client with Storybook",
        }),
      })
      .toLoader(),
  ],
  args: {
    id: "post001",
  },
} satisfies Meta;

export default meta;

type Story = StoryObj<typeof meta>;

export const Default = {} satisfies Story;
```

`createCachePreloader().toLoader()` が、必要なデータをロードした状態の `InMemoryCache` を Story に渡している感じ。
Decorator は Story Context の `loaded` オブジェクトに格納された `InMemoryCache` インスタンスを `MockedProvider` にセットするだけ。

実体は `InMemoryCache#writeFragment` と `InMemoryCache#writeQuery` を使っているだけなので、さしてハックじみたこともせずに済む。

```tsx
import type { Decorator } from "@storybook/react";

import { InMemoryCache } from "@apollo/client";
import { createFragmentRegistry } from "@apollo/client/cache";
import { MockedProvider } from "@apollo/client/testing";

import type { TypedDocumentNode } from "@graphql-typed-document-node/core";

type PreloadFragmentOptions<TResult extends Record<string, any>> = {
  fragment: TypedDocumentNode<TResult>;
  fragmentName?: string;
  id?: string;
  data: Resolver<TResult>;
};

type PreloadOperationOptions<
  TResult extends Record<string, any>,
  TValiables extends Record<string, any>
> = {
  query: TypedDocumentNode<TResult, TValiables>;
  data: Resolver<TResult>;
  variables?: TValiables;
};

type Resolver<TResolved extends Record<string, any>> =
  | TResolved
  | Promise<TResolved>
  | (() => TResolved)
  | (() => Promise<TResolved>);

async function resolveData<T extends Record<string, any>>(
  resolver: Resolver<T>
): Promise<T> {
  if (typeof resolver === "function") {
    return await resolver();
  }
  return await resolver;
}

function genDefaultId(data: { __typename?: string; id?: string }) {
  if (data.__typename && data.id) {
    return `${data.__typename}:${data.id}`;
  }
  return undefined;
}

type CachePreloaderContext = {
  __cache: InMemoryCache;
};

function isCachePreloaderContext(context: {
  loaded: unknown;
}): context is { loaded: CachePreloaderContext } {
  return !!(context.loaded as any).__cache;
}

class CachePreloader {
  private fragmentDefs: PreloadFragmentOptions<any>[] = [];
  private operationDefs: PreloadOperationOptions<any, any>[] = [];

  preloadFragment<TResult extends Record<string, any>>(
    options: PreloadFragmentOptions<TResult>
  ) {
    this.fragmentDefs.push(options);
    return this;
  }

  preloadQuery<
    TResult extends Record<string, any>,
    TValiables extends Record<string, any>
  >(options: PreloadOperationOptions<TResult, TValiables>) {
    this.operationDefs.push(options);
    return this;
  }

  toLoader() {
    const loader = async () => {
      const fragmentDefs = await Promise.all(
        this.fragmentDefs.map(({ data: resolver, ...rest }) =>
          resolveData(resolver).then((data) => ({ ...rest, data }))
        )
      );
      const operationDefs = await Promise.all(
        this.operationDefs.map(({ data: resolver, ...rest }) =>
          resolveData(resolver).then((data) => ({ ...rest, data }))
        )
      );
      const fragments = createFragmentRegistry(
        ...[...new Set(fragmentDefs.flatMap(({ fragment }) => fragment))]
      );
      const cache = new InMemoryCache({
        fragments,
      });
      for (const def of fragmentDefs) {
        cache.writeFragment({
          id: genDefaultId(def.data),
          ...def,
        });
      }
      for (const def of operationDefs) {
        cache.writeQuery({
          ...def,
        });
      }
      const loaded: CachePreloaderContext = {
        __cache: cache,
      };
      return loaded;
    };
    return loader;
  }
}

export function createCachePreloader() {
  return new CachePreloader();
}

export const preloadedCacheDecorator: Decorator = (Story, context) => {
  if (!isCachePreloaderContext(context)) {
    return (
      <MockedProvider>
        <Story />
      </MockedProvider>
    );
  }
  const cache = context.loaded.__cache;
  return (
    <MockedProvider cache={cache}>
      <Story />
    </MockedProvider>
  );
};
```

---

# 6/5

## Storybook の Unit Testing と loaders

https://storybook.js.org/docs/writing-stories/loaders では明言されていないが、Story を `composeStory` で単体テストコードから再利用する際、`loaders` が無視されている。

まぁ普通に考えると、もともとが同期的な React Component のテストの世界に対して非同期処理を持ち込まれても、、、という気がするのは分からないでもない。

```ts
test("render story", () => {
  const Component = composeStory(MyStory, Meta);
  render(<Component />);
});
```

直接的にこの件について触れられている Issue は存在しなかったが、 https://github.com/storybookjs/storybook/discussions/27389 の Discussion が近いか？と思ったけど、これは `play()` に非同期な Arrange を寄せようぜ、という内容なので自分の興味とは違いそう。
