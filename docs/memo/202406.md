# 6/4

## Apollo Client と `useFragment` と Storybook

Fragment Colocation な Apollo Client アプリケーションでいい感じに Storybook を書いていく方法について、素振りしてみた。

https://github.com/Quramy/apollo-client-storybook-example

基本的な戦略として「Component の依存関係: Fragment の依存関係」と「Test Fixture の依存関係」が対となるようにする。

- React `PostSummary` Component -> `UserAvatar` Component
- GraphQL: `PostSummary_Post` fragment -> `UserAvatar_User` fragment

であるのであれば、以下を成立させたい。

- Fragment Stub Factory: `Post` type fragment factory -> `User` type fragment factory

中間階層の Fragment Container である `PostSummary` が以下のようであったとして、

```tsx
/* src/components/PostSummary/index.tsx */

import { graphql, type DocumentType } from "../../gql";

import { useFragment } from "@apollo/client";

import { User } from "../User";

export const fragment = graphql(`
  fragment PostSummary_Post on Post {
    id
    title
    author {
      id
      ...User_User
    }
  }
`);

type Props = {
  readonly id: string;
};

export function PostSummary({ id }: Props) {
  const { complete, data: post } = useFragment<DocumentType<typeof fragment>>({
    fragment,
    fragmentName: "PostSummary_Post",
    from: {
      __typename: "Post",
      id,
    },
  });

  if (!complete) return null;

  return (
    <>
      <a href={`/posts/${post.id}`}>{post.title}</a>
      written by <User id={post.author.id} />
    </>
  );
}
```

`PostSummary_Post` fragment のデータを提供するファクトリ関数を graphql-codegen-typescript-fabbrica で用意しておく。

```ts
/* src/components/PostSummary/stub.ts */

import { definePostFactory, dynamic } from "../../__generated__/fabbrica";

import { UserFragmentFactory } from "../User/stub";

export const PostFragmentFactory = definePostFactory({
  defaultFields: {
    __typename: "Post",
    title: dynamic(({ seq }) => `Awesome blog post ${seq}`),
    id: dynamic(({ seq }) => `post${seq}`),
    author: dynamic(async () => await UserFragmentFactory.build()),
  },
});
```

ここで `UserFragmentFactory` は `User` Component で管理されるフィクスチャ。

用意した `PostFragmentFactory` と `PostSummary` Component へ流し込むには、Storybook の Loaders / Decorators を用いる。

```tsx
/* src/components/PostSummary/index.stories.tsx */

import type { Meta, StoryObj } from "@storybook/react";

import {
  createCachePreloader,
  preloadedCacheDecorator,
} from "../../support/storybook/apollo";

import { PostSummary, fragment } from ".";
import { PostFragmentFactory } from "./stub";

const meta = {
  title: "components/PostSummary",
  component: PostSummary,
  decorators: [preloadedCacheDecorator],
  loaders: [
    createCachePreloader()
      .preloadFragment({
        fragment,
        fragmentName: "PostSummary_Post",
        data: PostFragmentFactory.build({
          id: "post001",
          title: "Apollo Client with Storybook",
        }),
      })
      .toLoader(),
  ],
  args: {
    id: "post001",
  },
} satisfies Meta;

export default meta;

type Story = StoryObj<typeof meta>;

export const Default = {} satisfies Story;
```

`createCachePreloader().toLoader()` が、必要なデータをロードした状態の `InMemoryCache` を Story に渡している感じ。
Decorator は Story Context の `loaded` オブジェクトに格納された `InMemoryCache` インスタンスを `MockedProvider` にセットするだけ。

実体は `InMemoryCache#writeFragment` と `InMemoryCache#writeQuery` を使っているだけなので、さしてハックじみたこともせずに済む。

```tsx
import type { Decorator } from "@storybook/react";

import { InMemoryCache } from "@apollo/client";
import { createFragmentRegistry } from "@apollo/client/cache";
import { MockedProvider } from "@apollo/client/testing";

import type { TypedDocumentNode } from "@graphql-typed-document-node/core";

type PreloadFragmentOptions<TResult extends Record<string, any>> = {
  fragment: TypedDocumentNode<TResult>;
  fragmentName?: string;
  id?: string;
  data: Resolver<TResult>;
};

type PreloadOperationOptions<
  TResult extends Record<string, any>,
  TValiables extends Record<string, any>
> = {
  query: TypedDocumentNode<TResult, TValiables>;
  data: Resolver<TResult>;
  variables?: TValiables;
};

type Resolver<TResolved extends Record<string, any>> =
  | TResolved
  | Promise<TResolved>
  | (() => TResolved)
  | (() => Promise<TResolved>);

async function resolveData<T extends Record<string, any>>(
  resolver: Resolver<T>
): Promise<T> {
  if (typeof resolver === "function") {
    return await resolver();
  }
  return await resolver;
}

function genDefaultId(data: { __typename?: string; id?: string }) {
  if (data.__typename && data.id) {
    return `${data.__typename}:${data.id}`;
  }
  return undefined;
}

type CachePreloaderContext = {
  __cache: InMemoryCache;
};

function isCachePreloaderContext(context: {
  loaded: unknown;
}): context is { loaded: CachePreloaderContext } {
  return !!(context.loaded as any).__cache;
}

class CachePreloader {
  private fragmentDefs: PreloadFragmentOptions<any>[] = [];
  private operationDefs: PreloadOperationOptions<any, any>[] = [];

  preloadFragment<TResult extends Record<string, any>>(
    options: PreloadFragmentOptions<TResult>
  ) {
    this.fragmentDefs.push(options);
    return this;
  }

  preloadQuery<
    TResult extends Record<string, any>,
    TValiables extends Record<string, any>
  >(options: PreloadOperationOptions<TResult, TValiables>) {
    this.operationDefs.push(options);
    return this;
  }

  toLoader() {
    const loader = async () => {
      const fragmentDefs = await Promise.all(
        this.fragmentDefs.map(({ data: resolver, ...rest }) =>
          resolveData(resolver).then((data) => ({ ...rest, data }))
        )
      );
      const operationDefs = await Promise.all(
        this.operationDefs.map(({ data: resolver, ...rest }) =>
          resolveData(resolver).then((data) => ({ ...rest, data }))
        )
      );
      const fragments = createFragmentRegistry(
        ...[...new Set(fragmentDefs.flatMap(({ fragment }) => fragment))]
      );
      const cache = new InMemoryCache({
        fragments,
      });
      for (const def of fragmentDefs) {
        cache.writeFragment({
          id: genDefaultId(def.data),
          ...def,
        });
      }
      for (const def of operationDefs) {
        cache.writeQuery({
          ...def,
        });
      }
      const loaded: CachePreloaderContext = {
        __cache: cache,
      };
      return loaded;
    };
    return loader;
  }
}

export function createCachePreloader() {
  return new CachePreloader();
}

export const preloadedCacheDecorator: Decorator = (Story, context) => {
  if (!isCachePreloaderContext(context)) {
    return (
      <MockedProvider>
        <Story />
      </MockedProvider>
    );
  }
  const cache = context.loaded.__cache;
  return (
    <MockedProvider cache={cache}>
      <Story />
    </MockedProvider>
  );
};
```

---

# 6/5

## Storybook の Unit Testing と loaders

https://storybook.js.org/docs/writing-stories/loaders では明言されていないが、Story を `composeStory` で単体テストコードから再利用する際、`loaders` が無視されている。

まぁ普通に考えると、もともとが同期的な React Component のテストの世界に対して非同期処理を持ち込まれても、、、という気がするのは分からないでもない。

```ts
test("render story", () => {
  const Component = composeStory(MyStory, Meta);
  render(<Component />);
});
```

直接的にこの件について触れられている Issue は存在しなかったが、 https://github.com/storybookjs/storybook/discussions/27389 の Discussion が近いか？と思ったけど、これは `play()` に非同期な Arrange を寄せようぜ、という内容なので自分の興味とは違いそう。

---

# 6/6

## Storybook 8.1 と RSC のテスト周り

少し前に https://storybook.js.org/blog/storybook-8-1 がアナウンスされていた。

Type-safe module mocking が目玉とは思うものの、これと `experimentalRSC` を組み合わせた Demo を見ると納得いかない点が多い。

https://github.com/storybookjs/storybook-rsc-demo

`experimentalRSC` がやっていることがどこまでいっても「Async Component を Client 上で動作させる」であって「Server Component を Client で表示する」ではないことに由来していると思う。

今回の SB の Demo でやっているのは、本来は以下のような Component である部分について、

```tsx
import { PrimsaClient } from "@prisma/client";

export default async function Page({ params: { id } }) {
  const product = await new PrimsaClient().product.findUnique({ id });

  if (!product) return null;

  return <>{product.name} </>;
}
```

これを以下のように変更している。

```tsx
// import { PrimsaClient } from "@prisma/client";
import { Client } from "#lib/client"; // これが "storybook" condition と "react-server" condition で結果が異なる

export default async function Page({ params: { id } }) {
  const product = await new PrimsaClient().product.findUnique({ id });

  if (!product) return null;

  return <>{product.name} </>;
}
```

個人的には TypeScript の Path Alias (`@/*`) を多用する風潮が気に食わなかったので、この代わりとしての `"#*"` についてはウェルカムなんだが、「React Component とそれ以外」という境界の設け方は Client Component でのみ成り立つ話であって、それよりも手前で行われている Server Component ( "react-server" condition) のテスト、と言い張っているのは本当に気に食わない。

ここまでは React の利用者としての意見で、また Node.js アプリケーション開発者としての立場としては、ORM 全部をモックにすげ替えたテストにあまり価値を感じないというのもあって、この意味合いでも真っ向から真逆の Demo になっていて、この意味においても SB のやり方を是とする気持ちになれない。

---

# 6/11

## Node.js の `--env-file` オプション

Node.js v20.6 から `--env-file` で.env ファイル渡せるようになったの、知らなかった。。。

https://nodejs.org/en/blog/release/v20.6.0#built-in-env-file-support

もう `dotenv-cli` わざわざ install する必要ないじゃん。

「それもう Node.js だけでできるよ」系、どんどん増えてきたなぁ。。。
