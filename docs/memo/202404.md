# 4/1

## Apollo Client の `useBackgroundQuery` と Concurrent Mode

`useBackgroundQuery` は Query のトリガと描画が明示的に別の関数に分離されている。

基本的な利用方法は以下のようになる。

```tsx
function App() {
  const [queryRef] = useBackgroundQuery(query, { validables });

  return (
    <Suspense fallback={"loading..."}>
      <QueryResult queryRef={queryRef} />
    </Suspense>
  );
}

function QueryResult({ queryRef }) {
  const { data } = useReadQuery(query);
  // Render data
}
```

`variables` の内容が監視されているのは `useQuery` や `useSuspenseQuery` と同様であるが、これらの hooks と `useBackgroundQuery` がことなるのは、 `useBackgroundQuery` を実行した Component そのものはサスペンドしない、ということ。サスペンドするのは、あくまで `queryRef` を受け取って `useReadQuery` を実行するコンポーネントである。上記の例では `QueryResult` コンポーネントが相当する。

例えば Variables の中身に `<input type="text">` 由来の検索キーワードがある場合、タイプの度に Query が飛んで `QueryResult` がサスペンドするが、 https://react.dev/reference/react/Suspense#showing-stale-content-while-fresh-content-is-loading と同じテクニックを利用できる。

```tsx
function App() {
  const [queryRef] = useBackgroundQuery(query, { validables });
  const deferredQueryRef = useDeferredValue(queryRef);

  return (
    <Suspense fallback={"loading..."}>
      <QueryResult queryRef={deferredQueryRef} />
    </Suspense>
  );
}

function QueryResult({ queryRef }) {
  const { data } = useReadQuery(query);
  // Render data
}
```

## RSC における `react-server` Condition

package.json に React Server 用の Conditional Import 書いたら Static Differential Loading できた。

```json
{
  "imports": {
    "#util": {
      "react-server": "./src/util.react-server.ts",
      "default": "./src/util.default.ts"
    }
  }
}
```

軽くまとめて Medium に投稿した。

https://quramy.medium.com/server-component-%E3%81%A8-client-component-%E3%81%A7%E4%BE%9D%E5%AD%98%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B-7d65c8b2074f

---

# 4/2

## fretted-strings を v2 に変更

最初に作って以来、特にメンテしていなかった fretted-strings を変更。

https://github.com/Quramy/fretted-strings

型パズルを少し頑張って、Fret の key がテンプレートから推論されるようにした。

```ts
const [content, { a1 }] = extract(`
    hogehoge
%%% ^        %%%
%%% a1       %%%
    fugafuga
`);
```

また、Dual export の対応として tsup を使ってみた。楽だ。。。

## ts-graphql-plugin の性能問題

ある程度の規模のプロジェクトで極端に CLI の実行時間を要する件を調査した。

Node.js の `--inspect` オプションを使って Chrome から Debugger を開いて調査するつもりであったが、CLI なので実行が完了すると Node.js のプロセスが落ちるため、一時的に CLI のソースに `http.createServer` で TCP をリスンする処理を仕込んだ状態で起動することに。もう少しマシな方法ないんだろうか？

ts-graphql-plugin のボトルネックは一瞬で見つけることができた。

Call Tree を見たら、`ts.SourceFile` を取得する前段の `ts.Program` へのアクセスが支配的であった。

```ts
function extract(
  langService: ts.LanguageService,
  langServiceHost: ts.LanguageServiceHost
) {
  langServiceHost.getScriptFileNames().forEach((fileName) => {
    const program = langService.getProgram()!; // ここ
    const sourceFile = program.getSourceFile(fileName);
    // AST Analysis using sourceFile
  });
}
```

TypeScript が `ts.Program` を作成する処理はかなり重たい処理に該当する。
Language Service Plugin の場合はオンラインで発生する要求の都度に新しく `ts.Program` を用意するのは正しいが、CLI の場合はファイルに対するループの外側で `ts.Program` を用意しておいて使い回すようにしなくてはいけなかった。

---

# 4/3

## picomatch や nanomatch に頼らない glob

`**/*` のような glob ライクなワイルドカードパターンを JavaScript で取り扱いたい、という場合の参考実装として。

https://github.com/fitzgen/glob-to-regexp

ソースコードがシンプルなので、これを参考にすれば自分で組める。

---

# 4/9

## web.dev に JavaScript のラーニングコンテンツができている

https://web.dev/learn/javascript

本当に言語の基礎といった風合い。
Primitive 型や Class についての章がほとんどで、クロージャや非同期処理周りのトピックが扱われていないのが残念。
