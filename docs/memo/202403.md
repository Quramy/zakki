# 3/1

## zakki の見出し再考

何の気なしに、このレポジトリの memo の数を調べてみようと思い、以下のコマンドを実行した。

```sh
find docs/memo | xargs grep "^## "
```

上記の行数を取ったら、1,340 だった。

数は正直どうでもよくて、このコマンドの出力が以下のようになっていて、見出しとしての役割をあまり果たしていない気がしてきた。

```
:
docs/memo/202308.md:## CSS
docs/memo/202308.md:## Misc
docs/memo/202308.md:## CSS
docs/memo/202308.md:## Misc
docs/memo/202308.md:## CSS
docs/memo/202308.md:## Stylelint
docs/memo/202308.md:## Vim
docs/memo/202308.md:## CSS
docs/memo/202308.md:## VSC
docs/memo/202308.md:## recast
docs/memo/202308.md:## GraphQL Tokyo
docs/memo/202308.md:## Web Assembly
docs/memo/202308.md:## Misc
docs/memo/202308.md:## Performance
docs/memo/202308.md:## Web
docs/memo/202308.md:## Next.js
docs/memo/202209.md:## Unix
docs/memo/202209.md:## Jest
:
```

気になりだして、2020 年 9 月分から、再度見出しをつけ直し始めたものの、中々の重労働。1,300 あるので、それはそうなんだけど。

400 個見直すのに、2 時間程度使っている気がする。

## reg-cli / reg-suit と polyfill.io

自分にはあまり関係のない話と思っていた polyfill.io の件、reg-cli の UI Report で使っていたことを唐突に思い出して、修正した。

その過程で @bokuweb さんと Secure by default の考え方について色々と話す。

https://yosuke-furukawa.hatenablog.com/entry/2023/01/12/160406 の話もしたり。

> Node.js はエコシステムが既にあります。このエコシステムを壊すことはできないため、既に存在する機能に対してオプトインする（後から付け加える）形で導入する必要があります。(この点、 Deno などの後発は Secure By Default としてデフォルトからセキュア側に倒す事もできる設計になっていますし、Deno は実際にそうなっています。)

## TypeScript の `DocumentRegistry` 再考

DocumentRegistry は Language Service に対して、 Source File の供給を担う抽象化層。
Language Service が ts の Project に対して 1:1 になるのに対して、DocumentRegistry は Project に対して多対一の関係。

```ts
const documentRegistry = ts.createDocumentRegistry();
const languageService = ts.createLanguageService(
  languageServiceHost,
  documentRegistry
);
```

主なイベント (Language Service 側から利用されるメソッド) は acquire, update, release の 3 種.

- acquire: ファイル名を key にして、Source の AST を返却する. Language Service がファイルを要求するときに動作する
- update: ファイル名を key にして AST の update を行う。裏側では Incremental Parse が動作する？
- release: DocumentRegistry からファイルを破棄する際に呼び出される？ファイルシステムから対象ファイルを削除したことを Language Service が検知した場合に利用する？

---

# 3/4

## img-diff-js のレポジトリメンテナンス

放置気味だった img-diff-js のメンテを行う。

- yarn v1 剥がし
- CI の Node.js 最新化
- renovate の auto merge 有効化
- dependencies upgrade
- performance テスト廃止 (別の npm package と性能比較していたが、古すぎて参考にならなくなっていたため)
- Codecov 追加

## zakki の見出し再考

2021.04, 2021.05 分の h2 見出しを見直した。

## PicoML に CodeCov 導入

折角なので入れてみた。 93% 。これもテスト一杯書いたなぁ。。

---

# 3/5

## Sentry と CodeCov

たまたま、CodeCov と Setnry の UI の両方を眺める機会があって気づいたけど、 CodeCov っていつの間にか Sentry 傘下に入った？

## ts-graphql-plugin の Global Fragment Registry

Language Service の Auto Completion / Diagnostics どちらも、対象となるオペレーションを解析させる時点で「グローバルにどのような Fragment が定義されているか」が判明している状態でないとならない。

そこで、以下の方針で Fragment Map を取り扱うことを考える。

1. `ts.DocumentRegistry` にて、Script File の Open や Update を見張っておき、投機的に Fragment の map を準備しておく
1. 解析時は、事前に準備済の Fragment Map を参照する

特に 2. について、最初は graphql-language-service の `getFragmentDependencies` を使って力技気味に実装することを考えていたが、`getAutocompleteSuggestions`, `getDiagnostics` ともに、オプショナルな引数として `FragmentDefinitionNode[]` を受け取るようになっていたので、これを用いることで実装の目処が立ってきた。

```ts
const externalFragments: FragmentDenitionNode[] = fragmentDefenitionNodes;

getDiagnostics(queryDocument, schema, undefined, undefined, externalFragments);
```

ただ、細かく不都合が出てきていて、上記における解析対象の `queryDocument` が以下の Source 上の Document であったとして、この `MyFragment` の定義は `externalFragments` に含めてはいけないようになっていた。

```tsx
const MyFragment = gql`
  fragment MyFragment on User {
    name
  }
`;
```

一旦、Language Service 側が一通り動作するところまで仕上げた。

https://github.com/Quramy/ts-graphql-plugin/pull/1209

---

# 3/6

## ts-graphql-plugin の Global Fragment Registry

昨日からの続き。

Language Service 側を一通り作ったつもりでいたものの、 `DocumentRegistry` を利用する部分でミスっていることに気づく。

> 1. `ts.DocumentRegistry` にて、Script File の Open や Update を見張っておき、投機的に Fragment の map を準備しておく

`DocumentRegistry` に何かしらの処理を挟み込みたければ、正攻法としては以下のように `ts.DocumentRegistry` を実装したクラスを用意したうえで、 `ts.createLanguageService` の第２引数に渡す形となる。

```ts
class CustomDocumentRegistry implements ts.DocumentRegistry {
  private _delegate = ts.createDocumentRegistry();

  acquireDocumentWithKey(
    ...args: Paramenters<ts.DocumentRegistry["acquireDocumentWithKey"]>
  ) {
    // 自前の通知処理
    return this._delegate.acquireDocumentWithKey(...args);
  }

  updateDocumentWithKey(
    ...args: Paramenters<ts.DocumentRegistry["updateDocumentWithKey"]>
  ) {
    // 自前の通知処理
    return this._delegate.updateDocumentWithKey(...args);
  }

  // 以下略
}

const documentRegistry = new CustomDocumentRegistry();
const languageService = ts.createLanguageService(
  languageServiceHost,
  documentRegistry
);
```

実際、昨日の時点では上記のように実装して Source File の変更検知を挟み込んでいた。

しかし、Language Service Plugin が「lang service を受け取って lang service を返却する関数」であることを考えると、Plugin の中で `ts.createLanguageService` を実行してしまうのが駄目。
tsconfig の `compilerOptions.plugins` の順序にも依存するだろうが、すでに他の Plugin が Language Service をプロキシしている場合に、そのプロキシがいなかったことになってしまう。

このため、 `ts.createLanguageService` を Plugin から実行するわけにはいかず、翻って `DocumentRegistry` を乗っ取る方法を別に用意する必要があった。

TypeScript 本家のソースを読み直していたところ、 `ts.server.Project` type が内部的に `documentRegistry` フィールドを持っていたので、これを使うことにする。

```ts
function createPluginLanguageService(
  info: ts.server.PluginCreateInfo
): ts.LanguageService {
  const originalDocumentRegistry = (info.project as any)
    .documentRegistry as ts.DocumentRegistry;

  originalDocumentRegistry.acquireDocumentWithKey = new Proxy(
    originalDocumentRegistry.acquireDocumentWithKey,
    {
      apply: (delegate, thisArg, args) => {
        // 自前の通知処理
        return delegate.apply(thisArg, args);
      },
    }
  );
}
```

# 3/7

## msw と TypeScript

ts-graphql-plugin への ts 5.4 update renovate PR にて気付いたのだが、msw がなぜか TypeScript に対して Peer Dependency で version を縛っていた。

```
npm ERR! Conflicting peer dependency: typescript@5.3.3
npm ERR! node_modules/typescript
npm ERR!   peerOptional typescript@">= 4.7.x <= 5.3.x" from msw@2.2.2
npm ERR!   node_modules/msw
npm ERR!     dev msw@"2.2.2" from the root project
npm ERR!
```

https://github.com/mswjs/msw/blob/f805d349c6b9faf55c1201c51b4e7fcb29f79fe5/decisions/typescript-versioning.md になぜ TypeScript の version を明記しているかが記載されていた。

## ts-graphql-plugin の Global Fragment Registry

CLI 側への対応をしようにも、Language Service 側にちょこちょこ不具合を見つけてしまい、中々思うように進捗が出せない。

特に Diagnostic が鬼門。 `getDiagnostics` を利用するときは、以下のように `externalFragments` を渡す形となる。

```ts
getDiagnostics(queryDocument, schema, undefined, undefined, externalFragments);
```

GraphQL Language Service の側が、 `externalFragments` の中に閉じて発生する問題を拾ってきてしまう。

```ts
const dependentFragment = gql`
  fragment DependentFragment on Query {
    __typename
    notExistingField # 存在しないフィールド
  }
`;

const query = gql`
  query MyQuery {
    ...DependentFragment
  }
`;
```

上記のファイルに対して、TypeScript のエラーを問い合わせたとして、 `MyQuery` のエラーとして `notExistingField` の問題を報告してほしくない。

GraphQL Language Service は内部的に以下のような Document に展開した上で `getDiagnostics` を計算しているようで、この結果として `const query = ...` の Template String Literal に含まれるはずのない範囲のエラーが報告されるようになってしまう。

```gql
query MyQuery {
  ...DependentFragment
}
fragment DependentFragment on Query {
  __typename
  notExistingField # 存在しないフィールド
}
```

ts-graphql-plugin としては元々は以下のように Template Span を使って依存する Fragment を指定させていて、このときも同じように `notExistingField` のエラーを無視する必要があったのだが、その近辺のロジックが甘かった模様。

```ts
const dependentFragment = gql`
  fragment DependentFragment on Query {
    __typename
    notExistingField # 存在しないフィールド
  }
`;

const query = gql`
  query MyQuery {
    ...DependentFragment
  }
  ${dependentFragment}
`;
```

GraphQL Language Service 側がソースコードの位置を表現する際に用いる位置情報は TypeScript でいう Location 型に相当していて、Language Service で扱うには使い勝手が悪いためにいわゆる position (= テキストにおける先頭からの文字位置) に変換して扱うようにしていた。

```ts
interface IPosition {
  line: number;
  character: number;
}
```

問題は、この変換ロジックが内部的な Document 展開のことを考慮していなかったために起きる。検査対象の Document は以下のような 3 行のものなのに、

```
1  query MyQuery {
2    ...DependentFragment
3  }
```

`getDiagnostics` が「6 行目にエラーがあるよ」と報告してくることになるのだが、さらに location 2 position 変換で 6 行目という溢れた位置を「元々の Document の最終文字位置」として返してしまっていた。

```
1  query MyQuery {
2    ...DependentFragment
3  }
4  fragment DependentFragment on Query {
5    __typename
6    notExistingField # 存在しないフィールド
7  }
```

変換ロジック側で、テキストに存在しない Location を Position に変換しようとしたらエラーを投げるように改修。

---

# 3/8

## msw と TypeScript

> ts-graphql-plugin への ts 5.4 update renovate PR にて気付いたのだが、msw がなぜか TypeScript に対して Peer Dependency で version を縛っていた。

昨日、上記のように書いたばかりであったが、タイムリーに msw 側に Peer 上限撤廃の PR が merge されて、v2.2.3 では ts 5.4 を使えるようになっていた。

https://github.com/mswjs/msw/pull/2077

## Flex Box と `text-overflow: ellipsis` 問題

Flex Item で `ellipsis` が上手く使えない問題の件。

```
+---------------+---------+
|               |         |
| Looong text...|  fixed  |
|               |         |
+---------------+---------+
```

上記のようなレイアウトを実現しようとして、以下のような CSS を書いたとする。

```html
<div class="container">
  <div class="left">
    <div class="truncated">Looong text text</div>
  </div>
  <div class="right">Fixed</div>
</div>
```

```css
.container {
  display: flex;
}

.left {
  flex: auto;
}

.right {
  flex: 0 0 100px;
}

.truncated {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
```

こうしたとしても、`ellipsis` は期待通りには動作せず、以下のように `div.truncated` が伸長してしまう。

```
+-----------------------+---------+
|                       |         |
| Looong text text text |  fixed  |
|                       |         |
+-----------------------+---------+
```

割とよくある問題なので、至るところに解決方法は載っている。

https://css-tricks.com/flexbox-truncated-text/

```css
.left {
  flex: auto;
  min-width: 0; /* 追加 */
}
```

なぜ `min-width` を明示的に指定すると解消するか、という理由については https://bugzilla.mozilla.org/show_bug.cgi?id=1108514#c5 で述べられていた。

> As I recall, the reason "min-width:auto" exists is the following:
>
> (0) General principle: flexbox should _default_ to avoiding overflow / clipped content, for best results (and to behave gracefully in scenarios that web developers don't anticipate).
>
> (1) To that end: it's useful for "flex-shrink" to default to something nonzero, so that if authors design their pages with flexbox and don't consider small devices, then their flex items will be able to to shrink (where shrinking is possible) by default, instead of overflowing. Hence, flex-shrink defaults to "1", not "0", so that flex items will shrink if necessary.
>
> (2) BUT, we can't default to letting things shrink to be _zero-sized_ -- that would also cause overflow/truncated content, violating the principle that we're trying to achieve with (1). Essentially, we want to allow flex items to shrink until their children start overflowing, and then not shrink any further (by default).

Flex Item はデフォルトで伸長・収縮可能であるようになっているべき( Flex というくらいなのでそれはそう)だが、0 まで伸縮してしまうと「要素をなるべく見せるように」という原則に反するため、Overflow しない範囲までしか伸縮しないように暗黙的な min-width があるとのこと。

## ts-graphql-plugin の Global Fragment Registry

ここ 3~4 日間、ts-graphql-plugin を触っているが、いまいち Fragment Registry の Signature や実装が定まらない。

一旦 webpack (Custom Transformer) のことを忘れて CLI と Language Service のことだけを考えると、以下のようになっているはず。

```mermaid
flowchart LR

subgraph FragmentRegistry
  getExternalDependencies
  getGlobalFragments
  getExternalDependencies --> getGlobalFragments
end

subgraph CLI
  validate --> getExternalDependencies
  typegen --> getExternalDependencies
  report --> getExternalDependencies
end

subgraph lang-service
  getCompletion --> getGlobalFragments
  getDiagnostics --> getExternalDependencies
end
```

- `validate`, `getDiagnostics`: 検査対象の Document に対する External Fragments が必要
- `getCompletion`: Fragment Nodes の集合だけあれば十分
- `typegen`: Document に対する External Fragments が必要
  - 可能であれば、External Fragments に対する型は Type Alias Import としたい
- `report`: Document に対する External Fragments が必要
  - manifest には、External Fragments が結合された Document の文字列が必要
  - markdown には「このオペレーションはこういう External Fragments を使っているよ」を表示したい

結局、CLI 側は全て External Fragments に頼ることになるから、Extractor に寄せるのが正解？

```mermaid
flowchart LR

subgraph FragmentRegistry
  getExternalDependencies
  getGlobalFragments
  getExternalDependencies --> getGlobalFragments
end

subgraph "CLI(Analyzer)"
  validate --> extract
  typegen --> extract
  report --> extract
  subgraph Extractor
    extract -- A2 --> getExternalDependencies
  end
end

subgraph lang-service
  getCompletion -- B --> getGlobalFragments
  getDiagnostics -- A1 --> getExternalDependencies
end
```

CLI 側の `getExternalFragments` の要件を考えると、以下の Signature のイメージかしら。

```ts
interface FragmentRegistry {
  getExternalFragments(documentAst: DocumentNode): {
    fragmentName: string;
    node: FragmentDefinitionNode;
    fileName: string;
  }[];
}
```

一方で Language Service 側に必要な Signature は上とは少し異なる。

```ts
interface FragmentRegistry {
  getGlobalFragments(): FragmentDefinitionNode[];
  getExternalFragments(documentText: string): FragmentDefinitionNode[];
}
```

Language Service 側はパフォーマンスに対して機敏になるので、Cache 機構がそれなりに必要になる一方、CLI 側は Fragment に対するトレーサビリティ重視となるし、まずは別の class で実装することを考えた方が筋が良さそうな気がしてきた。

例えば 以下の `fragmentMain` の Template String を編集している最中、というシナリオを考える。
このとき `getExternalFragments` は SVC Version 0-2 の間で同一の結果を返す。

```ts
/* main.ts: svc version: 0 */
const fragmentMain = gql`
  fragment FragmentMain on Query {
    ...FragmentA
    ...FragmentB
  }
`;
```

```ts
/* main.ts: svc version: 1 */
const fragmentMain = gql`
  fragment FragmentMain on Query {
    __t
    ...FragmentA
    ...FragmentB
  }
`;
```

```ts
/* main.ts: svc version: 2 */
const fragmentMain = gql`
  fragment FragmentMain on Query {
    __typename
    ...FragmentA
    ...FragmentB
  }
`;
```

`getExternalFragments` の引数が Document のテキスト情報だけだと「同じ箇所を連続で編集している」というコンテキストを保持できないため、追加引数として付随情報が必要そう。

Language Service 側が知っていて且つこのコンテキストの表現に使えそうな値、ということだと Source File Name と Template Node の start position のペアか？

```ts
declare function getExternalFragments(
  documentText: string,
  fileName: string,
  startPosition
): FragmentDefinitionNode[];
```

`fileName` x `startPosition` を key とした `getExternalFragments` の Cache を持っていたとして、この Cache が利用可能である条件は、以下のようなる？(漏れている気もする)

- 1. `documentText` が valid syntax である, すなわち `parse` の呼び出しは必要
- 2. `documentText` に登場する Fragment Definition, Fragment Spread の種類が前回と同一
- 3. ~~前回時点と、Fragment Registry に登録された Fragment に変更がない(ただし自身の分は除く)~~ 前回時点における External Fragments が、今回の呼び出しまでの間に変更されていない
  - これ、どうやるのがいいんだろ？ Fragment Registry の Mutate で version を加算しておきながら、変更のあった Fragment Name を保持するような構造？

---

# 3/11

## ts-graphql-plugin の Global Fragment Registry

`getExternalFragments` の Cache 周りに手をつけるも茨の道感がすごい。

---

# 3/12

## Storybook と addon-storyshots の Migrate

Storybook v8 がリリースされたため、おしごとで利用している SB について Deprecated となっている `@storybook/addon-storyshots` を引き剥がした。

https://storybook.js.org/docs/writing-tests/storyshots-migration-guide#jest に記載されているのと殆ど同じだったが、RTL の場合は非同期待ち部分を `act` で囲んでおくとよい。

```ts
/* before */

stories.forEach(({ name, story }) => {
  // Instead of not running the test, you can create logic to skip it, flagging it accordingly in the test results.
  const testFn = story.parameters.storyshots?.skip ? test.skip : test;

  testFn(name, async () => {
    const mounted = render(story());

    // Ensures a consistent snapshot by waiting for the component to render by adding a delay of 1 ms before taking the snapshot.
    await new Promise((resolve) => setTimeout(resolve, 1));

    expect(mounted.container).toMatchSnapshot();
  });
});
```

```ts
/* after */

stories.forEach(({ name, story }) => {
  // Instead of not running the test, you can create logic to skip it, flagging it accordingly in the test results.
  const testFn = story.parameters.storyshots?.skip ? test.skip : test;

  testFn(name, async () => {
    const mounted = render(story());

    // Ensures a consistent snapshot by waiting for the component to render by adding a delay of 1 ms before taking the snapshot.
    await act(() => new Promise((resolve) => setTimeout(resolve, 1))); // act で囲んでおく

    expect(mounted.container).toMatchSnapshot();
  });
});
```

最初は test-runner まで持っていくこともちらっと考えたが、元が jest ベースの Storyshots であったし、ますは挙動があまり変わらないように jest + RTL のみとした。

## ts-graphql-plugin の Global Fragment Registry

Fragment Registry 本体が膨らみすぎていたため、以下に分割した:

- 外部に Fragment Definition Node の集合を供給する class: `FragmentRegistry`
- 内部で Fragment Definition Node 実体や重複を管理する class: `DefinitionFileStore`

主に `DefinitionFileStore` の実装とテストに取り組む。

ファイル名を key にした Map と、Fragment 名を key にした Map で 二重に状態を管理する上に、「重複定義された Fragment」と「全体で名前がユニークな Fragment」の間を行き来する構造のため、通常のテストとは別に不変条件を考えてアサートを仕込むようにした。

- 重複 Fragment 定義 map と ユニーク Fragment 定義 map の両方に同一の key が存在することはない
- ファイル名 を key とした Map の value は、重複定義 Fragment map か ユニーク定義 Fragment map のどちらかに必ず含まれる
- etc

`DefinitionFileStore` は `FragmentRegistry` が所有する関係となるが、管理する実体の型としてもはや GraphQL の AST であることを気にする必要がなくなった。

```ts
type DefinitionFileStoreEntry<T = unknown> = {
  name: string;
  node: T;
  fileName: string;
};
```

このおかげで、テストコードで逐一 `fragment FragmentA on Query { __typename }` のようなリテラルを大量に書かずに済む。
