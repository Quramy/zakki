# 8/1

## TypeScript 型パズル で `DeepPick`

microCMS の SDK で GET 系の API を実行する場合、 オプションの `fields` で取得するフィールドを限定できる。

ref: https://document.microcms.io/content-api/get-list-contents#h7462d83de4

```ts
import { createClient } from "microcms-js-sdk";

const client = createClient({
  apiKey: "*******",
  serviceDomain: "myapp",
});

type BlogPost = {
  id: string;
  title: string;
  body: string;
  tags: {
    label: string;
  }[];
};

const results = await client.getAllContents<BlogPost>({
  endpoint: "posts",
  queries: {
    fields: ["id", "tags.label"],
  },
});
```

ただし `fields` を使ったとしても結果の型は `getAllContents` の型パラメータで指定したものと一緒になってしまう。
上記の例の場合、 `results` の型は依然として `BlogPost[]` のまま、という意味。

本当に欲しい型は以下のような絞り込まれた形。

```ts
type ActualResultType = { id: string; tags: { label: string }[] }[];
```

`fields` は `"tags.label"` のようなドット繋ぎの形式も許容されるため、 TypeScript 組み込みの `Pick` 型だと充足できないため、再帰的な Pick を作る必要があるため、久々に型パズルしてみた。

https://gist.github.com/Quramy/d2a3b6eb5a5edf469fea0546f1118561#file-index-ts

サンプルは以下のような感じ。

```ts
type BlogPost = {
  id: string;
  isDraft: boolean;
  title: string;
  subTitle?: string;
  body: string;
  author?: {
    id: string;
    firstName: string;
    lastName: string;
    createdAt: string;
    updatedAt: string;
  };
  tags?: {
    id: string;
    color: string;
    label: string;
    createdAt: string;
    updatedAt: string;
  }[];
  createdAt: string;
  updatedAt: string;
};

const testObj: DeepPick<
  BlogPost,
  "id" | "author.id" | "author.firstName" | "tags.label"
> = {
  id: "b0001",
  author: {
    id: "user001",
    firstName: "Bob",
  },
  tags: [{ label: "Programming" }, { label: "TypeScript" }],
};

// @ts-expect-error
type WithInvalidPath = DeepPick<BlogPost, "id" | "not_existing_key">;
```

`DeepPick` の第２パラメータについて、組み込みの `Pick` 型と同じく利用可能なフィールドのみに限定するようにしたわけだが、つい今週にまったく違う文脈でも「Record から再帰的に `.` や `[]` をトークンとした Path を構成する」というのをやろうとしたばかり。
React Hook Form だったり、JSON Path だったりでこのような要求は意外とあるものなんだけど、この手の型パズルじみたコードを書けるようなるために必要な知識を Step by Step で伝達するの、どうすると効率的なのやら。

---

# 8/2

## TypeScript の CFA と `immediate` または `deferred` modifier

Hejlsberg が Control Analysis Flow 周りをより詳細に制御しようとしている:

https://github.com/microsoft/TypeScript/pull/58729

上記 PR のサンプルの通り、クロージャが挟まった場合に 現状の CFA は `mystery` がクロージャを同一タスクで呼び出すのか、別のタスクで呼び出すのかの判断ができないため、 TypeScript の CFA はこれの解析を諦めてしまっている。

```ts
let x: string | number = "OK";
x; // string
mystery(() => {
  x = 10;
});
x; // string | number
if (x === 10) {
  // Was error, now is ok
}
```

この PR の場合、上記の `mystery` のような、コールバック関数を受け取れる関数について、新たに `deferred` という Modifier を追加することで、CFA がより細かい解析可能になるとのこと。

```ts
function setTimeout(deferred callback: (args: void) => void, ms?: number): NodeJS.Timeout;
```

`deferred` を作るということは、何も Modifier を指定しない場合は即時呼び出し(= `immediate` ) の意味になると思われる。

一方で `immediate` を Modifier として用意し、デフォルトでは `deferred` 扱いとする、という考え方でも同様の効果を達成できるはずで、どちらを採用するかが Design Mtg で会話されている模様。

https://github.com/microsoft/TypeScript/issues/59406#issue-2426348464

> Let's go try out immediate. Let's not cram it in for 5.6.

とあるので、Hejlsberg の上記 PR は一旦閉じて `immediate` が 5.7 あたりで追加されるのかもしれない。

---

# 8/5

## Typescript 5.6

読まなきゃ

https://devblogs.microsoft.com/typescript/announcing-typescript-5-6-beta/

---

# 8/6

## Next.js と Error Boundary

Pages Router (且つ gSSP でなはなく gIP) なアプリケーションでの、エラーハンドリングについてのおさらい。

https://nextjs.org/docs/pages/building-your-application/configuring/error-handling#handling-client-errors

上記を見ると、以下とのこと。

- SSR でのエラー: `500.tsx` (またはカスタマイズした `_error.tsx`) とのこと
- CSR でのエラー: Error Boundary

Next.js のドキュメント的には Error Boundary は Client Side Only とのこと。
よくよく考えると、 Error Boundary が SSR で動くってことはないからそれはそうか。。

Stream が使える世界でどうなるの？という辺りも気になったので、軽くドキュメントをおさらいする。

https://ja.react.dev/reference/react-dom/server/renderToPipeableStream#setting-the-status-code

シェル(App における最上位の `<Suspense>` の外側) の内外で話が違いそうだが、以下における `<Posts />` に対してサーバー側でエラーが発生したことを考える。

```jsx
function ProfilePage() {
  return (
    <ProfileLayout>
      <ProfileCover />
      <Suspense fallback={<PostsGlimmer />}>
        <Posts />
      </Suspense>
    </ProfileLayout>
  );
}
```

この場合は以下のようになるとのこと。

> Posts コンポーネントまたはその内部のどこかでエラーが発生した場合、React はそこからの復帰を試みます。
>
> 1. 最も近い <Suspense> バウンダリ (PostsGlimmer) のローディングフォールバックを HTML として出力します。
> 2. サーバ上で Posts のコンテンツをレンダーしようとするのを諦めます。
> 3. JavaScript コードがクライアント上でロードされると、React はクライアント上で Posts のレンダーを再試行します。
>
> クライアント上で Posts のレンダーを再試行して再度失敗した場合、React はクライアント上でエラーをスローします。レンダー中にスローされる他のすべてのエラーと同様に、最も近い親のエラーバウンダリがユーザにエラーをどのように提示するかを決定します。

結局のところ、 Streaming SSR の世界でも Error Boundary の fallback が表示されるのは Client のみということ。
