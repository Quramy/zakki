# 11/4

## Jest と Native ESM の相性問題

Node.js で Require ESM が利用可能になって以降、ESM のみを提供するライブラリが増加傾向である。
おしごとでいうと、先日リリースされた Storybook v10 もその典型。

こうなってくると、CJS 前提でしか動作しない Jest の利用が厳しくなってくる。

Jest に対する延命措置としては、以下のように swc や ts-jest に対して、ESM パッケージもトランスパイルするように指示してしまえば回避は可能。

```js
module.exports = {
  // Other Jest config options...
  transformIgnorePatterns: ["node_modules/(?!(@storybook|storybook)/)"],
};
```

Vitest も v4 でたことだし、そろそろ真面目に以降していかないとダメな時期になってしまっているのかも。。。

---

# 11/5

## `Set.prototype.symmetricDifference`

少し前に Set の集合演算系メソッドを調べ直したが、ちょうど利用する機会があったので使ってみた。

2 種類の JSON Object A, B について、すべての Property が一致しているか確認するようなユーティリティをさっと書く機会があり、そこで利用。

この手のユーティリティは何度も書いているが、 `Object.entries` ループで深さ優先探索を回す前段で、そもそも A, B の keys 集合が一致しているかを確認する必要がある。
ここで、以下のように対称差が空集合かどうかをみれば、A / B の keys 集合の一致を簡潔に確認できる。

```js
const keysA = new Set(Object.keys(objA));
const keysB = new Set(Object.keys(objB));
const symmetricDiff = keysA.symmetricDifference(keysB);

if (symmetricDiff.size > 0) {
  return false;
}
```

---

# 11/11

## Vim でバッファすべで閉じる

```vim
:%bd
```

## Vercel / React の Directive と言語拡張という考え方

https://dev.to/herrington_darkholme/the-new-programming-frontier-why-vercel-is-redefining-the-language-2ij0

Next.js の `use cache` や Vercel AI SDK における `use workflow` などの Directive が Closure の転送機構として JavaScript を拡張している、という見方の話。

## Storybook の RSC サポートやりなおしムーブ

https://github.com/storybookjs/storybook/discussions/32665

Storybook v10 のリリースブログから言及されてるのを見かけた。

https://storybook.js.org/blog/storybook-10/#:~:text=discuss%20potential%20improvements.-,Experimental%20RSC%20component%20testing,-Finally%2C%20we%20are

既存の `experimentalRSC` オプションによる RSC サポートを諦めて別のアプローチを検討する、という話らしい。

中身を追えていないけど、きちんと Client - Server 境界を守って別環境として SC を実行できる、という内容であれば大分嬉しい。

---

# 11/12

## Storybook の Decorator から React Component に逆変換する Utility

以下のような Utility を作成してみたら割と便利だった。

```tsx
import type { ReactNode, FC } from "react";
import type { Decorator, StoryContext } from "@storybook/react";

interface WrapperFactory {
  ({ parameters }?: Partial<Pick<StoryContext, "parameters">>): FC<{
    readonly children: ReactNode;
  }>;
}

/**
 *
 * Creates a wrapper component that applies the given Storybook decorators.
 * It's useful for testing hook function.
 *
 * @remarks
 * This function takes multiple decorators. Each decorator is applied in the order they are provided.
 * For example, `createWrapper(DecoratorA, DecoratorB)` means "DecoratorB wraps DecoratorA".
 *
 */
export function wrapperFrom(
  ...decorators: readonly Decorator[]
): WrapperFactory {
  return ({ parameters = {} } = {}) => {
    function Wrapper({ children }: { readonly children: ReactNode }) {
      return decorators.reduce(
        (jsxElement, decorator) =>
          decorator(() => jsxElement, { parameters } as StoryContext),
        <>{children}</>
      );
    }
    return Wrapper;
  };
}
```

文脈としては、何かしらの React Context に依存する Hook に対する単体テストを記述する際に補助的に利用するイメージ。

```tsx
export function useMyHook() {
  const context = use(SomeContext);
  // do something with context
}
```

ここでいう `SomeContext` は Apollo Client だったり Zustand だったり Jotai のような、状態管理ライブラリ系の Provider が生成する類の Context を想定する。
ここで一旦話を Storybook に移す。`SomeContext` を必要とする Component に対して Storybook 上で描画したい、というのは頻出パターンであり、そのために Decorator + Parameters で Story 毎に Context を注入できるようにしておくと便利。

```tsx
const Default = {
  decorators: [
    SomeContextDecorator, // provide values via Story parameters
  ],
  parameters: {
    someContext: {
      stateValue: {
        fuga: {
          /* ... */
        },
        bar: {
          /* ... */
        },
      },
    },
  },
};
```

上記のようにしておけば、 Jest や Vitest でも `composeStory` で Storybook と同じように Parameters を使って注入する値をコントロールできる。

```tsx
const Component = composeStory(
  {
    decorators: [SomeContextDecorator],
    parameters: {
      someContext: {
        stateValue: {
          fuga: {
            /* ... */
          },
        },
      },
    },
  },
  meta
);
render(<Component />);
```

ここで Jest や Vitest のテスト対象が上述の `useMyHook` である場合を考える。
上記の `composeStory` と同じ様に、Parameters と Decorator で `someContext` の値を `useMyHook` に注入したい。これが `wrapperFrom` でやりたいことだ。

```ts
const { result } = renderHook(() => useYourHook(), {
  wrapper: wrapperFrom(SomeContextDecorator)({
    parameters: {
      someContext: {
        stateValue: {
          fuga: {
            /* ... */
          },
        },
      },
    },
  }),
});
```

そもそもの `SomeContextDecorator` を作るときに Context Provider となる React Component が登場しているはずだから、それを Wrapper として用いれば同様のことはできるのだけど、プロジェクトにおけるテスト関連のコード(stories or Jest or Vitest) で Context の注入書き方に違いを生みたくなかったということもあり、この方法を考えるに至った。

---

# 11/26

## State of React 2025

https://survey.devographics.com/en-US/survey/state-of-react/2025

## ほぼ初の Vibe Coding

全体で 300 行にも満たない程度の適当な Chrome Extension を Claude に書かせてみた。
品質気にするような箇所ではないし、Presentation を一切伴わない機能であったため、大方の想定通りに Prompt 経由のみで完結させることができた。

「そもそもの要件が Extension でないと達成不可能であり、Chrome API であればそれが実現できるであろうことを知っている」という前提があるので Prompt が書けるのであって、引き出しが無い人間だと結局辿り着くまでに時間がかかるんでは？という気がする。
