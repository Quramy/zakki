# Web フロントエンドの標準化でやっていることメモ

幾つかの会社で、新規プロダクト・プロジェクト立ち上げ時の Web フロントエンドリードエンジニアをやるようになって、かれこれ 10 年程度経つ。

如何せんフロントエンドは潮流の変化が激しい界隈であるため、新規に立ち上げ時に横のプロダクトからまるっとコピーするようなことはできないが、複数人での開発を進める上でリードエンジニアとして気にしている観点それ自体は一定成熟してきたと思う。それらの観点について、自身の活動を言語化する意味で覚書をしたためた。

なお、以降で記載している内容は、飽くまで「俺は普段こういうところを気に掛けている」であって、決して「これを守っておけばオールオッケー」という類の話ではない。

## ToC

<!-- !npx markdown-toc -i % --maxdepth 3 --no-firlsth1 -->

<!-- toc -->

- [0. 全体的アーキテクチャのキャッチアップと選定](#0-%E5%85%A8%E4%BD%93%E7%9A%84%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%83%E3%83%81%E3%82%A2%E3%83%83%E3%83%97%E3%81%A8%E9%81%B8%E5%AE%9A)
- [1. ソースコードの書き方を考える](#1-%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9%E3%82%92%E8%80%83%E3%81%88%E3%82%8B)
  - [ライブラリの選定, インストール](#%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E9%81%B8%E5%AE%9A-%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB)
  - [ディレクトリ構成](#%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E6%A7%8B%E6%88%90)
  - [Scaffold](#scaffold)
  - [CSS 関連](#css-%E9%96%A2%E9%80%A3)
  - [PoC の作成](#poc-%E3%81%AE%E4%BD%9C%E6%88%90)
- [2. Working Agreement](#2-working-agreement)
  - [テスト戦略](#%E3%83%86%E3%82%B9%E3%83%88%E6%88%A6%E7%95%A5)
- [3. ビルドパイプライン](#3-%E3%83%93%E3%83%AB%E3%83%89%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3)
- [4. BFF 周りの基盤選定](#4-bff-%E5%91%A8%E3%82%8A%E3%81%AE%E5%9F%BA%E7%9B%A4%E9%81%B8%E5%AE%9A)
- [5. エラーハンドリングの設計](#5-%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E8%A8%AD%E8%A8%88)
- [6. 計装](#6-%E8%A8%88%E8%A3%85)
- [7. カスタムイベント計測](#7-%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E8%A8%88%E6%B8%AC)
- [8. テスト見直し](#8-%E3%83%86%E3%82%B9%E3%83%88%E8%A6%8B%E7%9B%B4%E3%81%97)
- [9. 依存ライブラリのアップデート](#9-%E4%BE%9D%E5%AD%98%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88)

<!-- tocstop -->

## 0. 全体的アーキテクチャのキャッチアップと選定

フロントエンドエンジニアだけではなく、バックエンドエンジニアや SRE の意見も加味しつつ決める部分

- Meta Framework (e.g. Next.js App Router) どうするの？の検討や合意形成
  - SSR (Server Side Node.js) の有無
    - 最近はそこまで気にされなくなったとはいえ、フロントエンドがサーバー運用することにネガティブを感じる現場もまだある印象
- フロントエンド - バックエンド間の通信方式
  - OpenAPI なのか GraphQL なのか、といった辺り
  - 上記の SSR 有無とも関連するが、ブラウザから直接 バックエンド API を呼び出すのか、インターネットフェイシングな BFF を用意してから、同一 VPC (または k8s namespace)内の通信とするのか
- 基盤構成のキャッチアップ
  - 普段は基本的に AWS 前提 (稀に GCP)
  - 生で EC2 使うのか、Docker 使うとして Fargate なのか EKS なのか、など
  - CDN はどこにいるのか、ロードバランサ (ALB 相当) はどこにいるのか、ブラウザから API サーバーに到達するまでの経路をイメージできるようにしておく
- 外部接続サービスのキャッチアップ
  - 決済や認証などで SaaS であったり、別ベンダーが提供するサービスと接続することが確定しているのであれば、最低限、存在程度は把握しておく

同じ様なコードを書くにせよ nginx に .js や .css を載せるのか、 Node.js のサーバーを Docker Image として用意して Deploy するのかで後続で気にすることは大きく異なる

また、対応ブラウザについてのキャッチアップもこのタイミングで行う。

- Browsers List の元ネタとして. 「iOS safari は xx までをサポートするよ」といった情報
- 立ち上げ時点で明確なバージョンが決まってなかったとしても、下限バージョンについての考え方の目線を合わせておくだけでもよい

## 1. ソースコードの書き方を考える

「これを済ませておかないと、複数人で開発を開始するのが難しい」という系統に絞って考える。

実際にフロントエンドを開発していくメンバー同士でワイワイと相談しながら進めていくとよい。

質が悪いのは、ずーっとライブラリの選定だったり、lint のルールを議論し続けて何も開発が進まないような状況に陥ってしまうこと。
全部を決めきる、準備しきるのは不可能なので、作りたい画面の特性に合わせて取捨選択をすること。
(e.g. 回遊閲覧がメインのサイトであれば、Form や更新系処理の検討は後回しにする)

### ライブラリの選定, インストール

package.json に Dependency 追加したり、`.xxxrc` や `xxx.config.js` を作成していく作業。

ライブラリ選定の基準としては、一般的な「GitHub star 数」「npm DL 数」「release 頻度」などを気にするが、机上検証だけでなく自身やメンバーで複数ライブラリを触ってみて確認するのもあり。

- お約束系:
  - TypeScript, prettier, ESLint あたり
    - この段階で lint のルールについてごちゃごちゃ言っても時間の無駄間があるので、 standard 系の軽めのやつを入れておしまいにしておく
    - 場合によっては Stylelint とかも
- Styling
  - CSS in JS or CSS Modules なのか、tailwind を使うのか、のような部分
    - Zero Runtime 系の場合、Meta Framework が用意している Build 周りと親和するかも考慮点
  - 非 atomic css の場合、デザイントークンの管理方法も考えるべき
- Component UI ライブラリ (Material UI とかそういう系)
  - ちゃんとデザイナーが Sketch や Figma で VD を用意してくれているのであれば、自前で CSS を書いてしまえばよいと思っている
- State Management
  - Redux とかそういう部分
    - とはいえ、2023 年にもなって Redux を新規に選定することはほぼないはず
  - Atomic State Management なライブラリを検討する方がよい
    - Recoil は非アクティブなため、リスク高い
- Form ライブラリ
  - React の場合、RHF(react-hook-form) 一強？
  - RHF だけでなく、Validation に使う resolver (e.g. zod) も検討しておく
- API 通信方式
  - ここで言っているのは、ブラウザ - Node.js 間の通信ではなく、フロントエンド - バックエンド通信, チームや開発言語を跨いで IDL が必要になる箇所のこと
  - OpenAPI の場合
    - yaml をフロントエンドが書くのか、バックエンドが書くのかによって大きく異なる
    - バックエンドが API 定義を書く場合、openapi-genenerator の設定を行う
    - フロントエンドが API 定義を書く場合、YAML を生成するための TypeScript と親和するツールを用意する(e.g. zodios)
  - GraphQL の場合
    - ランタイムの選定: Apollo Client なのか urql なのか
    - SDL を引っ張ってきて、TypeScript Client 生成を行えるようにする (e.g. graphql-codegen)
  - gRPC の場合
    - やったことないから知らない
  - スタブサーバー
    - バックエンド API を叩くのが面倒、並行開発なのでまだ存在しない、のような場合に検討する
      - そもそもローカルで普通にバックエンド API を動作させた方が楽なのであれば、そっちを使えばよい
    - graphql-mock や MSW を BFF に仕込む、など
- Component カタログ
  - 実質 Storybook 以外の選択肢が無い
- テスト関係
  - 最低限の Component Unit Test が書けるくらいのセットアップを事前に済ませておくと楽
  - Jest(or Vitest), jest-environment-jsdom, testing-lib のインストール及び、global な stub の設定など(e.g. Next Router)

### ディレクトリ構成

基本的には選択した Meta Framework の構成に従うようにする

- 規模が大きめの場合、NPM workspaces の利用も検討する
  - ビルドが難しくなりがちなので、trade off も考慮する
- Atomic Design を採用しているのであれば、共通コンポーネントディレクトリをどう切るのか、などを考える
- `utils` のような名前のディレクトリを切ってしまうと将来のゴミ箱になるので、名前はちゃんとかんがえるべき
- 先に決めておくと楽な箇所
  - ただの関数群: e.g. `src/functions`
  - ライブラリ用グルーコード. Storybook の Decorator や、独自 Redux Middleware: e.g. `src/support/storybook`, `src/support/redux`

### Scaffold

hygen や schematics などのツールでチームメンバが初動しやすいようにしておく。

- Component
  - CSS, Storybook, 単体テストに何を使うか、及びディレクトリ構成の大まかな検討が完了していれば、Component を自動生成するようにしておく
- API Client
  - 自分で組むことは無いので、Open API Generator や GraphQL Codegen などの設定と同じ意味

### CSS 関連

プロジェクトが走り出してしまうと手を出しにくい部分は以下.

- 共通変数の定義
  - そもそも「どこまで共通変数化するのか」を定める
    - Figma や Sketch の VD が存在している場合、VD に記載されていないものに対して無闇に変数化しても、作業効率が下がるだけ
    - e.g. Figma のカラーパレットに存在するもののみ、Custom Variables に定義するようにする
  - 実装形態は CSS in JS or CSS Modules or Tailwind or ... で異なるが、考え方そのものはあまり変わらないはず
- リセット・ノーマライズ
  - いわゆる UA の標準スタイルを打ち消す系
  - `box-sizing` は後から変更するのが面倒な系統なので、真っ先に対応しておくべき
- ブレークポイントと優先順位
  - レスポンシブ対応が必要な場合、SP First なのか、Laptop First なのかを決めておく
  - 共通定数として保存しておくと楽
    - CSS Modules の場合、 Custom Media 用の PostCSS Plugin を設定しておく
- rem v.s. px どっちを決める
  - 長さに限らず、標準で用いる単位は ある程度 Stylelint で縛っておくとよい

### PoC の作成

各種ライブラリのセットアップと並行して、各アプリケーション処理方式が想定通り成り立っているかを試していく. いわゆるサンプル実装.

- API 通信について、正常系だけでなく、非正常系のハンドリング方法も考えておくこと
  - Loading Status はどこから取得するのか, Suspense 使うのか, ...
  - エラーハンドリング は後回しになりがちだが、後から詳細な要件が出てきても改修しやすい仕組み(共通的なエラーハンドリングインターセプタ系統）を噛ませられるようになっているかどうか, ...
- (SSR を採用している場合)
  - Client Site Routing と Server Side Rendering におけるデータ取得経路の違いを整理・理解しておく
  - API やその結果の Client State の初期値がどう hydrate されるのかを検証・理解しておく

## 2. Working Agreement

この辺りで複数人でコードを書ける下地が大枠整いつつある状態となっているはず.

メンバー全員でなるべく PR を開ける(= PR を開くことに抵抗を感じさせないようにする)環境の醸成をしておけるとよい。

特に初期段階では横でディレクトリ構成の検討のような、ドラスティック(かつ Conflict を起こしやすい) 検討も並行で走っているのが常なので、「Stale な Opened PR は極力少なくする」に重点を置く.

e.g. 1 Approver ついたら PR Author が main/master に merge してよい

### テスト戦略

テストをどこまで用意させるのかを考えるのも、まずはこのタイミングから。

VRT や E2E などの高コストな自動テストを、初手から構築しても旨味が少ないはず。どのタイミングでそれらに向き合うとよいかを確認しておくこと。

最終的には「VRT や E2E も含めてあったほうがよい」に収束するので、後回しにしても登るのが難しくないような基盤としておくことは重要。

e.g. Storybook ベースで VRT を加味して、stories.tsx と Render する test.tsx だけは commit するルールとしておき、初期は Jest / Storyshots のみを運用するようにしておく

## 3. ビルドパイプライン

レポジトリから実行環境に Deploy するまでの自動化部分。
すべてをフロントエンドがやる訳では無いが、インフラ・SRE と分担しつつ恊働していく。

「チーム全体が見れる開発環境」は、早期段階から必要になってくるため、アプリケーションコードの書き方部分が落ち着いたらここをすぐやっていく。

CI / CD にどんなツールを採用しているかで多少記法は異なるものの、大概は YAML ベースでビルドが組めるようになっているはず。

- GitHub Actions
- AWS CodeBuild
- CircleCI
- etc,,,

また、Build / Deploy は フロントエンド以外でも必要になってくるので、YAML をイチから全部書くというよりはバックエンドが利用しているものなどをコピペして育てるケースの方が多い。

コンテナベースであれば、以下の作業を実施していく。

- ビルド用の Dockerfile 書く
  - フロントエンドで Node.js server の面倒まで見ている場合は、BFF 部分のトランスパイルや `next build` のようなコマンドの実行を書く
  - nginx にブラウザ用のアセットのみ配置する構成の場合、バンドルしたファイルやエントリポイントとなる HTML の設置だけでなく、nginx の設定の記述も必要
    - e.g. `/api/` は upstream に proxy させ、そうでなければ自身から静的アセットを serve する
  - パッケージマネージャの workspace 機能を使っていると、Docker のビルドコンテキスト周りがややこしくなる
- Image Repository へ push できるようにビルド用の CI を組む
- deployment 系の設定との整合性を確認する (または自分で書く)
  - AWS Fargate であれば、task definition JSON の中身
  - k8s であれば、manifest 一通り. フロントエンドで特に重要なのは、deployment, ingress あたり?

特に Build と Deploy を分離する（ステージング用のビルド成果物をそのまま本番にも Deploy する）場合は、環境差異となるパラメータを外からインジェクトできるように、環境変数の取り扱いにちゃんと向き合わないといけない

## 4. BFF 周りの基盤選定

BFF(Backend For Frontend) をフロントエンドで開発・運用する場合に考えること

- 環境変数の取り扱い
  - Server Side に留めるもの (各種 Secret や Backend Service の URL)と、ブラウザまで露出させるべきもの (インターネットから見たサービスの FQDN など) を分別して管理できるようにしておく
- セッション関連
  - 大概が認可とセットになる
  - Redis / DynamoDB などの middleware と結合する箇所の設定
    - express-session や next-session など

## 5. エラーハンドリングの設計

バリデーションエラーとか、認証失敗ではなく、「予期せぬエラー」のような例外挙動について、どのようにユーザーにフィードバックするのかを設計・実装する作業。

例えば、以下のような事象に対して検討する。

- ページ描画(SSR, CSR 両方) 時に、サーバーで 50x が発生したらどうするのか？
  - ごめんなさい画面を表示する？
- フォーム送信時に、サーバーで 50x が発生したらどうするのか？
  - スナックバーで表示して、再送信を促す？
- ブラウザの JavaScript が Error を throw してしまった場合、何が起こる？
- POST が WAF で遮断されたら何が起こる？

網羅的な洗い出しが必要となるため、「経路」や「操作(画面遷移 or それ以外)」のような軸を組み合わせて洗い出すようにする。

- ブラウザからデータベースや外部接続サービスまでの基盤の経路を描き、書く線で断絶が起こった場合にエンドユーザーに異常発生を通知できるようになっているか？を確認する
  - (起きてほしくはないが) サービスディスカバリ(e.g. CoreDNS ) が死ぬようなこともありうるため、CDN レイヤで最低限防御できるようにする
  - CDN のカスタムエラーレスポンスで画面を返す場合、専用の HTML を作成することもある

また、Node.js / ブラウザ問わず、JavaScript の Error Tracking も仕込む

- React であれば、Root Error Boundary, Express であれば error handling middleware に Sentry や Datadog への通知を仕込む
  - tag をセットしておくと、実際に問題が発生したときの解析が楽(e.g. 認証済みユーザー識別子のハッシュ値)

## 6. 計装

所謂 Observability 関係. エラーハンドリングと似ているが、こちらはモニタリング要求などに合わせて考慮・実装を行っていく.

モニタリング要求と書いてしまうと監視要件だけを連想してしまうが、ブラウザの Session Replay や SSR(BFF) の Distributed Tracing があるのとないのではは問題発生時の原因調査効率に段違いに差がでるので、要件になくとも開発者主導でねじ込みたいレベル.

- ブラウザ側で考慮する部分:
  - Performance Monitoring
    - CWV などのフィールドデータ集計が必要であれば、送信先に合わせて設定を入れておく(e.g. Datadog RUM / Firebase / GA / etc...).
  - Session Replay
    - いわゆる Sentry / Datadog RUM に搭載されている機能のこと
- BFF を フロントエンドで構築・運用するケースで考慮する部分:
  - Logging
    - ローカル開発時以外は構造化ログで出力しておく、など実行環境に合わせてロギングミドルウェア(Express であれば pino や morgan) の設定を仕込む
  - Distributed Tracing
    - Datadog APM / New Relic / 汎用 Open Telemetry など、プロダクトが契約している SaaS に合わせて、SDK を仕込んでいく
      - SaaS の場合、Trace データの多寡で金額やサンプリングレートが変更されるため、無駄な Trace data (e.g. health check や static assets) は SDK 設定時に exclude しておく
    - SDK 提供元によっては、Error Tracking 系と同時に設定できるものも多いため、同じタイミングで仕込むと少しだけ楽

## 7. カスタムイベント計測

こちらもモニタリング関係。所謂コンバージョントラッキングであったり、PV 数計測のようなビジネスサイドからの要求となる部分。
Firebase(GA4) / Google Tag Manager / Adobe Analytics / Karte などの SDK をラップしつつ、画面実装からイベントを発火できるようにしておく。

画面の主機能ではないため後回しにされがちだが、最後まで積み残すと「計測したいパラメータをブラウザに伝播させえるためにはバックエンドから見直しが必要」のような悲しい事態のリスクがあるため、とっとと見極めておくが吉。

例えば GA の場合、PV を計測するときに自動で `document.title` が送信され、これが GA 側画面に表示されるため SPA で API 実行結果を使って動的に `document.title` を設定しているケースでは、正しいタイミングでイベントを発火させないと、一つ前の画面の title 値が送信されてしまったりするので要注意。

## 8. テスト見直し

ある程度開発が進捗していくと「ステージング環境で妙な動きをしている」のような事象が絶対に起こる。

それは QA チームが実施する手動テストかもしれないし、ビジネスサイドが行うドッグフーディングかもしれない。切欠自体は何でも構わないが、似たようなミスが繰り返されているのを目撃したら、それは仕組みを見直す機会と捉えるべき。

特に「気づいたら壊れていた」のような事象が発生したのであれば、E2E や VRT などの Non Degrade Test 導入を考慮すること。

## 9. 依存ライブラリのアップデート

Dependa bot / Renovaate を仕込んでおいて、自動で PR が来るようにしておくと良いのはやればできるのでいいとして、「すべてのライブラリの version が最新であること」を目指しても現実的ではないため、Update するパッケージの種別・頻度について、ガイドラインを考えておくとよい。

以下は例:

- Dev Dependencies はビルド成果物に影響がない場合に限り最新追従を心がけるようにする
- フレームワーク本体(e.g. Next.js) の Version Up 時は QA チームに追加テストを依頼してからリリースする
- TypeScript はフォーマッタ(prettier) や Linter(ESLint) 側のエコシステムが追従してから最新可する
- 半年に一度程度には Node.js の version を見直す
- 半年に一度程度には不要となった Polyfil を削除できないか見直す
- etc...
