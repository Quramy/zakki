# 4/5

## typescript-eslint-language-service

少し前から謎だった、 ESLint を最新化すると、 `eslint:recommended` を継承した config のときに落ちてしまう件について、 https://github.com/Quramy/typescript-eslint-language-service/issues/523 で原因を教えてもらった。

https://github.com/eslint/eslint/pull/16844 にて、 Config js の位置が移動したのが原因。

これを切欠に知ったのだが、Experimental な扱いではあるが、eslintrc の書き方が大きく変更されるみたい。

https://eslint.org/docs/latest/use/configure/configuration-files-new#using-predefined-configurations

```js
import js from "@eslint/js";

export default [
  {
    files: ["**/src/safe/*.js"],
    ...js.configs.recommended,
  },
];
```

mjs で書くのはまぁさして驚きはないとして、config array そのものを返すような形になっていた。

もう全員がこの形式で書いてくれれば、language service としても、楽になりそうな気はするんだよなぁ。

## Storycap

Storybook v7 の E2E 追加してもらえた。助かる。

---

# 4/6

## graphql-ruby

GraphQL における Query Rejection について考えてみた。

大きく分けて 2 系統あって、

- A. Ahead of time rejection: 静的解析
- B. Runtime rejection: 実行時処理

graphql-ruby であれば、 A. は https://graphql-ruby.org/queries/ast_analysis.html#errors であり、

```ruby
class NoFieldsCalledHello < GraphQL::Analysis::AST::Analyzer
  def on_leave_field(node, _parent, visitor)
    if node.name == "hello"
      @field_called_hello = true
    end
  end

  def result
    GraphQL::AnalysisError.new("A field called `hello` was found.") if @field_called_hello
  end
end
```

B. は https://graphql-ruby.org/authorization/authorization.html#field-authorization である。

```ruby
class Types::BaseField < GraphQL::Schema::Field
  # Pass `field ..., require_admin: true` to reject non-admin users from a given field
  def initialize(*args, require_admin: false, **kwargs, &block)
    @require_admin = require_admin
    super(*args, **kwargs, &block)
  end

  def authorized?(obj, args, ctx)
    # if `require_admin:` was given, then require the current user to be an admin
    super && (@require_admin ? ctx[:viewer]&.admin? : true)
  end
end
```

どちらも Custom Directive と連携させるようなことはさして難しくないため、以下のような Schema を実装できる。

```gql
directive @allowIfHoge on FIELD_DEFINITION

type Query {
  fuga: String! @allowIfHoge
}
```

あとは向き不向きの話だ。

- パターン A: そもそも Execution すらして欲しくないケースに向く
  - e.g. Operation Complexity の制限
- パターン B: Parent Object の状況にポリシーが大きく依存するものに向く
  - e.g. 組織一覧を取得した場合に、自分の所属組織かどうかによって、field のアクセスレベルが変わる

いずれにせよ、Schema で規定されていること以上の内容はできないので、Reject した場合の挙動として選択できるのは `GraphQLError` の raise 程度。Reject された理由であったりを アプリケーションレイヤできちんと表示するような要件なのであれば、それを `GraphQLError` として扱うことについて下策と考えるスタンスに変化がない。

---

# 4/7

## WebAssembly

Chrome 111 に WASM GC が入ったとのこと

https://www.publickey1.jp/blog/23/webassemblychrome_111dartwebassembly.html

---

# 4/12

## graphql-tools

`@graphql-tools/wrap` の役割がいまいち分かっていなくてモヤつく。。。

https://the-guild.dev/graphql/stitching/docs/transforms/operational

特に `@graohql-tools/stitch` と併用する意味ってあるんだろうか？

雑に stitching の example を書いてみたのだが、stitch するときに、さらに executor 込で wrap した schema を渡すと、stitch 側の batching 設定が意味をなさなくなる。
※ (`schema` と `schema2` で結果が異なる)

```ts
import { createServer } from "node:http";
import { createYoga, createSchema } from "graphql-yoga";

import { makeExecutableSchema } from "@graphql-tools/schema";
import { buildHTTPExecutor } from "@graphql-tools/executor-http";
import { stitchSchemas } from "@graphql-tools/stitch";
import { wrapSchema } from "@graphql-tools/wrap";

import { typeDefs as userServiceTypeDefs } from "../user-service/typedefs";
import { typeDefs as postServiceTypeDefs } from "../post-service/typedefs";

function createRemoteSchema(typeDefs: string, url: string) {
  const schema = makeExecutableSchema({ typeDefs });
  const executor = buildHTTPExecutor({
    endpoint: url,
    method: "POST",
    fetch: globalThis.fetch,
  });

  const wrappedSchema = wrapSchema({
    schema,
    executor,
  });

  return {
    executor,
    schema,
    wrappedSchema,
  };
}

const schema = stitchSchemas({
  mergeDirectives: true,
  subschemas: [
    {
      ...createRemoteSchema(
        userServiceTypeDefs,
        "http://localhost:4010/graphql"
      ),
      merge: {
        User: {
          selectionSet: "{ id }",
          fieldName: "userById",
          args: ({ id }) => ({ id }),
        },
      },
      batch: true,
    },
    {
      ...createRemoteSchema(
        postServiceTypeDefs,
        "http://localhost:4020/graphql"
      ),
      batch: true,
    },
  ],
});

const schema2 = stitchSchemas({
  mergeDirectives: true,
  subschemas: [
    {
      schema: createRemoteSchema(
        userServiceTypeDefs,
        "http://localhost:4010/graphql"
      ).wrappedSchema,
      merge: {
        User: {
          selectionSet: "{ id }",
          fieldName: "userById",
          args: ({ id }) => ({ id }),
        },
      },
      batch: true,
    },
    {
      schema: createRemoteSchema(
        postServiceTypeDefs,
        "http://localhost:4020/graphql"
      ).wrappedSchema,
      batch: true,
    },
  ],
});

const yoga = createYoga({ schema: schema2 });
const server = createServer(yoga);

server.listen(4030, () =>
  console.log("Server is running on http://localhost:4030/graphql")
);
```

おそらく、stitch 時の batching 設定も所詮は DataLoader に依存しているが、wrap された schema + executor のどこかに tick を超える処理が紛れ込んでいる、とかが起きているんじゃなかろうか。

他人が書いた物を引き継ぎ引き継ぎやっていたりしたせいで、妙にこんがらがっているのだけど、こういうのは一回 scrap and build しちゃった方がスッキリしそうではある。

---

# 4/12

## GraphQL

https://github.com/0no-co/GraphQLSP

おそらく ts-graphql-plugin とすごく似ていそう。Features List に以下のようにあるんだけど、最後の typed-document-node の件ってどういう意味なんだろう？

> - Hover information showing the decriptions of fields
> - Diagnostics for adding fields that don't exist, are deprecated, missmatched argument types, ...
> - Auto-complete inside your editor for fields
> - When you save it will generate typed-document-nodes for your documents and cast them to the correct type

---

# 4/13

## PostgreSQL

トランザクション中で以下のように書くと、COMMIT させるまで制約の違反チェックを遅延させることができる、ということ知る。

```sql
-- ALL の代わりに特定の constraint 名も可
SET CONSTRAINTS ALL DEFERRED;
```

https://www.postgresql.org/docs/15/sql-set-constraints.html

例えば、一意制約をトランザクション終了まで遅延させることで、特定の順序キーを swap するような処理の UPDATE を打てるようになる。
