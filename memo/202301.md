# 1/4

## Prisma

jest-prisma と prisma-fabbrica の記事（英語版）をそれぞれ Medium に公開した。

- https://quramy.medium.com/test-your-prisma-app-part-1-isolated-transactional-testing-via-jest-prisma-14075c14b2ea
- https://quramy.medium.com/test-your-prisma-app-part-2-prisma-fabbrica-test-data-factory-utility-89f8f4c36302

---

# 1/6

## T3

そろそろ真面目に一回 T3 Stack 触っておくか、という気持ちになってきた。

https://create.t3.gg/

---

# 1/11

## Rails

前から気になっていた「Active Job に直接 Active Record のインスタンスが渡せるのかどうか」について、以下の記事がわかりやすかった。

https://zenn.dev/stomk/articles/11f8c0dba0303://zenn.dev/stomk/articles/11f8c0dba0303e

## Puma

Puma を運用している中で「web サーバが起動した後」というコールバックが欲しくなることがまれにある。

Cluster Mode であれば、 Puma DSL の `after_worker_boot` に書けばよいが、Single Mode だとこのコールバックは使えなくて困っていたが、 Puma のコードを読んでいたところ、`on_booted` という Event を発火させていることがわかった。

https://github.com/puma/puma/blob/97ec2484b1d8664c73a250c2cec2c8fe736ba271/lib/puma/single.rb#L58

DSL から直接このイベントを引っ掛けられるわけではないが、 `launcher.events` が使えるので、自前で Puma Plugin を用意することで `on_booted` が利用できる。

```ruby
# lib/puma/plugin/my_plugin.rb

Puma::Plugin.create do
  def start(launcher)
    launcher.events.on_booted do
      puts "Puma gets on booted."
    end
  end
end
```

```ruby
# config/puma.rb

require './lib/puma/plugin/my_plugin'

plugin :my_plugin
```

## T3

とりあえず zod を触りだしてみたものの、簡単すぎて語ることが全然ない。

tRPC について、思想的な部分が分かるリソースを探す。

まずは Theo の tRPC v.s. GraphQL についての動画。
https://www.youtube.com/watch?v=KIJUUtWjl48

tRPC は backend の関数を frontend に公開するための仕組みでしかない。
GraphQL の Schema は backend - frontend の Conract としての側面があるが、tRPC は Schema を整備することそれ自体を目的にしない。
同じチームの中で一透過的に HTTP 越しに TypeScript の非同期関数を呼び出したいだけ。

---

# 1/12

## JavaScript

https://2022.stateofjs.com/en-US/

## RDS

AWS の RDS Performance Insights の使い方を学んだ。

Datadog や New Relic だと、相当の設定を仕込まないと ORM Duration の内訳まではわからないが、 Perf Insights 単独で wait の内訳が可視化できるため、特に Slow Query 調査には有用。

Metrics も幾つかついてくるが、直近で役に立ったのは下記辺り。

- Dead lock 発生有無
- Active transactions
- Blocked transactions

---

# 1/13

## Safari

https://webkit.org/blog/13686/release-notes-for-safari-technology-preview-161/

> Added experimental support for AudioSession Web API

上記が新しく追加されるらしいという話を社内で聞いた

---

# 1/16

## Misc

TypeScript で `hoge.maybeNull.fuga` のような記述が Compile Error になるのが当たり前に鳴ってしまっているせいか、別言語における NPE 相当が全然自分の目でチェックできなくなっている気がする。

下記のようなパターンを Review で見逃してしまった。

```ruby
hoge.maybe_nil.fuga
```

---

# 1/18

## T3

LT 資料書いて https://techfeed.io/events/techfeed-experts-night-11 に登壇。

https://speakerdeck.com/quramy/t3-stack-and-typescript-ecosystem

タイトルだけ先に決めてやってみたものの、先日に書いた感想から何も変わらなかったし、結果として我ながらさして面白くない LT をしてしまった。

> とりあえず zod を触りだしてみたものの、簡単すぎて語ることが全然ない。

tRPC にせよ Prisma にせよ、利用するだけなら何ら難しさの無いライブラリだ。

tRPC/ Zod の Type Inference や Prisma の DMMF からの Generation など、ライブラリの中身が好きな人間に対しては面白い要素が山のようにあるが、広く受け入れられるような話でもないだろうし。

## Misc

Techfeed experts night の中で、同僚の書いていたアドカレが TypeScript 界隈記事 2022 ランキングトップだったことを知る

https://qiita.com/wlcmty/items/fcf5be68c830349fa122

> ### 公式ドキュメントを読む癖や習慣を身につける
>
> 中・大規模なシステム開発で使用されるようなライブラリやフレームワークには、その開発者もしくは組織によって作成・管理されている公式ドキュメントがあるはずです。
> そして言うまでもなく、非関係者である不特定多数の個人が書いた解説記事やブログ等よりも、その技術に最も精通している人たちが作成した公式ドキュメントに記載されている情報のほうが質が高くて信頼できるはずです。
>
> 人間は厳しい道よりも楽な道を選びがちなので、ほとんどの新米フロントエンジニアは、専門用語だらけでお堅い文章表現が多くなりがちな公式ドキュメントより、「初心者向け」とか「丁寧に解説してみた」みたいなキーワードが含まれるブログの記事等をクリックしがちです。しかし、私の身近にいるつよつよエンジニアの先輩方はみんな真っ先に公式ドキュメントを読みにいきますし、SNS 等でもそういった声は多いです。

まさに一番重要なのはこれだよなぁ。

このスタンスがちゃんと身につくことに比べたら、 記事中の gSSP の話とかなんて本当に些末なレベル。

---

# 1/19

## CSS

MDN にこんなページが...!

https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox_skills

一応、その場で CSS を書いて動かせるようになってるけど、何の補完も効かないのでかなり辛い。結局 devtool 開いちゃう

---

# 1/20

## Next.js

https://beta.nextjs.org/docs/app-directory-roadmap

## Ruby

`--yjit` を自分たちの業務で利用している Rails アプリケーションに適用させたら、どの程度効果があるのか？を測定した。

graphql-ruby + Active Record 構成の API サーバーであり、load wait の内訳概略が以下のようになっている。

- 3 割程度: Active Record
- 2 割程度: graphql-ruby の Resolver
- 1 割弱: HTTP 呼び出し
- 3 割程度: その他(Rack など)

フロントエンドから実際に利用されているクエリを選定して、hey でラッシュをかけてスループットの比較を行ったが、2~3 % 程度の改善効果しか得られず。
Latency の 50 パーセンタイルで比較した場合も 2%ほどの速度向上。

[YJIT が公表しているベンチマーク](https://speed.yjit.org/benchmarks/bench-2023-01-19-041039) では、railsbench を対象にして、baseline に対して YJIT が 1.4x 高速であることになっていたので「プロダクションコードの倍、5%以上 10%未満くらいかな？」と踏んでいたが、期待していたほどではなかった。

JIT なので当然 Memory に対する trade off が発生するが、これは 上記のベンチ資料にあるのと同じく 30%程度の usage 増大を確認。

## Misc

BuriKaigi:

https://burikaigi.dev/
