# 7/1

## PathQuery

@yosuke_furukawa から教わった https://arxiv.org/pdf/2106.09799.pdf に登場する Google が作っているグラフ志向のクエリ言語。

[Google Knowledge Graph](https://developers.google.com/knowledge-graph) という機能を作成する上で、開発者が扱いやすいクエリ言語が欲しかった、というのが誕生のモチベーションっぽい。

「グラフ志向」という単語だけ見ると GraphQL と比較したくなるような気もするが、Facebook が GraphQL を作ったモチベーションとは結構違いそう。以下は Facebook の GraphQL 開発経緯。

> Back in 2012, Facebook was working on their mobile application for Android and iOS platform. They had to make changes in the rest services according to the mobile platform. To resolve this, either make a different rest API for the Android and iOS platform or do handling at multiple places in a rest service. Sometimes in large codebase it becomes very messy and frustrated to manage it and multiple versioning of the API’s.
>
> I see that sometimes we have a lot of attributes in the response of the rest API’s which sometimes is not useful for the client always, so devices which are on low network bandwidth has to wait long to get big JSON.
>
> Here, Facebook team started to work on GraphQL to solve these problems and rethink data fetching way for devices, specially which are on low network bandwidth. It moved focus on developers at client side to ask what they need.

https://medium.com/@ajaysaini.official/why-graphql-886ba866ae75 より

PathQuery のモチベーションは純粋に「グラフベースなリソース群に対する問い合わせ」にフォーカスされているように思う。論文中で登場する比較対象も GraphQL ではなくて

- Cypher (Neo4J とかの問い合わせに使うやつ)
- SPARQL (AWS Neptune 立てるとコイツのエンドポイント作れる、くらいの知識しかない)

あたりが出てくる。

---

# 7/2

## k8s

仕事で EKS 環境を触る必要がでてきたので :memo:

https://github.com/int128/kubectl-external-forward

というツールで、EKS に reverse proxy となる pod を自動で立てて AWS VPC のリソース (Aurora とか) に Access できるようになる。

## graphql-code-generator

Stitching した Resolver の型を生成する際に `selectionSet` パラメータが必須となっているのはおかしいのでは？疑惑。

https://github.com/dotansimha/graphql-code-generator/blob/master/packages/plugins/typescript/resolvers/src/index.ts#L55

Stitching で出てくるコードのした辺りと型不整合があるような。

https://github.com/ardatan/graphql-tools/blob/aa43054d3415cc29c8a610dea6aa04df5f42e5f9/packages/delegate/src/types.ts#L74

```ts
mergeSchemas({
  schemas: [schemaA, schemaB],
  resolvers: {
    HogeType: {
      fooField: {
        // selectionSet は必須じゃない
        resolve(payload, _args, context, info) {
          // resolver
        }
      }
    }
  }
});
```

---

# 7/5

## GraphQL

お仕事として、GraphQL x React の workshop を開催。

資料は事前に準備していた https://github.com/Quramy/gql-study-workshop のレポジトリをベースに実施。

やはりというか、なんというか、 typescript-graphql-plugin を導入するところで聴講者が結構脱落していった印象。

下記をちゃんと資料に盛り込んでおいた上で、講義中に救うようにしないとダメだなぁ。。。と反省。

- SDL ファイルを Playground から Download してね！
- VSCode は tsconfig.json と同じディレクトリ上で立ち上げてね！
- ちゃんと workspace と同じ version の TypeScript を使ってね！

---

# 7/6

## Misc

jq っぽいツールとして https://github.com/antonmedv/fx を教わった

---

# 7/7

## GraphQL

> Stitching した Resolver の型を生成する際に `selectionSet` パラメータが必須となっているのはおかしいのでは？疑惑。
>
> https://github.com/dotansimha/graphql-code-generator/blob/master/packages/plugins/typescript/resolvers/src/index.ts#L55

上記の件で issue できてた。というか同僚が作ってくれていた。

https://github.com/dotansimha/graphql-code-generator/issues/6243

`selectionSet` に関わる部分は https://github.com/ardatan/graphql-tools/blob/master/packages/stitch/src/types.ts#L108-L113 のところだった

## Misc

`apollo:extract` した JSON を markdown にするだけの CLI を作った。

https://github.com/Quramy/query-json-to-md

---

# 7/8

## TypeScript

TypeScript の code generator のことを考えているうちに、ふと「ts-graphql-plugin の typegen customize で Template String 使いたくなることあるよな...?」と思い、 `@babel/template` のように簡単に利用できる AST generator が欲しくなって、半ば思いつきだけで https://github.com/Quramy/talt という npm package を作る。

```ts
import { template } from "talt";

const userTypeNode = template.type<ts.TypeLiteralNode>`
  {
    readonly firstName: string;
    readonly lastName: string;
    readonly age?: number;
  }
`;
```

## k8s

EKS 環境の仕事をするにあたって、 kubectl の基本的な使い方がわかってなくて色々困りそう。

https://kubernetes.io/ja/docs/reference/kubectl/overview/

## Ruby

普段あまり使わないので大体忘れてる系。

.ruby-version ファイルがあると、rbenv がその version に切り替わる。

ここで何気に bundle install すると、`The bundle command exists in these Ruby versions` というメッセージが出て install が止まるが、

```sh
$ gen install bundler
```

を叩いて、その version でも bundle を突っ込めばよい。

## SwiftUI

Apple 公式の SwiftUI Tutorial があるみたい

https://developer.apple.com/tutorials/swiftui

## tmux

今更だけど、 ウィンドウ一覧を出したときに表示される `M-a` の意味を知る。

`M` はメタキーで Alt キー を意味していたわけだけど、mac の場合、Esc のみがメタキー扱いなので、Option(Alt)をメタキーとして振る舞うように、iTerm2 などで設定する必要があった。

---

# 7/9

## Docker

ようやく Multistage Build がどう動くのかを理解する機会があったのでメモ。

```Dockerfile
FROM node:15-alpine AS base

WORKDIR /app
COPY . .
RUN npm i --no-save --prod

FROM base as installed
RUN npm i --no-save

FROM installed as built
RUN npx tsc

FROM base as prod
COPY --from=built /app/lib /app/lib
CMD ["node", "lib/main.js"]
```

上記のように Dockerfile を書くことで、最終的なビルド成果物には deb dependencies が入った node modules は含まないようにできる。

ただ、中間の stage ごとにも image が build されていることになり、大量に `<none>` という名前無しの image が生まれてしまう。

docker-compose.yaml からは、 `target` キーで中間 stage を参照できる。 この方法で `docker compose build` した場合、`installed` と `app` の image は名前がつくことになる。

```yaml
version: "3.4"

services:
  installed:
    build:
      context: .
      target: installed
    image: installed
  app:
    build:
      context: .
      target: prod
    image: app
```

## xTest

関数に対して、色々なパターンで値を与えて動作を検証するような技法のことを Property Based Testing と呼ぶことを @twada さんに教わる。

もともとは Haskell で作られた [QuickCheck](https://hackage.haskell.org/package/QuickCheck) というパッケージが元祖で、これを真似て xxxCheck という名前の Property Based Testing ライブラリが各言語で生まれたのとこと。

## WASM

[threads proposal](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md) を眺める。

PicoML に GC 実装するとして、thread が使えるネタなのかどうか把握する目的。

Threads Proposal で提供される機能は以下

- WASM Module 側:
  - Atomic な Memory 操作を実現するための instructions
  - JavaScript の `Atomics` における `notify` や `wait` と同等の instructions
- WASM Host 側(JavaScript):
  - Shared Array Buffer が WASM Memory に渡ってきた場合の挙動の変更

スレッド自体は Worker Thread なりを使ってホスト側でやれ、というスタンス。

読んだ感じ、Shared Array Buffer と Atomics を使った操作、ということなので、ECMAScript 側でこれらの挙動を理解する方が早そう。
というか、 `Atomics` なんていう Global Object がいたことを知らなかった。。。

Chrome 92 で Cross Origin Isolation(COOP, COEP を明示的に付与する)ことで、 Shared Array Buffer が再び利用可能になる。

https://developer.chrome.com/blog/enabling-shared-array-buffer/

WASM Thread を調べようと思ったのはたまたまなんだけど、Shared Array Buffer がないと Atomics API も無意味だろうし、Web 上での Thread 共有を考えるにはちょうど良い時期のような。
