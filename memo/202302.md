# 2/1

## Prisma

```prisma
model Product {
  id            String @id
  name          String
  unusedField   String?
}
```

上記のような Schema に対して、 `unusedField` を DB から安全に削除したい、という文脈が仕事で生じた。

愚直に `unusedField` を schema.prisma から削除した場合、 以下のような Migration SQL が生成される。

```sql
ALTER TABLE "Product" ALTER DROP COLUMN "unusedField";
```

自分の職場でもそうだが、大概の CD では、先に Migration を流してから、新しいバージョンのアプリケーションを Deploy するようになっているはず。

この場合、Prisma Client の `prisma.product.findFirst()` などが発行する SQL はデフォルトでは以下のようになる。

```sql
-- BEFORE
SELECT "id", "name", "unusedField" FROM "Product";

-- AFTER
SELECT "id", "name" FROM "Product";
```

すなわち、DROP COLUMN の Migration が適用された直後に Before の側のコードでクライアントが動作すると、列名指定に不整合が発生して SQL 例外となる。

列を削除するのだから、事前に該当列の利用は削除されているはずなのであり、先に After の状態となる Prisma Client を Deploy してから Migration を流したいわけだ。

「Migration を生成せずに、Client Generation のみを行う Schema 変更」の方法が無いか調べたところ、 https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#ignore が一番適合しそうであった。

```prisma
model Product {
  id            String    @id
  name          String
  unusedField   String?   @ignore
}
```

上記の様に、削除予定の列に `@ignore` を付与すると、`unusedField` に関する一切を出力しなくなる（なお、Model に対して同様のことをおこなう `@@ignore` という attribute もある)。

- `@ignore` を付与した schema.prisma で Generate を行って deploy
- schema.prisma から Field を消して migration を生成して deploy

の 2 段階で deploy を行えばよい。

なお、Active Record の場合は `SELECT * FROM "Product"` の SQL となるため、列名指定の不整合は発生しない。

SQL として、というよりもライブラリとして、Prisma と Active Record のどちらが良いかは一長一短ありそうだが、Prisma "Client" というだけのことはあって、Database を API だと思えば、削除系、すなわち Forward Compatible な変更は Downstream から先に Deploy しろ、が鉄則である。

Prisma をわざわざ v2 と呼ばなくなって久しいが、Scala GraphQL server を提供していた時代はたしかに Prisma は API Client として動作していたわけで、当たり前のように Scalar 側と Client 側の deploy が非同期に行われていたことを考えると、この堅さには得心が行くものがある。

# 2/2

## Storycap

CircleCI でのテストが git clone でコケていたので、いい機会なので GitHub Actions に移行することにする。
最近、Storycap のメンテナンス放置しすぎていた、というのもある。1 年くらいほったらかしにしてしまっていた。
一旦、諸々の branch や 小粒な PR を全て master に取り込んで v4.0 をリリースした。

---

## Web

https://web.dev/interop-2023/

色々あるが、 Import assertion が取り上げられているが、TC39 側で Stage 2 に格下がったらしい。
背景として、JavaScript エンジンがホストに対して、script となか stylesheet なのかの情報を import する前に渡さないと、CSP に適合させることができない、というのもある模様。

```js
// 現状のProposal
import "./styles.css" assert { type: "css" };

// 新しい Syntax proposal
import "./styles.css" with { type: "css" };
```

Web の世界では例えば CSS であれば、以下のように書いて初めて CSS として解釈される。これは「styles.css を Stylesheet として取得して欲しい」を意味しているわけで、結局 JavaScript での import についても 非 js を考えるのであれば、link や script 要素と同じ様にリソースの取得方法を事前にリソースローダーに渡しておき、リソースローダーがそのコンテンツに対して、読み込み可否を判断する必要が出てくる。

```html
<link rel="stylesheet" href="styles.css" />
```

---

# 2/7

## React

たまたま目についた LogRocket が書いた React 実装パターンの blog

https://blog.logrocket.com/react-design-patterns/

ざっと斜め読みしたけど、あまり目新しいことは書いてなかった

---

# 2/8

## Prisma

https://github.com/prisma/prisma/issues/16582 の Interactive Transaction で Client Extension が効かない問題が Prisma v4.10 で修正されていた。
jest-prisma の方も対応いれないと。。。

---

# 2/13

## jest-prisma

https://github.com/Quramy/jest-prisma/pull/74 でちょっとした機能追加 PR をもらっていた。ありがたく merge & publish

## Node.js

久しぶりに Node 学園があるみたい。

https://nodejs.connpass.com/event/275061/

connpass にはオフラインって記述あるけど、参加枠はオンラインだけになっててどっちやねん状態。@yosuke_furukawa さんに直接聞いてみるか。

## JWT

久しぶりに https://www.npmjs.com/package/jsonwebtoken を触ったけど、そうえいば key って String だけじゃなくてバイナリ( `Buffer` ) も渡せるのな。
変に `Buffer.from(SELECT, 'base64').toString()` のようなこねくり回しをしたせいで無駄に時間浪費してしまった。

```js
const key = Buffer.from(process.env.SECRET);
const token = jwt.sign(obj, key);
```

---

# 2/14

## Web

Declarative Shadow DOM について、あまりにも何も知らないので少し調べる。

- https://web.dev/declarative-shadow-dom/

Shadow DOM は、昔っからの Web Components のキーワードであり、ドキュメントルートからは分離されたスコープを持つ DOM ツリーのこと。

これを、SSR など、HTML 自体で宣言的に書く手段が提供されるから "Declarative" ってことか。

## CSS

https://www.webkit.org/blog/13813/try-css-nesting-today-in-safari-technology-preview/

Chrome / Safari Tech Preview で CSS Nesting が ship されるらしい。

https://webkit.org/blog/13607/help-choose-from-options-for-css-nesting-syntax/ でも紹介されているが、SCSS でお馴染みの `&` token についての位置づけについて。

```css
a {
  color: red;
  &:hover {
    color: blue;
  }
}
```

まず、そもそもの前提として、以下のようなネストは invalid になる。

```css
ul {
  li {
    color: red;
  }
}
```

nest されてる `li` の要素セレクタが「文字で開始する」トークンであることが CSS の parse エンジン上、都合が悪い。
(具体的になんで都合が悪いのかはよく分かってない)

nest されるセレクタのトークンが文字開始でなければいいので、 `&` を置くことで回避できる。

```css
ul {
  & li {
    color: red;
  }
}
```

要素セレクタ以外は、symbol token から始まるので、あまり気にする必要は無く、SCSS であったような従来の記法もそのまま使える。

```css
li {
  margin-top: 0;
  &:not(:first-child) {
    margin-top: 4px;
  }
}
```

blog 読んでて何それって思ったのが `&` を後置する件。

```css
h1 {
  font-weight: bold;
  .hero & {
    font-size: 10rem;
  }
}
```

```css
h1 {
  font-weight: bold;
}

.hero h1 {
  font-size: 10rem;
}
```

これ、自分が知らないだけで Sass でも昔っからできたらしい。
