# 2/1

## Prisma

```prisma
model Product {
  id            String @id
  name          String
  unusedField   String?
}
```

上記のような Schema に対して、 `unusedField` を DB から安全に削除したい、という文脈が仕事で生じた。

愚直に `unusedField` を schema.prisma から削除した場合、 以下のような Migration SQL が生成される。

```sql
ALTER TABLE "Product" ALTER DROP COLUMN "unusedField";
```

自分の職場でもそうだが、大概の CD では、先に Migration を流してから、新しいバージョンのアプリケーションを Deploy するようになっているはず。

この場合、Prisma Client の `prisma.product.findFirst()` などが発行する SQL はデフォルトでは以下のようになる。

```sql
-- BEFORE
SELECT "id", "name", "unusedField" FROM "Product";

-- AFTER
SELECT "id", "name" FROM "Product";
```

すなわち、DROP COLUMN の Migration が適用された直後に Before の側のコードでクライアントが動作すると、列名指定に不整合が発生して SQL 例外となる。

列を削除するのだから、事前に該当列の利用は削除されているはずなのであり、先に After の状態となる Prisma Client を Deploy してから Migration を流したいわけだ。

「Migration を生成せずに、Client Generation のみを行う Schema 変更」の方法が無いか調べたところ、 https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#ignore が一番適合しそうであった。

```prisma
model Product {
  id            String    @id
  name          String
  unusedField   String?   @ignore
}
```

上記の様に、削除予定の列に `@ignore` を付与すると、`unusedField` に関する一切を出力しなくなる（なお、Model に対して同様のことをおこなう `@@ignore` という attribute もある)。

- `@ignore` を付与した schema.prisma で Generate を行って deploy
- schema.prisma から Field を消して migration を生成して deploy

の 2 段階で deploy を行えばよい。

なお、Active Record の場合は `SELECT * FROM "Product"` の SQL となるため、列名指定の不整合は発生しない。

SQL として、というよりもライブラリとして、Prisma と Active Record のどちらが良いかは一長一短ありそうだが、Prisma "Client" というだけのことはあって、Database を API だと思えば、削除系、すなわち Forward Compatible な変更は Downstream から先に Deploy しろ、が鉄則である。

Prisma をわざわざ v2 と呼ばなくなって久しいが、Scala GraphQL server を提供していた時代はたしかに Prisma は API Client として動作していたわけで、当たり前のように Scalar 側と Client 側の deploy が非同期に行われていたことを考えると、この堅さには得心が行くものがある。

# 2/2

## Storycap

CircleCI でのテストが git clone でコケていたので、いい機会なので GitHub Actions に移行することにする。
最近、Storycap のメンテナンス放置しすぎていた、というのもある。1 年くらいほったらかしにしてしまっていた。
一旦、諸々の branch や 小粒な PR を全て master に取り込んで v4.0 をリリースした。

---

## Web

https://web.dev/interop-2023/

色々あるが、 Import assertion が取り上げられているが、TC39 側で Stage 2 に格下がったらしい。
背景として、JavaScript エンジンがホストに対して、script となか stylesheet なのかの情報を import する前に渡さないと、CSP に適合させることができない、というのもある模様。

```js
// 現状のProposal
import "./styles.css" assert { type: "css" };

// 新しい Syntax proposal
import "./styles.css" with { type: "css" };
```

Web の世界では例えば CSS であれば、以下のように書いて初めて CSS として解釈される。これは「styles.css を Stylesheet として取得して欲しい」を意味しているわけで、結局 JavaScript での import についても 非 js を考えるのであれば、link や script 要素と同じ様にリソースの取得方法を事前にリソースローダーに渡しておき、リソースローダーがそのコンテンツに対して、読み込み可否を判断する必要が出てくる。

```html
<link rel="stylesheet" href="styles.css" />
```

---

# 2/7

## React

たまたま目についた LogRocket が書いた React 実装パターンの blog

https://blog.logrocket.com/react-design-patterns/

ざっと斜め読みしたけど、あまり目新しいことは書いてなかった

---

# 2/8

## Prisma

https://github.com/prisma/prisma/issues/16582 の Interactive Transaction で Client Extension が効かない問題が Prisma v4.10 で修正されていた。
jest-prisma の方も対応いれないと。。。
