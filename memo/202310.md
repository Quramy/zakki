# 10/2

## prisma-fabbrica

prisma v5.3.x から出続けていた、DMMF 周りの TypeScript エラー修正。

## dd-trace

Next.js の instrumentation.ts + dd-trace で苦戦中。

https://github.com/DataDog/dd-trace-js/issues/3457#issuecomment-1669499660 にあるように Dynamic Import で Tracer の初期化を行うも、undici にしか計装がかからない。

next plugin が動いてくれないと旨味皆無なんだが。。。

```ts
/* src/insturumentation.ts */

export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    const tracerLib = await import("dd-trace");
    const tracer = tracerLib.default;

    tracer.init({ logInjection: true });
    tracer.use("next");
  }
}
```

やっぱり tracer の初期化を行うには、 `register` 関数が呼び出されるのが遅すぎる、という話なんだろうか？

Custom Server なのかなぁ。。このために Custom Server 使うの嫌だなぁ。。。

---

# 10/3

## Tsuquyomi

全然使い物になっていなかった `:TsuReloadProject` を再実装する。

Git branch を切り替えた際に実行することがメインのユースケースなのだけど、

1. バッファには残っているが FS 上から削除されたファイルを tsserver から close する
1. バッファで開き続けているファイルを tsserver へ sync しなおす

を行うようにした。

Git 操作だけでなく、Vim 外の操作( e.g. code generation) によって外部更新された .ts ファイルについても対象となるので、今まで何年も脳死で tsserver とズレが起き出していたら Vim ごと閉じる癖がついてしまっていたのが解消されそう。

## Vim

今更ながら Vim script におけるメソッドとラムダの記法について

```vim
echo len("hogehoge")

" method
echo "hogehoge"->len()

" lambda expr
let Lambda = {i, x -> x * 2} " 左辺は Funcref 型
echo map([1, 2, 3], Lambda)
```

メソッドとラムダを混在させれば以下のように書ける:

```vim
echo [1,2,3]->map({i, x -> x * 2})
```

vim9script だと、ラムダ式のトークンは `->` ではなく、`=>` になるので、メソッド/ラムダの Lexing が行いやすくなっているらしい。
問題はプラグインなどの外部公開するようなコードで vim9script がどの程度受け入れられているのか全然肌感がわからんことだ。

まずは手元の .vimrc を分割して vim9script 化していくのがいいのかねぇ。。

## React

React の cache 関数 ( https://react.dev/reference/react/cache ) で遊んだ。

```tsx
import { cache } from "react";

import DataLoader from "dataloader";

import { getPopularPosts, getUserById, getUsers } from "../../services";

const memoizedGetUserById = cache(getUserById);

const getUserLoader = () =>
  new DataLoader((id: readonly string[]) =>
    getUsers(id).then((users) => id.map((id) => users.find((u) => u.id === id)))
  );

const memoizedGetUserLoader = cache(getUserLoader);

export async function User({ userId }: { userId: string }) {
  // const result = await memoizedGetUserById(userId);
  const result = await memoizedGetUserLoader().load(userId);
  if (!result) return null;

  const { name, email } = result;

  return (
    <div>
      <p>{name}</p>
      <p>{email}</p>
    </div>
  );
}

export default async function Posts() {
  const posts = await getPopularPosts();
  return posts.map((post) => (
    <ol>
      <li key={post.id}>
        <h3>{post.title}</h3>
        <User userId={post.authorId} />
      </li>
    </ol>
  ));
}
```

特に配列の要素について、Component とデータの取得を collocate させるような設計をしたとすると、React の cache 関数単体だと、N + 1 になる。
上記の例だと、ナイーブな `getUserById` の実行が、Posts の author 人数分発生する。

ここで、 バルクで解決できる実装が提供されている場合、 `getUsers` こいつを Dataloader でくるんでやれば、 N + 1 を解消できる、というのが GraphQL の基本なわけだけど、このテクニックってそのまま RSC の世界でも通用するはず。
GraphQL Resolver でいうところの Execution Context 相当を React.cache から提供するようにすればよいかと思い、やってみたのが上記のコード。

React.cache で Dataloader のインスタンスを返す関数をキャッシュさせれば、Async Component から loader が利用できる。
