# 2/1

## Puppeteer

業務で作ってるちょっとした Webview 画面の HTML について、Puppeteer オンリーでテストコードを記述する、というのをやってみた。

そもそも自動テスト書くほど機能が豊富なページではないんだけど、半分くらいは暇だったので書いてみた、というのに近い。

昨年末に Medium に書いた ARIA ハンドラを実際に HTML のテストに組み込んでみたかった、というのもある。

例えば下記のような感じ。

```js
async testPage(page) {
  const inputHandle = await page.$('aria/ユーザー名[role="textbox"]')

  assert.equal(await inputHandle.evaluate(elm => elm.type), 'email')
  assert.equal(await inputHandle.evaluate(elm => elm.maxLength), 40)
}
```

ついでにというか、ARIA ハンドラとは全然関係ないが、既存の Element Handle から、新しく別の要素の Element Handle を作ろうとして、

```js
const newHandle = await someElementHandle.evaluate(
  node => node.nextElementSibling
);
```

のように書いたら全然動かなくて 10 分くらいハマってた。正しくは `evaluateHandle` を使う。

```js
const newHandle = await someElementHandle.evaluateHandle(
  node => node.nextElementSibling
);
```

## Misc

薄々分かってはいたんだけど、1 月、全然 input も自発的な勉強もしてなかったのが memo の量からも一目瞭然だ。自覚はあったけど、実際に昨年の 12 月分と比較すると記載量としてもボリュームめちゃめちゃ少ないもんな。。。別に量を書くことが目的じゃないけど、流石に何もしてなさすぎて危機感出るわ。

---

# 2/2

## Vite

https://vitejs.dev/

新しいバンドルツール？仏語で「速い」という意味らしい。

rollup をラップして、dev-server や optimizer などの便利設定をまとめたツール的なイメージだろうか。

dependencies に rollup と esbuild 両方入ってるけどそういうものなのか？

## Spring MVC

ちょっとしたログインフォームを Spring MVC + Thymeleaf で書く、というのをやってみた。
Java で Server-Side Web 書くの久々なので色々忘れてる。API の Controller 書くのはそこまで苦に感じないだろうけど、画面出てくると途端にうんざりしてくるな。。

```java
@Controller
public class MyController {

    @GetMapping("/signup")
    public String getSignupPage(Model model) {
        if (!model.containsAttribute(ClassUtils.getShortNameAsProperty(SignupForm.class))) {
            model.addAttribute(new SignupForm());
        }
        return "/signup";
    }

    @PostMapping("/signup")
    public String signup(@Validated SignupForm form, BindingResult br, RedirectAttributes ra) {
        ra.addFlashAttribute(form);
        ra.addFlashAttribute(BindingResult.MODEL_KEY_PREFIX + Conventions.getVariableName(form), br);
        return "redirect:/signup";
    }
}
```

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>アカウント作成</title>
  </head>
  <body>
    <form method="post" action="/authenticate" th:object="${signupForm}">
      <div>
        <label for="username">ユーザー名</label>
        <input
          id="username"
          name="username"
          type="email"
          th:field="*{username}"
          th:aria-invalid="${#fields.hasErrors('username')}"
        />
      </div>
      <div>
        <label for="password">パスワード</label>
        <input
          id="password"
          name="password"
          type="password"
          th:field="*{password}"
          autocomplete="new-password"
          th:aria-invalid="${#fields.hasErrors('password')}"
        />
      </div>
      <button type="submit">アカウント作成</button>
    </form>
  </body>
</html>
```

## Croquette

約一月ぶりにレポジトリのファイル開くも、やはり手が止まってしまう。

`@defer` とかに囚われすぎてるような気もするし、そもそも Store 層用意して何がやりたいのかが分からなくなってきてるのよなぁ。。。

どうしても 「`useFragment` という hooks を実装すること」ばかりが先行して、その接続先として cache を用意する発想になってるけど、そもそも正規化された data cache を client に置く目的は別に Deferred Fragment のためじゃないはず。

まずは各 Client Library が Cache や refetch をどう扱ってるのかをちゃんと知ることから考えた方がいいかもしれない。

## GraphQL

上記の続き。

ちなみに、ちょっと調べた感じ、urql はデフォルトでは Normalized Cache 持ってないらしい。

- https://formidable.com/open-source/urql/docs/basics/document-caching/
- https://formidable.com/open-source/urql/docs/graphcache/normalized-caching/

Document Cache, Normalized Cache のことをもやもやと考えていたら、何故かふと Hibernate の Cache のことを思い出す。

Hibernate も Entity レベルの Cache と Query レベルの Cache と 2 種類あるし、GraphQL クライアントってある意味 O/R マッパと似ているところがある。
思い付きの類似関係だけで無理やり考えをまとめようとするのは良くないが、「Normalized Cache な GraphQL Client を作ろうとするのって、ある意味 Entity Manager を実装しようとしているのと同じでは？」と思ってしまった。

実際問題、GraphQL を使ったアプリケーション自体は、どっかしらで永続化層にたどり着くし、それが Entity であることにはそこまで変な話じゃない。したがって、Server Side で Entity Cache として実装されてた概念をさらに Client にも Cache 層にもってくること自体は良しとする。
ただ、GraphQL が JPA や Active Record と大きく違うのは、Entity を通した操作なんて存在しない。

GraphQL では、

- ID をベースに Entiry の instance を生成する
- 得られた Entity を操作して、更新・削除を行う

といったアプローチは使われず、Query と Mutation が支配する世界だ。理解が間違ってる可能性も大いにあるけど、CQRS の方が考え方としては親しいものがある。

Client の中で、Entity レベルの Cache、すなわち Single of truth が確保されていることによるメリットって何だ？という話になってくる。
結局、Normalized Cache の何が嬉しいのか、という話になってくるな。

## Misc

https://github.com/xtyrrell/undollar StackOverflow なんかでよくある `$ tar xvfJ something.tar.xz` のような先頭に `$` ついてる shell command をそのままコピペしたときに ドルマークが鬱陶しい問題を解決するだけの CLI。大した機能じゃないけど、この発想は無かった。

---

# 2/3

## TypeScript

```ts
type Hoge = number | null;
type Foo = NonNullable<Hoge>; // number;
```

ってなる `NonNullable` を知る。これを知った事自体はどうでもいいけど、自分でこの型定義が書けなくなってたことがやばかった。Union と Conditional Type の交換則...

## reg

「GitHub にコメントするときに、update ではなく、delete and insert 的な挙動にしてほしい」というリクエストが来ていたので対応する。

https://github.com/reg-viz/reg-suit/issues/364

運用として reg の PR コメントに `:+1:` の emoji リアクションが付いているかどうかで見分けているから、とのこと。

## Misc

FrontEnd Performance Checklist 2021 の担当箇所(Build Optimization)の読み込み開始する。

---

# 2/4

## Front-End Performance Checklist 2021

読み込み作業の続き。びっくりするくらい時間かかるな、、、これ。別ファイルにまとめ中。

## Misc

https://github.com/WICG/app-history というのが提案されているらしい。SPA で利用可能な History API の後継版的な位置づけ？

---

# 2/5

## Front-End Performance Checklist 2021

なんとか読み込み切った。

## Misc

社内勉強会で OOUI 設計の話を聞く。名前だけしか聞いたことなかったやつ。
イメージとして、「やらせたいこと（=動詞)ではなく、まずはモノ（=名詞）を見せた後に、そのモノに付随する動作を見せる」というような考え方っぽい。
