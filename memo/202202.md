# 2/1

## a11y

dnd kit の keyboard 対応がちゃんとしている、という話を同僚とする。

https://docs.dndkit.com/guides/accessibility#keyboard-support

## react-hook-form

Nested Form のパターン、より正確には「フォーム中で出現する子フォームを再利用性を保ちつつ取り扱う」ということを達成するために悩んでいる。

やりたいことのイメージとしては、GraphQL client におけるコロケーションのような「子の構造を隠蔽しつつ Aggregate すると全体の構造が完成する」というやつなのだけど、中々これがうまくいかない。

```tsx
import { UseFormRegister } from "react-hook-form";

export type UserProfileFormData = {
  readonly firstName: string;
  readonly lastName: string;
  readonly address: string;
};

export const defaultValue: UserProfileFormData = {
  firstName: "",
  lastName: "",
  address: ""
};

export type ChildFormProps = {
  register: UseFormRegister<{ readonly profile: UserProfileFormData }>;
};

export function ChildForm({ register }: ChildFormProps) {
  return (
    <>
      <label>
        <input type="text" {...register("profile.firstName")} />
      </label>
      <label>
        <input type="text" {...register("profile.lastName")} />
      </label>
      <label>
        <input type="text" {...register("profile.address")} />
      </label>
    </>
  );
}
```

```tsx
import { useForm } from "react-hook-form";

import {
  UserProfileFormData,
  ChildForm,
  defaultValue as childDefaultValue
} from "./childForm";

type FormData = {
  readonly name: string;
  readonly profile: UserProfileFormData;
};

export function ComplexForm() {
  const useFormReturn = useForm<FormData>({
    defaultValues: {
      name: "",
      profile: childDefaultValue
    }
  });
  const { register, handleSubmit } = useFormReturn;

  return (
    <form onSubmit={handleSubmit(formData => console.log(formData))}>
      <FormProvider {...useFormReturn}>
        <section>
          <input type="text" {...register("name")} />
        </section>
        <section>
          <ChildForm register={register} />
        </section>
        <button type="submit">submit</button>
      </FormProvider>
    </form>
  );
}
```

一番シンプルなのは、上記のように、`useForm` の結果を下層に伝播していくパターン.
本来は `profile.` という「親の構造における自分への access 方法」を直接知ってしまっているので、あまり良くないが、ここは TypeScript 的になんとかできるのか？

また、親子で `UseFormRegister` の型エラーが出る。
これは当たり前で、

- 親側の `register` に許容される key: `"name" | "profile.firstName" | "profile.lastName" | "profile.address"`
- 子飼の `register` に許容される key: `"profile.firstName" | "profile.lastName" | "profile.address"`

`FormData` は `{ readonly profile: UserProfileFormData }` の Sub Type なので、 `UseFormRegister` の型が反変することによって起きる。
key が引数側に現れる `watch` や `setValue` も一緒。

一方で 子 Component へのバケツリレーを嫌う場合に Context を利用するパターンも用意されている。

https://react-hook-form.com/advanced-usage#FormProviderPerformance

```tsx
import { useFormContext } from "react-hook-form";

export type UserProfileFormData = {
  readonly firstName: string;
  readonly lastName: string;
  readonly address: string;
};

export const defaultValue: UserProfileFormData = {
  firstName: "",
  lastName: "",
  address: ""
};

export function ChildFormWithContext() {
  const { register } =
    useFormContext<{ readonly profile: UserProfileFormData }>();
  return (
    <>
      <label>
        <input type="text" {...register("profile.firstName")} />
      </label>
      <label>
        <input type="text" {...register("profile.lastName")} />
      </label>
      <label>
        <input type="text" {...register("profile.address")} />
      </label>
    </>
  );
}
```

```tsx
import { useForm, FormProvider } from "react-hook-form";

import {
  UserProfileFormData,
  defaultValue as childDefaultValue,
  ChildFormWithContext
} from "./childForm";

type FormData = {
  readonly name: string;
  readonly profile: UserProfileFormData;
};

export function ComplexForm() {
  const useFormReturn = useForm<FormData>({
    defaultValues: {
      name: "",
      profile: childDefaultValue
    }
  });
  const { register, handleSubmit } = useFormReturn;

  return (
    <form onSubmit={handleSubmit(formData => console.log(formData))}>
      <FormProvider {...useFormReturn}>
        <section>
          <input type="text" {...register("name")} />
        </section>
        <section>
          <ChildFormWithContext />
        </section>
        <button type="submit">submit</button>
      </FormProvider>
    </form>
  );
}
```

この書き方だと確かに TypeScript 上の型エラーにはなりえないのだけど結局「親 form の部分構造に子 form が出現する」という制約がどこにも表現されていない。共変性・反変性の問題以前に、その自分で勝手に Context Value を宣言してしまうことになるため、静的型検査の観点で考えるとバケツリレーのコードの方がまだマシ、とすら言えるかもしれない。
