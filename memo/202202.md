# 2/1

## a11y

dnd kit の keyboard 対応がちゃんとしている、という話を同僚とする。

https://docs.dndkit.com/guides/accessibility#keyboard-support

## react-hook-form

Nested Form のパターン、より正確には「フォーム中で出現する子フォームを再利用性を保ちつつ取り扱う」ということを達成するために悩んでいる。

やりたいことのイメージとしては、GraphQL client におけるコロケーションのような「子の構造を隠蔽しつつ Aggregate すると全体の構造が完成する」というやつなのだけど、中々これがうまくいかない。

```tsx
import { UseFormRegister } from "react-hook-form";

export type UserProfileFormData = {
  readonly firstName: string;
  readonly lastName: string;
  readonly address: string;
};

export const defaultValue: UserProfileFormData = {
  firstName: "",
  lastName: "",
  address: ""
};

export type ChildFormProps = {
  register: UseFormRegister<{ readonly profile: UserProfileFormData }>;
};

export function ChildForm({ register }: ChildFormProps) {
  return (
    <>
      <label>
        <input type="text" {...register("profile.firstName")} />
      </label>
      <label>
        <input type="text" {...register("profile.lastName")} />
      </label>
      <label>
        <input type="text" {...register("profile.address")} />
      </label>
    </>
  );
}
```

```tsx
import { useForm } from "react-hook-form";

import {
  UserProfileFormData,
  ChildForm,
  defaultValue as childDefaultValue
} from "./childForm";

type FormData = {
  readonly name: string;
  readonly profile: UserProfileFormData;
};

export function ComplexForm() {
  const useFormReturn = useForm<FormData>({
    defaultValues: {
      name: "",
      profile: childDefaultValue
    }
  });
  const { register, handleSubmit } = useFormReturn;

  return (
    <form onSubmit={handleSubmit(formData => console.log(formData))}>
      <FormProvider {...useFormReturn}>
        <section>
          <input type="text" {...register("name")} />
        </section>
        <section>
          <ChildForm register={register} />
        </section>
        <button type="submit">submit</button>
      </FormProvider>
    </form>
  );
}
```

一番シンプルなのは、上記のように、`useForm` の結果を下層に伝播していくパターン.
本来は `profile.` という「親の構造における自分への access 方法」を直接知ってしまっているので、あまり良くないが、ここは TypeScript 的になんとかできるのか？

また、親子で `UseFormRegister` の型エラーが出る。
これは当たり前で、

- 親側の `register` に許容される key: `"name" | "profile.firstName" | "profile.lastName" | "profile.address"`
- 子飼の `register` に許容される key: `"profile.firstName" | "profile.lastName" | "profile.address"`

`FormData` は `{ readonly profile: UserProfileFormData }` の Sub Type なので、 `UseFormRegister` の型が反変することによって起きる。
key が引数側に現れる `watch` や `setValue` も一緒。

一方で 子 Component へのバケツリレーを嫌う場合に Context を利用するパターンも用意されている。

https://react-hook-form.com/advanced-usage#FormProviderPerformance

```tsx
import { useFormContext } from "react-hook-form";

export type UserProfileFormData = {
  readonly firstName: string;
  readonly lastName: string;
  readonly address: string;
};

export const defaultValue: UserProfileFormData = {
  firstName: "",
  lastName: "",
  address: ""
};

export function ChildFormWithContext() {
  const { register } =
    useFormContext<{ readonly profile: UserProfileFormData }>();
  return (
    <>
      <label>
        <input type="text" {...register("profile.firstName")} />
      </label>
      <label>
        <input type="text" {...register("profile.lastName")} />
      </label>
      <label>
        <input type="text" {...register("profile.address")} />
      </label>
    </>
  );
}
```

```tsx
import { useForm, FormProvider } from "react-hook-form";

import {
  UserProfileFormData,
  defaultValue as childDefaultValue,
  ChildFormWithContext
} from "./childForm";

type FormData = {
  readonly name: string;
  readonly profile: UserProfileFormData;
};

export function ComplexForm() {
  const useFormReturn = useForm<FormData>({
    defaultValues: {
      name: "",
      profile: childDefaultValue
    }
  });
  const { register, handleSubmit } = useFormReturn;

  return (
    <form onSubmit={handleSubmit(formData => console.log(formData))}>
      <FormProvider {...useFormReturn}>
        <section>
          <input type="text" {...register("name")} />
        </section>
        <section>
          <ChildFormWithContext />
        </section>
        <button type="submit">submit</button>
      </FormProvider>
    </form>
  );
}
```

この書き方だと確かに TypeScript 上の型エラーにはなりえないのだけど結局「親 form の部分構造に子 form が出現する」という制約がどこにも表現されていない。共変性・反変性の問題以前に、その自分で勝手に Context Value を宣言してしまうことになるため、静的型検査の観点で考えるとバケツリレーのコードの方がまだマシ、とすら言えるかもしれない。

---

# 2/2

## CSS

縦書きにおける文字の向きについて。

文字フローの方向と Box の並びの方向設定は `writing-mode` で基本的に決定される。日本語縦書きであれば `vertical-rl`。

以下に記載があるが、まずは UA デフォルトに任せるべき。

https://www.w3.org/International/articles/vertical-text/

> In vertical text, certain characters are normally upright and others are normally rotated sideways. The Unicode Standard assigns a property to each character and browsers can use this to determine the default orientation of a given character. For example, ordinary number digits in vertical text lie on their side by default, whereas fullwidth digits and enclosed alphanumerics, such as ①, are upright by default.

Unicode のコードポイントに対して、向きを決定するのはブラウザの判断となるため、特定のコードポイントに対するグリフの向きが期待と異なるということは発生しうる。

その場合に狙い撃ちで向きを矯正するために用いるのが `text-orientation` ということになる。

実際に iOS Safari と Chrome で `…` (三点リーダー) に作用する Orientation の挙動が異なったために調べる形に。

iOS Safari の場合、 `text-orientation: upright` とすると、・が横方向に並ぶ様に変化する。一方で Chrome の場合、 `text-orientation` の値に関わらず、 `writing-mode: vertical-rl` となった時点で縦並びのままで変化しない。

いずれにせよ、 `text-orientation` 自体、Block レベルに作用させるものというよりも、パラグラフの一部に指定するために利用するべきものらしい。

付随して、 `font-feature-settings` などのキワモノ系のプロパティも少し調べた。例えば以下の指定を行うと、（ASCII の範囲も含む Latin）文字まで全角のグリフに置き換える、というヤツ。

```css
font-feature-settings: "fwid";
```

https://docs.microsoft.com/ja-jp/typography/opentype/spec/features_fj#tag-fwid
