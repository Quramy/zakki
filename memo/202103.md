# 3/1

## Storycap

「`connect` API を使って、既に立ち上げ済みの Chrome のブラウザプロセスにつなぎたい」という要望が来た。 https://github.com/reg-viz/storycap/issues/374

この API を知らなかったので、一見悪く無さそうな気もしたが、

https://github.com/puppeteer/puppeteer/blob/main/docs/api.md#puppeteerconnectoptions

を見ると、

> This methods attaches Puppeteer to an existing browser instance.

と書いてあるので、自由に並列数分の `launch` をしている現行のようにはいかないのでは？という疑問がある。
仮に browser 数を 1 にしても、storyshots-puppeteer よりは十分速いだろうけど、ちょっと微妙かもなー、という気持ち。

## ts-playground-plugin-vim

TypeScript Playground を dark theme にしたら、Vim 拡張の status bar が読めなくなってしまったので、何とかしたいが、手元で build できぬ。。。 :sob:

## TypeScript

Mini Interpreter 書き直しの件。

加減乗除、エラー表示までは大体でけた。ちょうど Playground の version も 4.2.2 になったので、とりあえず type-dungeon にあげてから考えるか？

---

# 3/2

## abacus-ts

Mini Interpreter の d.ts を npm に置いてみることにした。

https://github.com/Quramy/abacus-ts

何故か AWS の人から star もらえたけど何でだ。

結果だけでなくて、「どうやって作るか」を読み物として残したいけど、英語書くの手間やなぁ。こういうの「xx までにどこかに提出しろ！」という圧力が無いと絶対進まない。

## TypeScript

型パズルでのテストについて幾つか考えてみた。

下記はあると嬉しい機能。

- できれば何も出力したくない
- テストが失敗したときに、デバッグがしやすい

```ts
// テストしたい型作用素の例
type TargetType<T> = T extends string ? "hogE" : "fuga";
```

パターン 1: 雑に定数に打ち込んで確認する系.

値が必要になってる時点であまり嬉しくない。 雑に Playground とかで試すときとかに使うくらい。

```ts
const testWithString: TargetType<""> = "hoge";
const testWithNumber: TargetType<100> = "fuga";
```

パターン 2: interface の declaration merging を使う。

property 1 つがそれぞれテストケースに相当。 特に何も用意する必要が無いので手軽。 tsc のエラーメッセージにも actual と expected の双方が出るのでわかりやすい。

ただし、 actual と expected の prop 名を間違えると悲惨. 2 個目の interface でも property の補完効かない

```ts
interface TestTargetType1 {
  withString: TargetType<"">;
  withNumber: TargetType<100>;
}
interface TestTargetType1 {
  withString: "hoge";
  withNumber: "fuga";
}
```

パターン 3: interface extension で検証する

property 1 つがそれぞれテストケースに相当。 base となる interface と 型検査を行うための util type は用意する必要あり。

```ts
interface TestTargetType2 extends TypeTestSuite {
  withString: AssertIs<TargetType<"">, "hoge">;
  withNumber: AssertIs<TargetType<100>, "fuga">;
}

interface AssertSuccess {
  readonly resultOk: unique symbol;
}
type AssertFailure<A, B> = [actual: A, expected: B];
type TypeTestSuite = {
  [caseName: string]: AssertSuccess;
};
type AssertIs<A, B> = A extends B
  ? B extends A
    ? AssertSuccess
    : AssertFailure<A, B>
  : AssertFailure<A, B>;
```

## Misc

仕事で久々に生 JavaScript な React + Redux アプリケーションに触れた。
ここ最近はずっと TypeScript でのアプリケーションばかりだったので、Go to definition が使えない環境が久々過ぎて、エディタの感掴むのにちょっと時間がかかる。
