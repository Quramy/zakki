# 3/1

## Storycap

「`connect` API を使って、既に立ち上げ済みの Chrome のブラウザプロセスにつなぎたい」という要望が来た。 https://github.com/reg-viz/storycap/issues/374

この API を知らなかったので、一見悪く無さそうな気もしたが、

https://github.com/puppeteer/puppeteer/blob/main/docs/api.md#puppeteerconnectoptions

を見ると、

> This methods attaches Puppeteer to an existing browser instance.

と書いてあるので、自由に並列数分の `launch` をしている現行のようにはいかないのでは？という疑問がある。
仮に browser 数を 1 にしても、storyshots-puppeteer よりは十分速いだろうけど、ちょっと微妙かもなー、という気持ち。

## ts-playground-plugin-vim

TypeScript Playground を dark theme にしたら、Vim 拡張の status bar が読めなくなってしまったので、何とかしたいが、手元で build できぬ。。。 :sob:

## TypeScript

Mini Interpreter 書き直しの件。

加減乗除、エラー表示までは大体でけた。ちょうど Playground の version も 4.2.2 になったので、とりあえず type-dungeon にあげてから考えるか？

---

# 3/2

## abacus-ts

Mini Interpreter の d.ts を npm に置いてみることにした。

https://github.com/Quramy/abacus-ts

何故か AWS の人から star もらえたけど何でだ。

結果だけでなくて、「どうやって作るか」を読み物として残したいけど、英語書くの手間やなぁ。こういうの「xx までにどこかに提出しろ！」という圧力が無いと絶対進まない。

## TypeScript

型パズルでのテストについて幾つか考えてみた。

下記はあると嬉しい機能。

- できれば何も出力したくない
- テストが失敗したときに、デバッグがしやすい

```ts
// テストしたい型作用素の例
type TargetType<T> = T extends string ? "hogE" : "fuga";
```

パターン 1: 雑に定数に打ち込んで確認する系.

値が必要になってる時点であまり嬉しくない。 雑に Playground とかで試すときとかに使うくらい。

```ts
const testWithString: TargetType<""> = "hoge";
const testWithNumber: TargetType<100> = "fuga";
```

パターン 2: interface の declaration merging を使う。

property 1 つがそれぞれテストケースに相当。 特に何も用意する必要が無いので手軽。 tsc のエラーメッセージにも actual と expected の双方が出るのでわかりやすい。

ただし、 actual と expected の prop 名を間違えると悲惨. 2 個目の interface でも property の補完効かない

```ts
interface TestTargetType1 {
  withString: TargetType<"">;
  withNumber: TargetType<100>;
}
interface TestTargetType1 {
  withString: "hoge";
  withNumber: "fuga";
}
```

パターン 3: interface extension で検証する

property 1 つがそれぞれテストケースに相当。 base となる interface と 型検査を行うための util type は用意する必要あり。

```ts
interface TestTargetType2 extends TypeTestSuite {
  withString: AssertIs<TargetType<"">, "hoge">;
  withNumber: AssertIs<TargetType<100>, "fuga">;
}

interface AssertSuccess {
  readonly resultOk: unique symbol;
}
type AssertFailure<A, B> = [actual: A, expected: B];
type TypeTestSuite = {
  [caseName: string]: AssertSuccess;
};
type AssertIs<A, B> = A extends B
  ? B extends A
    ? AssertSuccess
    : AssertFailure<A, B>
  : AssertFailure<A, B>;
```

## Misc

仕事で久々に生 JavaScript な React + Redux アプリケーションに触れた。
ここ最近はずっと TypeScript でのアプリケーションばかりだったので、Go to definition が使えない環境が久々過ぎて、エディタの感掴むのにちょっと時間がかかる。

---

# 3/3

## type-dungeon

直したいとこ:

- footer に問題もしくはレポジトリのリンクを設置
- Tuple Type でシンプルにできるとこを修正
- abacus の簡易版（減算・除算なしくらい？）の追加

## TypeScript

昨日考えた Type Assertion の仕組みを https://github.com/Quramy/type-assert-tool に上げて npm に公開した。

```ts
type TestSuite = {
  [caseName: string]: AssertSuccess | TypeTestSuite;
};
```

としておけば、

```ts
interface MyTest extends TestSuite {
  "parent section": {
    "nested section": {
      result: AssertIs<"hoge", "hoge">;
    };
  };
}
```

のように好きな単位で interface 中に description が書けるよな、ということに気づく。

abacus-ts のテストケースもこのパターンで書き直したので、可読性がちょっと向上した。

## Misc

https://github.com/aheckmann/greadme Markdown を Github flavor でローカル表示してくれる君。良い。

---

# 3/4

## TypeScript

```ts
console.clear();
```

で Playground の log がちゃんと消せる。
これ、Cmd + k でショートカットも使えるようになってた。

初学者向け研修の演習問題に頭を悩ませる。

難しい問題を作るよりも全然難しい。

## State of JS / CSS

GraphQL API でデータ叩けることを初めて知る。endpoint は http://api.stateofjs.com/graphql

```graphql
query GetLocaleData {
  survey(survey: state_of_js) {
    totals {
      year(year: 2020)
    }
    featuresData: features(ids: [nullish_coalescing, optional_chaining]) {
      id
      name
      experience {
        year(year: 2020) {
          total
          completion {
            total
            count
            percentage
          }
          buckets {
            id
            count
            countDelta
            percentage
            countDelta
          }
        }
      }
    }
  }
}
```

---

# 3/5

## TypeScript

引き続き初学者向けの演習問題を考える作業をやる。

https://gist.github.com/Quramy/3b84da57b048fd15315e46b8513c8676

Vim 以外にも Playground Plugin を色々活用することを思いつく。

- Prettier
- Link Shortener
- Present

## Misc

今週、ずっと Playground 触ってたな。。。

---

# 3/8

## reg

エゴサに引っかかっていたので、 https://speakerdeck.com/andpad/vrtyatutemasuka-reg-suitdesuka というスライドを見つける。

「regconfig.json の運用」という中々にマニアックな内容で、というかその契機になってるのが、 [去年末](202012.md#124) に見つけた下記の件だった。

> 社内の reg-suit 利用案件で「絶対に差分があるはずなのに passed になっちゃう！」という相談を受ける。
> マジかよ、と思いつつ手元で最新の reg-suit 使ってイチからやってみたら再現して冷や汗かいた。
>
> 完全には原因を究明できていないが、pixelmatch にわたす Threshold が undefined になってしまうと発動する。
> reg-cli の場合、undefined ではなく null 渡しするように CLI を書いていたので気づきにくい構造だった（というより null / undefined で挙動が変わるのもどうかと思うが）。
>
> reg-suit と img-diff-js 側双方に patch 当てる。

ほんっと申し訳ない気持ち。

## CoPL

abacus-ts に関数評価の機能を入れようと思い、CoPL 本を開き直す。

本の中で言う ML1 （`if x then a else b` が使えるやつ）について、普通に TypeScript で書いてみたところ、tokenize, parser, evaluator を 2 時間くらいで書くことができた。

abacus でやった、BNF -> 再起下降パーサー の流れが完全にマスターできてる感があって感動する。

```
expr   := cond | "if" expr "then" expr "else" expr
cond   := add("<" add)*
add    := mul("+" mul | "-" mul)*
mul    := prim("*" prim)*
prim   := "(" expr ")" | number | bool
number := "-"? nat;
nat    := "0" | "1" | "2" |  ...
bool   := "true" | "false"
```

---

# 3/9

## CoPL

昨日雑に書いた ML1 相当コードを少しキレイにする。

というか、tokenizer にて、下記のように書いてしまっていたため、 `"ifthenelse"` みたいなのが if, then, else の別々のトークンにされてしまっていたりしていたので、これも直す。

```ts
if (inputString.startsWith("else")) {
  tokens.push(ElseToken);
}
```

tokenizer にせよ、評価器にせよ、「何かにマッチしたら、マッチした情報を使って後続の処理をする」というコードが頻出するけど、やっぱり JavaScript の syntax だと書きにくさがある。

```ts
if (input.match(/^(\d+)/)) {
  // グループ参照の値を使った処理
}
```

ML2 ( `let` 式での変数束縛）の部分の実装をすすめる。下記のような構文。

```ocaml
let x = 100 in x * x;;
```

パーサ作成するとこまでは完全に慣れてきて、追加する構文に応じて、CoPL 本に載ってる BNF を見ながら、EBNF と生成規則を書き下して再起下降関数に落とすだけ。

束縛を考えると、その評価に基づく環境へのアクセスが必要になる。

```ocaml
* Root *                                  let x = 1 in
* Root <- env1 *                          let y = 2 in
* Root <- env1 <- env2 *                  let z = 3 in
* Root <- env1 <- env2 <- env3 *          let x = 4 in
* Root <- env1 <- env2 <- env3 <- env4 *  x + y + z;;
```

上記コードの最後の行の `x + y + z` という式が評価されるときの環境を `env4` とすると、次の要件が必要。

- `env4` において、識別子 `x` に束縛されている値は 4
- `env4` からも上位の `env1` や `env2` で束縛された値へアクセスできる

色々な実装方法があっただろうが、まずは Linked List 様なデータ構造で実現してみた。

```ts
interface Environment {
  get(identifier: IdentifierNode): RHS | undefined;
}

class RootEnvironment implements Environment {
  get(identifier: IdentifierNode) {
    return undefined;
  }
}

class ChildEnvironment implements Environment {
  constructor(
    private identifier: IdentifierNode,
    private value: RHS,
    private parent: Environment
  ) {}
  get(identifier: IdentifierNode) {
    if (this.identifier?.name === identifier.name) {
      return this.value;
    }
    return this.parent.get(identifier);
  }
}
```

現状の `let` 式が返す AST 上、各環境に束縛できる識別子と値のペアは 1 つのみなので、`identifier` と `value` は `ChildEnvironment` の prop でよい。
あと、後段で値として取りうるものが増えそう（関数式とか）なので、そこは `RHS` の型で吸収できるといいな、という期待がある。

評価器そのものはナイーブな再帰関数だったので、「それぞれの式を評価しているときに、その環境を参照させるか」はシンプルに再帰関数の引数に環境を追加するだけで実装完了。

```ts
function evaluateWithEnv(
  expression: ExpressionNode,
  env: Environment
): EvaluationResult {
  // ML1での評価部分
  if (expression.kind === "Identifier") {
    return env.get(expression);
  }
  if (expression.kind === "LetExpression") {
    const { identifier, binding, exp } = expression;

    // 今の環境に、新しい束縛を追加した環境を作る
    const boundValue = evaluateWithEnv(binding, env);
    const childEnv = new ChildEnvironment(identifier, boundValue, env);

    // 子環境をつかって、 `in` の後ろの式を評価する
    return evaluateWithEnv(exp, childEnv);
  }
}

export function evaluate(expression) {
  return evaluate(expression, new RootEnvironment());
}
```

## Node.js

標準入力から文字読んで〜、という系統の処理、意外と普段書かないので完全に忘れてた。

```js
process.stdin.resume();
process.stdin.setEncoding("utf8");

process.stdin.on("data", function (chunk) {
  const str = chunk.toString("utf-8").trim();
  console.log(str);
});
```

---

# 3/10

## CoPL

関数適用部分を作っていく。

ここに来てパーサーで躓く。

```ocaml
let f = fun x -> x + 1 in f 100;
```

`f 100` の部分について、「このトークンが来たら関数適用が確定する」という固定トークンが無い。

`f - 1` のようなケースもややこい。これは、

```js
const expression = {
  kind: "BinryExpression",
  op: "Sub",
  left: {
    kind: "Identifier",
    name: "f"
  },
  right: {
    kind: "NumberLiteral",
    value: 1
  }
};
```

であって、下記ではない。下記は `f (- 1)`

```js
const expression = {
  kind: "FunctionApplication",
  callee: {
    kind: "Identifier",
    name: "f"
  },
  argument: {
    kind: "UnaryExpression",
    op: "Minus",
    exp: {
      kind: "NumberLiteral",
      value: 1
    }
  }
};
```

この辺りで、 `-` の扱いが怪しいことに気づく。関数適用の話を抜きにしても、

```ocaml
1 - if true then 1 false 0
```

のような式を正しく parse できてなかった。

実装が間違っているというよりは、実装の元にしている EBNF を正しく書けていなかった、という状態。

## Lerna

4.0 が出てた。 https://github.com/lerna/lerna/blob/main/CHANGELOG.md#400-2021-02-10

## Relay

experimental が外れて、v11 として hooks API が正式にリリースされてた。 https://relay.dev/blog/2021/03/09/introducing-relay-hooks/

## Misc

久しぶりに Docker for mac を update したら GUI が使いやすくなってた。

---

# 3/11

## JavaScript

https://github.com/tc39/proposal-collection-normalization

## CoPL

もう一度 if 式と二項演算子の結合の強弱について考え直す。

```ocaml
(* A *)
if true then 0 else 1 + if true then 0 else 1
```

は ↓ と等価

```ocaml
(* B *)
if true then 0 else (1 + if true then 0 else 1)
```

if 式同士の加算であれば、下記。

```ocaml
(* if を + よりも優先したい場合は明示的にグルーピングが必要 *)
(* C *)
(if true then 0 else 1) + if true then 0 else 1
```

「 `if` よりも `+` が強く結合する」 というのがようやく腹落ちしてきた。何もしなければ、 (B) のパターンのようにグルーピングがなされるが、 (C) のように明示的にグルーピングを行うと、結合順序（＝構文木要素の順序関係）が逆転する。

(B) と (C) を眺めると、left と right で取りうるグルーピングの関係が違う、というところに思い当たる。
「left は明示的なグルーピングが必要」ということを想定したのだから、 `prim` しか取り柄ないが、right は (A) のように if 式を許容しなくてはならないので、`expr` を嵌めないといけない。

ということで、 if と加算からのみなる EBNF は以下のようになる。

```
expr    ::= addExpr | ifExpr
ifExpr  ::= "if" expr "then" expr "else" expr
addExpr ::= prim("+" expr | "-" expr)*
prim    ::= number | bool | "(" expr ")"
```

これで、ようやく昨日の

> ```ocaml
> 1 - if true then 1 false 0
> ```
>
> のような式を正しく parse できてなかった。

が解消された。パーサー直すだけで大分時間を費やしてしまったが、create tree 部分のテストコードが拡充されてきたのは嬉しい副作用。

一方で、単項の `-` 問題は以前解決できていない。

何となくだけど、

- tokenize
- create tree

を完全に分離している実装だとダメな気がする。構文木の構築中の状態（= 今どの parser にいるか）に応じてトークン化の処理の分岐が変わっていくパターンになっているのでは。

一旦、単項演算子 `-` の件はさておいて、関数適用の評価器を完成させる。CoPL 本、構文解析についてはあまり実装の参考にはならないが、評価規則については実装と同じレベルで記述されてるんだな、ということを改めて実感。

---

# 3/12

## Puppeteer

Storycap に来ていた renovate bot の CI 失敗にて。

puppeteer-core パッケージで Launch するときの `headless: true` みたいなオプション指定で tsc コケてる模様。

関係するとしたら、 https://github.com/puppeteer/puppeteer/pull/6888 の PR あたりか？

## reg

open という npm package の major update が来ていたので、その対応。とっくに npm 本体に d.ts が含まれていたのに、 `@types/open` を install していたので、削除したり。

## CoPL

再帰関数の関数適用部分を作成した。

```ocaml
let rec fact = fun n -> if n < 2 then 1 else n * fact (n - 1) in fact(3)
```

OCaml 本来の `let rec` 式は束縛する値に関数式以外も許容できるらしいが、CoPL 本では関数式に限定しているため、まずはそれに従う。

```
letRecExpr ::= "let" "rec" id "=" "fun" id "->" expr "in" expr
```

例として、上記の `fact` 関数の場合、評価時 (`fact 3`) に以下の環境が必要となる

- `fact` に `fun n -> if n < 2 then 1 else n * fact (n - 1)` のクロージャが束縛されていること
- `n` に `3` が束縛されていること

これは 関数式の本体部（`fact (n -1)` の部分）についても同様。

したがって、関数適用のノードを評価する際のステップは以下のようになる（太字部分が再起呼び出しで必要となる箇所）。

- ノードから `callee` を評価する
- **`callee` が再起クロージャの場合、以下の環境を用意する**
  - クロージャが持っている環境に対して、再起クロージャの名前で再起クロージャを束縛する
  - さらに、ノードの実引数を評価した値を束縛する
- `callee` が再起クロージャでない場合、以下の環境を用意する
  - クロージャが持っている環境に対して、ノードの実引数を評価した値を束縛する
- `callee` の本体式にすいて、用意した環境下での評価を実行する

上記の通り、「評価対象のクロージャが再起関数かどうか」を関数適用時に判別できなくてはならないため、 `let rec fact = fun n` に相当する let 式を評価するときに、通常の関数式からなるクロージャではなく、そのクロージャを拡張した「自身の名前を保持したクロージャ」を再起クロージャとして用意しておき、それを環境に束縛する必要がある。

ここまでで、CoPL 本の第 5 章の部分までの評価器を一通り作成できたことになる。一息つくには丁度良いタイミングなので、幾つかリファクタを実施した。

- GH actions, prettier
- 導出評価失敗時のメッセージ整形
- Class or plain object でブレていたので object に統一

次の章に進む前に、tokenizer と parser 周りをもう少し整理しておきたい。

- トークンの生成に generator 使えないかしら
- コンビネータにしてもうちょっと見通しよくしたい

## Node.js

```js
process.stdin.setRawMode(true);
```

---

# 3/14

## CoPL

パーサーコンビネータを利用する実装に変更していく作業。

ライブラリに頼らずにコンビネータを実装する上で役に立ったのは https://anatoo.hatenablog.com/entry/2015/04/26/220026 の記事。

書いてみて分かったが、本質的な部分は再起下降パーサーと何ら変わらない。違いとしては下記な感じ。

- ナイーブな再起下降パーサー: EBNF を手続き的に実装する
- パーサーコンビネータ: EBNF に対する宣言的な DSL を導入して表現する

```
prim    ::= id | number | bool | "(" expr ")"
id      ::= ...
number  ::= "0" | "1" | ...
bool    ::= "true" | "false"
```

上記部分の EBNF に対する実装が、コンビネータの導入で下記のようになった。

```ts
// before

const prim = () => {
  if (expect(tokens, "LeftParenthesis")) {
    consume(tokens, "LeftParenthesis");
    const node = expr();
    consume(tokens, "RightParenthesis");
    return node;
  }
  if (expect(tokens, "Boolean")) {
    return bool();
  }
  if (expect(tokens, "Number")) {
    return number();
  }
  if (expect(tokens, "Variable")) {
    return identifier();
  }
  console.error(tokens);
  throw new Error("invalid token");
};
```

```ts
// after

const prim: Parser<ExpressionNode> = oneOf(
  ref(() => group),
  ref(() => bool),
  ref(() => num),
  ref(() => id)
);

const group: Parser<ExpressionNode> = expects(
  [symbolToken("("), ref(() => expr), symbolToken(")")],
  ([lp, node, rp]) =>
    ({
      ...node,
      ...loc(lp, node, rp)
    } as ExpressionNode)
);
```

`oneOf` は「いずれか 1 つの parser で parse する」を実現するコンビネータ。引数の順序が優先度に直結する。

`expects` は「連続する Token や Node の parser をまとめて、新しくノードを生成する」コンビネータ。

他にも、左結合中置演算子のためのコンビネータ、なども作った。

実装しながら、なるほどと思ったのは、各パーサーの出力にトークンも構文木も両方を許容している、という部分。

よくよく考えると、すべてのノードには葉としてトークンをぶら下がっていると考えられるはずなので、何ら不思議は無いんだけど。
今まで、AST にふれるときに、完成された構文木しか見ていなかったので、あまりトークンについて意識していなかったせいかもしれない。

例えば、 `IdentifierNode` という識別子用のノードがあったとして、これは本来そのノードの直下に変数名を表すトークンがいるはず。
ただ、TypeScript などのパーサーは、最終的にはトークンを使わずに `IdentifierNode` を葉の要素として木を構築しているだけ、ということだ（トークンが持つ情報が、位置情報も含めて Node にあれば十分なので）。

この結果として、何日か前に下記のように書いた「完全分離」な実装から脱却された。

> 何となくだけど、
>
> - tokenize
> - create tree
>
> を完全に分離している実装だとダメな気がする。

結局 generator を使うようなことはなかったが、「入力文字列のレコードをスキャンしつつ、ちょっと読んでパースされる」という実装に落ち着いた。

```ts
interface Parser {
  (scanner: Scanner) => Node | Token;
}

interface Scanner {
  startsWith(text: string): boolean;
  match(text: string): boolean;
  consume(length: number): { pos: number, end: number };
}
```

こんな感じのインターフェイス。

最初は、下のような Pure Function な interface を考えていたんだけど、これだと現実的に面倒な点がいくつかあった。

```ts
interface Parser {
  (input: string, pos: number) => [result: Node | Token, nextPos: number];
}
```

1. このままだと空白の除去を各パーサー側で考慮する必要がある。trivia はトークンでないので、パーサーに意識させない構造にしたい
1. いちいちタプルで書くのがちょっと面倒（これはあまり重要じゃない）

ということで、`Scanner` class に状態を持たせる実装とした。空白除去は Scanner の各メソッド側で実現するようにしている。

もともとのパーサーの実装でも、各関数がトークン列に対して破壊的な変更を行うような実装であったし、これはまぁ良しとしよう。そこまで純粋性にこだわりないし。。

---

# 3/15

## CoPL

ちょっこり Evaluator 側のリファクタリング実施。 `Option` 的な感じの型を付けてみる。

parser 側に合わせて、Evaluator 側もファイルを分割。ただ、１つの関数にベタ書きされたままではあるので、見栄えはあまり良くない。まぁ別に実害ないし、これはいいか。

今日は 7 章のパターンマッチのところに着手。

下記のような、Cons List 構文や単純な match 式の評価を行えるようにした。

```ocaml
let rec ln = fun list ->
  match list with [] -> 0 | x::y -> 1 + ln y in
ln(1::2::3::[])
```

`::` 演算子で初めて右結合中置演算子が出てきたので、少し combinator の実装に戸惑う。

## Storycap

renovate の PR で error になってるものが溜まってきているので、幾つか対応する。

ついに puppeteer-core に本家の d.ts が入って、 `@types/puppeteer` を切れるようになった。ただ、LaunchOption まわりで、import すべき型が変わったようで、幾つか小さい compile error になっていた模様。

重い腰を上げたついでに、eslint-config-prettier や husky など major ver up 対応も一緒にやっつける。

---

# 3/16

## Misc

幾つか freee の API 叩く。developer 向けに最初からアカウント用意されてるのすごい。

---

# 3/17

## CoPL

型システムの章に着手、、、するも、これって 10 章までの内容をちゃんと把握してないと実装できないのでは？ということに気付く。
まずは 9 章で導入される多相型におけるパラメトリックな型システムの内容をちゃんと理解しないと。

## Node.js

とあるシステムで、 Node v10 -> v14 に上げる過程で、以下のコードで Node.js のプロセスが死ぬ問題に遭遇。

```js
const pino = require("pino");
log = pino({ level: "error" });

// Application code
log.info("hello");

process.on("unhandledRejection", e => {
  log.error("unhandledRejection", e);
});
```

直接的には https://github.com/pinojs/pino/issues/680 が原因で、pino 自体を最新化すれば解消する。

面倒だったのが、

- info ログを出力しようとする -> この段階で pino が Error を投げる
- `unhandledRejection` に到達する
- さらに `log.error` で pino が呼び出され、ここでエラーが発生する
- Node.js のプロセスが死ぬ

という構造になっており、 `console.error` などもなかったため、最初スタックトレースすらわからずに調査に苦労した。

先に、「 `unhandledRejection` , `uncaughtException` で何も表示されないこと」から logger に問題があることに気付くことができればなぁ、、という悔しみが若干ある。

## Storycap

「user agent 指定できなくない？」という tweet を見かけた。
確かに、、、とは思わないでもないが、よくよく考えると Puppeteer の user agent 指定したどころで、、、というのは正直あるような。

特に Storycap の場合、リクエストを送る対象が Storybook を serve している server 限定になるわけで、そこに対して UA を上書きする意義がどれくらいあるんだろう。。。？という気持ちもある。
Component 側で `navigator.userAgent` とかしちゃってる箇所があるのかなぁ。

---

# 3/18

## CoPL

9 章の let 多相の話を読み込む。

まずは言葉の定義をちゃんと噛み砕かねば。

- 型: `int` や `bool` , `bool list` のような具体的な型。
- 型環境: 束縛した変数と、その対象の型のペアの集合。値評価の際に導入した環境の型バージョン。
- 型スキーム: パラメトリックな型を表す。型そのものではなく、型の集合。 `'a. 'a -> 'a` のように書く。
- 型インスタンス: とある型スキームに対して、型パラメータに具体を代入した結果の型

```ocaml
fun x -> x (* これは 'a.'a -> 'a というスキーム を満たす型ならば何でもよい *)
```

`'a.'a -> 'a` はスキームであって、型ではない。一方で、 `'a -> 'a` は型。

TypeScript で書くのであれば、以下のようなイメージか。

```ts
type IdFunc<T> = (arg: T) => T; // これはスキーム

type NumIdFunc = IdFunc<number>; // こっちが型インスタンス
```

また、型, 型の集合, 型スキームに対する作用として FTV （何の略だろう。 Free Type Variables?）というものが出てきた。「対象の自由型パラメータの集合」を表す作用素。

- `FTV(0)` -> `[]`
- `FTV('a -> 'a)` -> `['a]`
- `FTV('a.'a -> 'a)` -> `[]`
- `FTV('a.'a -> 'b list)` -> `['b]`
- `FTV({ x: 'a.'a -> 'a, y: 'b })` -> `['b]`

特に、 `'a.'a -> 'a` の FTV が、 `['a]` ではなく空集合であることに注意。

FTV が何の略か知りたくて、TaPL の let 多相の節も開いてみたけど、やっぱりまだ自分には難しい。

## Node.js

npm の推移依存解決を強制するツール: https://github.com/rogeriochaves/npm-force-resolutions

README にも書いてあるが、気軽に使うようなものではなく、自身の package.json で dependencies を書き換えても推移依存が upgrade できないようなケースで、それでもなお強制的に推移的依存を上げたい場合にのみの利用が推奨されている。要するに脆弱性見つかったとき。

## Web Serial API

https://wicg.github.io/serial/

シリアルポートを持つデバイスに web からアクセスするための仕様。

WebBluetooth](https://webbluetoothcg.github.io/web-bluetooth/) や [WebUSB](https://wicg.github.io/webusb/) と重複してしまいそうなものだが、 https://github.com/WICG/serial/blob/gh-pages/EXPLAINER.md にシリアルポートデバイスを直接扱う意義が書いてあった。

> 1. すべてのシリアルデバイスが Bluetooth または USB デバイスであるとは限りません。一部のプラットフォームには、DE-9 コネクタ（ほとんどの PC プラットフォーム）またはシステムボード上のヘッダー（Raspberry Pi など）としてシリアルインターフェイスを提供する UART が組み込まれています。
> 1. ほとんどのオペレーティングシステムでは、利用可能な最高レベルの API を使用してデバイスと対話するために、アプリケーション（ユーザーエージェントを含む）が必要です。たとえば、USB デバイスが標準の USB CDC-ACM インターフェイスクラスを実装している場合、組み込みのクラスドライバーはそのインターフェイスを要求し、仮想シリアルポートインターフェイスを提供します。USB インターフェースが要求されているため、WebUSBAPI の実装は代わりにそれを要求できません。デバイスには、システムのシリアルポート API を介してアクセスする必要があります。

うーん、まぁ使う機会は中々訪れないだろうなぁ。。。

## CSS

```css
.clip-cotainer {
  overflow: clip;
  max-height: var(--container-height);
}
```

```html
<div class="clip-container">
  <!-- large contents -->
</div>
```

上記のように `clip` という値を `overflow` に書けることを初めて知る。 きっかけは caniuse に来ていた PR。Chrome 90 で実装されたからだろう（Firefox では 81 から利用可能だった）。

https://drafts.csswg.org/css-overflow-3/#overflow-properties

（現状は、 CSS Overflow Module というモジュールで議論されていて、 `text-overflow: elipsis` のような文字の切り落としもこのモジュールで仕様化される流れらしい）

`overflow: hidden` はスクロールバーを隠すが、Formatting Context の生成はされてしまっている。実際、JavaScript で `scrollY` 値をイジることはできる。
一方で、 `overflow: clip` の場合は、Formatting Context の開始を許容しない。また、切り取られ方についても、`hidden` は Padding Box を境界とするが、 `clip` の場合は `overflow-clip-margin` プロパティで挙動の調整ができる（デフォ値は `padding-box`）。

大概のケースにおいて、 `hidden` ではなく `clip` を使うのが今後の正解になりそうな気配ではある。

ただ、webkit の issue を見るとあんまり乗り気ではなさそう。。。

https://bugs.webkit.org/show_bug.cgi?id=198230#c3

## Misc

「自分しか知らないことを増やす」時間と「自分しか知らないことを他の人にも理解してもらえるようにする」時間のバランスが難しい。
前者を捨てるつもりは無いが、それは最終的に自分の首が締まっていく。
後者ばかりやっていても、育成自体にモチベーションがすごくあるわけではないし
