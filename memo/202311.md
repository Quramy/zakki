# 11/1

## Panda CSS

以前から少し気になっていた Panda CSS 調べてみた。

### Getting Started

基本的な書き味は以下のようになる。Tagged Template Literal ではなく、Style Props ライクなオブジェクトで記述していく類。
CSS Property を camel にする程度の違いであるので、Tailwind CSS よりは馴染みやすいというのが第一印象。

```tsx
import { css } from "../../styled-system/css";

export default function Home() {
  return (
    <main
      className={css({
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        minHeight: "100dvh",
        gap: 16,
      })}
    >
      <h1 className={css({ fontSize: 48, fontWeight: 600 })}>Hello Panda</h1>
      <p className={css({ fontSize: 32, fontWeight: 600 })}>Styling example</p>
    </main>
  );
}
```

例えば、以下の行に着目すると、

```tsx
<h1 className={css({ fontSize: 48, fontWeight: 600 })}>Hello Panda</h1>
```

上記の JSX 部分は、最終的に次の DOM に展開される。

```html
<h1 class="fs_48 font_600">Hello Panda</h1>
```

`fs_48` や `font_600` の部分は Tailwind と同じような、Utility First な CSS Class であり、Panda CSS は Utility 部分を CSS Layer として出力する。

以下が Panda が上記の Home Component から出力した CSS Layer:

```css
@layer utilities {
  .gap_16 {
    gap: var(--spacing-16);
  }

  .d_flex {
    display: flex;
  }

  .items_center {
    align-items: center;
  }

  .justify_center {
    justify-content: center;
  }

  .flex_column {
    flex-direction: column;
  }

  .min-h_100dvh {
    min-height: 100dvh;
  }

  .mt_16 {
    margin-top: var(--spacing-16);
  }

  .fs_48px {
    font-size: 48px;
  }

  .fs_32px {
    font-size: 32px;
  }

  .font_bold {
    font-weight: var(--font-weights-bold);
  }

  .fs_48 {
    font-size: 48px;
  }

  .fs_32 {
    font-size: 32px;
  }

  .font_600 {
    font-weight: 600;
  }
}
```

複数のタグで `fontWeight: 600` と記載しているが、Utility Layer 上は単一のセレクタである `.font_600` でしか無いので、格段に CSS の量が削減される、というのは Tailwind と同じ理屈。

Panda CSS の肝は、`css({ fontSize: 48, fontWeight: 600 })` のような部分から、実際にアプリケーションで必要となる最小の Utility Selector のセットを抽出する部分となる。

### Ahead of Time v.s. Just in Time

Panda CSS の Docs にもある通り、Next.js と組み合わせる文脈においては、PostCSS Plugin を利用することになる。
ビルドに関係するのが `postcss.config.cjs` に記述するプラグインの設定のみという点について、かなり違和感を覚えた。

```js
module.exports = {
  plugins: {
    "@pandacss/dev/postcss": {},
  },
};
```

Next.js に限らず、React のアプリケーションにおいて CSS in JS を Ahead of Time に実現するのであれば、それは.jsx や.tsx ファイルを処理するトランスパイラであったり、それらトランスパイラと接合する webpack-loader のレイヤの仕事になるはずで、.css ファイルを process するのが責務である PostCSS 単独で JSX をハンドルできるというのが直感に反している。

実際に動かしてみて気づいたが、Panda CSS は.js のバンドル作成という意味においては、以下の JSX を何一つ書き換えない。

```jsx
import { css } from "../../styled-system/css";

export const Hoge = () => <div className={css({ fontWeight: 600 })} />;
```

`css` 関数は build された結果に残り続けるし、SC であっても CC であっても、バンドルの結果に残り続ける。基本的に Object から Utility Class Name を決定するだけの関数であるため、実行箇所(ブラウザ or Node.js or エッジ) を問わないし、サーバー用とクライアント用でバンドルが別れても問題はない作りになっている。
上記のようなパターンであれば、AoT で Utility Class に変換することは論理的に可能なので、てっきりそういうビルドだと思いこんでいたのだけど、この意味においては Panda CSS は "not zero runtime" である。

[When not to use Panda?](https://panda-css.com/docs/overview/why-panda#when-not-to-use-panda) に以下のように書いてあるので、自分が勝手に誤解していた、というだけの話ではあるが。

> You're looking for an absolute zero JS solution.

### Code Reading

一方で、「.tsx なり.jsx なりを parse しないと Utility Layer の最小化はできっこない」という疑問は相変わらず解決されておらず、ここはここで気になって仕方がないため、ここから先は Panda CSS のコードリーディング.

Panda CSS の主たるパッケージの依存関係はおよそ以下のようになっていた。

```mermaid
flowchart LR;
    postcss --> node;
    node --> parser;
    node --> extractor;
    node --> core;
    parser --> extractor;
```

名前を見た瞬間に察しがついたし、extractor や parser の依存に ts-morph がいることからも明白だけど、PostCSS Plugin を起点にして、ts-morph を通じて tsx や jsx(他にも Vue.js のファイルとかも)を静的解析して、extract している。

`<div className={css({ fontWeight: 600 })} />` のようなパターンがどう処理されているのかを追えるのは、以下のテストコード部分。

https://github.com/chakra-ui/panda/blob/b840e4694f8d5f3adf64e9bd1a8891bce13b6243/packages/extractor/__tests__/extract.test.ts#L5111-L5182

`extractor` package がコード抽出の本体部分ではあるが、ts-morph(要するに TypeScript Compiler API が提供する `ts.Node` 形式) の AST をそのまま扱うのではなく、Panda CSS で独自に定義し直した node に `extractor` package で変換している模様。

https://github.com/chakra-ui/panda/blob/main/packages/extractor/src/types.ts

Extract された node 情報が Parser に渡されていて、その結果を core package の optimizer で Utilize する流れ。

X にポストしながら Working Out Loud 気味にコードリーディングしていたら、Panda CSS の開発者である @astahmer_dev に補足されたのか、Panda CSS CLI の flowchart を教えてもらった。

https://twitter.com/astahmer_dev/status/1674438685406765056

### Build Performance

Panda CSS の 動作の流れを追うと、webpack や Turbopack, Vite, esbuild のようなバンドラレイヤとは完全に切り離された実装(おそらく意図的な設計) であることに気づく。
extract した CSS を optimize する処理にしても、おそらく webpack の Plugin として作ってしまえば、もっと少ないコード量で実現できた可能性があるが、そうはしていない。
これは Turbo や Vite に置き換えても同じ話が成り立つのだろう。

裏を返すと、Meta Framework が用意しているチューニングされた build プロセスとは別の処理として Panda が動いているということを意味している。
Next.js の文脈で書くのであれば、webpack だろうと `--turbo` だろうと、Panda は独立した機構で CSS を emit することになるし、Production ビルド時においても、swc の parser とは別に Panda CSS は tsx を parse することになる。

次世代のバンドラの生き残りがどうなるかわからない時世としては正しい戦略であるとは思うけど、一方で build performance を求めるのであれば、最適解ではないのだろうな。

---

# 11/2

## Ark UI

Chakra UI family ということで、 https://ark-ui.com を少し触ってみる。

https://www.adebayosegun.com/blog/chakra-panda-ark-whats-the-plan#recommendations を読むと、Chakura v3 は依然 Emotion 依存のままだが、さらにその次のメジャーバージョンアップでは内部構成を Panda CSS + Ark UI に差し替える可能性について示唆されているため。

とはいえ、Next.js で Ark UI を import してみたものの、SC からでは import することすら難しかった。
