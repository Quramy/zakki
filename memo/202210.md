# 10/1

## Web Assembly

https://webassembly.github.io/spec/core

2.0 の仕様草案になっているの、全然知らなかった。

## Misc

https://lp.nijibox.jp/cp/postdev に登壇した。

Frontend のテストがどう変遷してきたのかを中心に twada さんと対談する。

楽屋で、探索的テストや Mutation テストの話も伺ったので、そちらの内容もまとめたみがある。

---

# 10/4

## Apollo Client

しれっと v3.7.0 が出ていた。結局、あまり RC から変わってなさげな雰囲気。

https://github.com/apollographql/apollo-client/blob/HEAD/CHANGELOG.md#Apollo-Client-370-2022-09-30

---

# 10/5

## GraphQL

https://speakerdeck.com/quramy/esm に書いた、apollo link 剥がしをおしごとの案件で適用した。

WHATWG fetch ベースで executor を実装する場合、シンプルに https://www.the-guild.dev/graphql/tools/docs/remote-schemas に書いてある以下をやるだけ。

```ts
import { fetch } from "@whatwg-node/fetch";
import { print } from "graphql";
import { introspectSchema, wrapSchema } from "@graphql-tools/wrap";
import { AsyncExecutor } from "@graphql-tools/utils";

const executor: AsyncExecutor = async ({ document, variables }) => {
  const query = print(document);
  const fetchResult = await fetch("http://example.com/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ query, variables })
  });
  return fetchResult.json();
};

export default async () => {
  const schema = wrapSchema({
    schema: await introspectSchema(executor),
    executor
  });
  return schema;
};
```

## Misc

Rails アプリケーションの Memory Usage 最適化について。

https://tech.medpeer.co.jp/entry/2022/02/01/113000

https://github.com/jemalloc/jemalloc

https://github.com/nodejs/node/issues/21973

---

# 10/11

## graphql-ruby

resolvers をいつ、どのような目的で使うべきなのかがまだ自分の中で整理できていない。

types は SDL に対する DSL にとどめておき、実際の解決ロジックを resolvers に書く、とかができる?

## GraphQL

おしごとの関係で、以下のような Schema, Operation に対してアプリケーションが特定の条件下でぶっ壊れる、という問題があった。

```graphql
interface Node {
  id: ID!
  url: String!
}

type Issue implements Node {
  issueNumber: Int!
}

type PullRequest implements Node {
  description: String
}

type Query {
  find(id: ID!): Node!
}
```

```graphql
query SearchQuery {
  find(id: "hoge") {
    url
  }
}
```

Apollo 系の Code Generator (非 JS) の話だったのだが、workaround としては以下のように Inline Fragment Spread にバラすしかない、という状況。

```graphql
query SearchQuery {
  find(id: "hoge") {
    ... on Issue {
      url
    }
    ... on PullRequest {
      url
    }
  }
}
```

これをチェックするには、 「Query Type の `find` フィールドの ReturnType が Interface かどうか」を判定する必要がある。

構造的には、ts-graphql-plugin の typegen でやっていた https://speakerdeck.com/quramy/diy-graphql-codegen?slide=27 と同じ話で実現できそうではあるものの、もうちょっとスマートに書く方法ないのだろうか。

別の文脈で graphql-js を生で触っていて思ったのだけど、「今着目しているフィールドの ReturnType 」とか、まんま Field Resolveer の `ResolvedInfo` に入ってくる情報なのよな。

`variableValues` とかだけが不要(というか、AST だけで見るので確定し得ない)のだけど、Client Schema と Document AST と graphql-js から提供される visit よりは high level なユーティリティで解決できないんだろうか。

ちょっと調べた感じ、 https://graphql.org/graphql-js/utilities/#typeinfo が完全に欲しい物であった。

---

# 10/12

## Vim

`:term` を調べる度に https://knowledge.sakura.ad.jp/23018/#i-3 のページに行き着いている気がする。

「今開いているファイルだけを jest で回したい」っていうのが割とあるが、専用の command 用意するほどでもないなぁ、と思っていたが、以下を手癖にしちゃうのが良さそう。

```vim
:bo terminal npx jest %
```

## GraphQL

少し前からちゃんと理解したいなと思いながら棚上げにしていた、GraphQL の Resolver 周りについて、graphql-js + jest だけで手を動かしていくだけの説明資料を作成。

https://github.com/Quramy/learn-gql-resolver
