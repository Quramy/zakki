# 10/1

## Web Assembly

https://webassembly.github.io/spec/core

2.0 の仕様草案になっているの、全然知らなかった。

## Misc

https://lp.nijibox.jp/cp/postdev に登壇した。

Frontend のテストがどう変遷してきたのかを中心に twada さんと対談する。

楽屋で、探索的テストや Mutation テストの話も伺ったので、そちらの内容もまとめたみがある。

---

# 10/4

## Apollo Client

しれっと v3.7.0 が出ていた。結局、あまり RC から変わってなさげな雰囲気。

https://github.com/apollographql/apollo-client/blob/HEAD/CHANGELOG.md#Apollo-Client-370-2022-09-30

---

# 10/5

## GraphQL

https://speakerdeck.com/quramy/esm に書いた、apollo link 剥がしをおしごとの案件で適用した。

WHATWG fetch ベースで executor を実装する場合、シンプルに https://www.the-guild.dev/graphql/tools/docs/remote-schemas に書いてある以下をやるだけ。

```ts
import { fetch } from "@whatwg-node/fetch";
import { print } from "graphql";
import { introspectSchema, wrapSchema } from "@graphql-tools/wrap";
import { AsyncExecutor } from "@graphql-tools/utils";

const executor: AsyncExecutor = async ({ document, variables }) => {
  const query = print(document);
  const fetchResult = await fetch("http://example.com/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ query, variables })
  });
  return fetchResult.json();
};

export default async () => {
  const schema = wrapSchema({
    schema: await introspectSchema(executor),
    executor
  });
  return schema;
};
```

## Misc

Rails アプリケーションの Memory Usage 最適化について。

https://tech.medpeer.co.jp/entry/2022/02/01/113000

https://github.com/jemalloc/jemalloc

https://github.com/nodejs/node/issues/21973

---

# 10/11

## graphql-ruby

resolvers をいつ、どのような目的で使うべきなのかがまだ自分の中で整理できていない。

types は SDL に対する DSL にとどめておき、実際の解決ロジックを resolvers に書く、とかができる?

## GraphQL

おしごとの関係で、以下のような Schema, Operation に対してアプリケーションが特定の条件下でぶっ壊れる、という問題があった。

```graphql
interface Node {
  id: ID!
  url: String!
}

type Issue implements Node {
  issueNumber: Int!
}

type PullRequest implements Node {
  description: String
}

type Query {
  find(id: ID!): Node!
}
```

```graphql
query SearchQuery {
  find(id: "hoge") {
    url
  }
}
```

Apollo 系の Code Generator (非 JS) の話だったのだが、workaround としては以下のように Inline Fragment Spread にバラすしかない、という状況。

```graphql
query SearchQuery {
  find(id: "hoge") {
    ... on Issue {
      url
    }
    ... on PullRequest {
      url
    }
  }
}
```

これをチェックするには、 「Query Type の `find` フィールドの ReturnType が Interface かどうか」を判定する必要がある。

構造的には、ts-graphql-plugin の typegen でやっていた https://speakerdeck.com/quramy/diy-graphql-codegen?slide=27 と同じ話で実現できそうではあるものの、もうちょっとスマートに書く方法ないのだろうか。

別の文脈で graphql-js を生で触っていて思ったのだけど、「今着目しているフィールドの ReturnType 」とか、まんま Field Resolveer の `ResolvedInfo` に入ってくる情報なのよな。

`variableValues` とかだけが不要(というか、AST だけで見るので確定し得ない)のだけど、Client Schema と Document AST と graphql-js から提供される visit よりは high level なユーティリティで解決できないんだろうか。

ちょっと調べた感じ、 https://graphql.org/graphql-js/utilities/#typeinfo が完全に欲しい物であった。

---

# 10/12

## Vim

`:term` を調べる度に https://knowledge.sakura.ad.jp/23018/#i-3 のページに行き着いている気がする。

「今開いているファイルだけを jest で回したい」っていうのが割とあるが、専用の command 用意するほどでもないなぁ、と思っていたが、以下を手癖にしちゃうのが良さそう。

```vim
:bo terminal npx jest %
```

## GraphQL

少し前からちゃんと理解したいなと思いながら棚上げにしていた、GraphQL の Resolver 周りについて、graphql-js + jest だけで手を動かしていくだけの説明資料を作成。

https://github.com/Quramy/learn-gql-resolver

---

# 10/13

## RSpec

https://relishapp.com/rspec/rspec-core/v/3-11/docs/helper-methods/let-and-let

> Note that let is lazy-evaluated: it is not evaluated until the first time
> the method it defines is invoked. You can use let! to force the method's
> invocation before each example.

`let` は基本的に遅延評価になる、すなわち、以下の例であれば `expect(x)` で評価されてはじめて block が実行される

```ruby
RSpec.describe "something" do
  let(:x) { 1 }
  it "hogehoge" do
    expect(x).to eq(1)
  end
end
```

また、Example 毎に呼び出しが Memoize されているため、以下のような書き方は問題がない。

```ruby
RSpec.describe "something" do
  let(:x) { rand }
  it "hogehoge" do
    expect(x).to eq(x)
  end
end
```

書き味だけでいうのであれば、jest の以下と似ているが、JavaScript の `let` は(当然だが)、その Statement が解釈された瞬間に RSH の値が束縛されるので、意味がまるで違うことになる。

```ts
describe("something", () => {
  let x = 1;
  it("hogehoge", () => {
    expect(x).toBe(1);
  });
});
```

即時束縛なのであれば、 RSpec 側では `let!` だと考えた方がいい。

```ruby
RSpec.describe "something" do
  let!(:x) { 1 }
  it "hogehoge" do
    expect(x).to eq(1)
  end
end
```

## Node.js

https://nodejs.org/api/test.html を初めて利用した。

---

# 10/14

## Misc

[TypeScript による GraphQL バックエンド開発 ─ TypeScript の型システムとデータフローに着目した宣言的プログラミング](https://techplay.jp/event/873259) を観戦した。

https://speakerdeck.com/naoya/typescript-niyoru-graphql-batukuendokai-fa-75b3dab7-90a8-4169-a4dc-d1e7410b9dbd

- 一休では GraphQL に CQRS を採用している
  - DDD における集約と Query の相性が悪い <- ???
  - 大半は DB の写像的な
- ドメインモデルを状態遷移図で考える
  - 「モデル」は DB の Record だけではない
  - 「ユーザーが入力した」から、状態遷移は開始されている(まだ所謂 DB と完結する model はまだなくとも)
- 関数型がやりたい、がモチベーションではなく、「FE と BE の設計や実装ギャップを減らしたい」が目的。
  - (F#などではなく) TypeScript を採用している理由もそこ

以下、感想

- 「TypeScript による関数型パラダイムなバックエンド開発」の話であった
  - もっと GraphQL と絡んだ話も聞きたかった (Relay 使っている会社は貴重だし)
- DB などの非同期 IO にどう対処しているのかの答えが聞けた (`neverthrow` にヘルパがあった) のはよかった
  - というか、大半 neverthrow というライブラリの使い心地次第で開発体験の良し悪しが変わってきそう？という気がする
  - rx 触ってたときに、パイプラインの前後で型推論が上手く効かないケースも割とあって(とくに `filter` とか) 、TypeScript の言語標準の機能よりも劣後していそうな箇所が生まれたり、など
- Prisma ベタ褒めにはちょっと違和感あったけど、IO 含めた Integration test はあまりやらずに、DI で別のものを刺してテストしている、とのことだったので自分とは温度感が違うのかも
  - 最近 RSpec と jest を行き来して見ていることが多めだけど、自分はなるべく RSpec と同じように jest が書けるようにしておきたい、というマインドが強めなので、jest / prisma 側に FactoryBot が欲しい、、、のような欲求が出てきている

---

# 10/18

## Rails

Active Support で下記のような日付計算ができてしまえてビビる。

```ruby
Time.now + 1.hours
```

---

# 10/20

## Node.js

https://nodejs.org/en/blog/announcements/v19-release-announce

- `--watch` オプションの追加
- WebCrypto 安定版の提供開始
- Keep Alive が `createServer` のデフォルトに

あたりか。
