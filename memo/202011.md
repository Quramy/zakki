# 11/2

## ts-graphql-plugin

https://github.com/Originate/eslint-plugin-ts-graphql

クエリに合わせた型定義を自動でやってくれる ESLint rule + auto fixer.
自分の作った OSS の上で他の人が色々やってくれるのを見るとホントに気分がいいなぁ。嬉しくなる。

## Storycap

サンプルの script 起動するための ts-node のオプションに transpileOnly 追加

## reg

久々に手元で reg-cli 回したら結構 diff 取るのに時間掛かってる。
worker thread 系の何か試せたりするだろうか？

## 英語

先週、dulicate を「ダプリケイト」って発音してる人がいて、（その場で特に指摘はしなかったんだけど）自分の記憶が疑わしくなってので撥音調べる。

deprecate と duplicate ってアクセントが全然違うのね。

## Misc

このメモも 3 ヶ月目かー。まぁそこそこに続いてるかな？

---

# 11/4

## TypeScript

https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-rc/

4.1 の RC が release されたので、軽くまとめを書く。一旦このレポジトリで markdown としてまとめ書いたけど、会社の Slack に流しておしまい。

## 英語

たまーにメールで「〇〇について discussion しないかい？」ってライトなノリなやつが来ることあるけど、リアクションに困る。
自分が認知してない相手からであればほぼ 100%で無視するけど、年に 1 回程度で「あー、これは気になる」っていうのが来るんだよな。。。
（今回は "things about general GraphQL" だった。元 Meteor の中の人）

1 on 1 で call するのに踏み出せなくて、「Slack とかがいいんだけど」って返さざるを得ないのが悲しい。

## Next.js

`Cache-Control: public, max-age=0` が public dir の asset に付与されてるんだけど、だれがどこで setHeader してんのかわからん。。。

## Misc

Google で「大統領選挙」で調べたときに出てくる開票速報がリロードされなくても画面更新されてたので、「何使ってるんだろ？」って思って devtool 開いてみたら、JSONP っぽい XHR を polling している風だった。

久々過ぎて毎回忘れるシリーズ:

- Android ADV からみた Host PC の address が 10.0.0.2 であること
- Dockerfile と Docker Compose Config YAML の書き方
- envsubst コマンドの存在

---

# 11/5

## reg

PHP Conference で reg-suit の話があるみたい。もしかしたら Storycap も？

https://fortee.jp/phpcon-2020/proposal/d6d95063-67d7-416f-b480-7c12ceb69038

## Next.js

ひさびさに `pages/posts/[post_id].tsx` 的な path parametric な Component を作ろうとしたら、Next Link が CSR で Dynamic Routing されなくてドハマリする。

原因は何のことはなくて、下記のように書いてたんだけど、

```html
<Link href={`/posts/${postId}`><a>りんく</a></Link>
```

正しくはこうだったのをすっかり忘れてた。

```html
<Link href="/posts/[post_id]" as=`/posts/${postId}`><a>りんく</a></Link>
```

しかも v9.5.4 でわざわざこの書き方する必要なくなったらしい。

---

# 11/6

## Vim

vim9script というのがあるのか。。。

- https://zenn.dev/mattn/articles/9c670e5ec661becb4d88
- https://github.com/vim-jp/issues/issues/1332

ちゃんと読んでないけど、AST に parse できるように構文を変えてるらしい。

旧来の Vim script の場合、下記のような部分が、runtime semantics に頼らないと決定できないのが問題。

```vim
echo hello.world
```

- `hello` というディクショナリの `world` という値
- `hello` という文字列と `world` という文字列の結合

のどっちなのか、判断できないため、compile しようがなく、都度 interpret するしかない。

自分の.vimrc あたりから書き換えてみるか、、、と思わないでもないが、そもそも.vimrc に負債というか秘伝のタレ化していて、言語イジるよりも前にやらなきゃいけないことが色々ある気がする。
いらん plugin の install やめたりとか、NeoBundle 切るとか。

## Next.js

`next/image` の話を社内のフロントエンド共有会で聞いた。

- `render/renderToString()` のタイミングで、 `<Image>` の src/srcsets 属性が書き換わる。query string に width を付与したり、CDN 向けの URL を生成したりなど。
  - どういう src にするかは next.config で制御できる。デフォルトは next server へのリクエストになるだけ。
- ブラウザから書き換えられた src のリクエストを Next.js server が受け付けた場合、optimize 処理を行った buffer を返却する
  - optimizer は https://github.com/lovell/sharp が使われる
  - PNG -> webp のような codec の変換は現状行われない。開発者が指定した拡張子の形式がそのまま利用されるだけ
- SSG かつ default loader の場合、next server がいないので何も行われないのと一緒。
  - imgix とか cloudinary の CDN に任せないとダメ

## GraphQL

Apollo Day というイベントが 11/10 に開催されるらしいので、とりあえず申し込みだけした。

https://events097286.typeform.com/to/X9BF8MNs

JST だと 11/11 午前 0 時開始っぽい。

## Rust のお勉強

大分日が空いてしまった。

「実践 Rust 入門」の 4 章のとこから。

primitive 型の復習。

- 精度の違う数値を混合して扱うことはできない。 i32 で定義された値と u8 で定義された値を足し算する、 とかはだめ。

触ってて気になったんだけど、main.rs じゃないとこで、 `fn foo() { }` みたいなの書いても rls のチェックが効かない？ Vim の quickrun では実行できちゃうんだけど...
main.rs に `pub mod foo;` とか書けばチェック効くようになるんだけど、そういうものなのか？

関数ポインタと関数定義型が出てきた。下の 2 つは意味が違うとのこと。

```rust
let f = someFn;
let f: fn(i32) -> i32 = someFn;
```

前者の `f` は関数定義型だけど、後者は関数ポインタ。どっちも `f(100)` みたいに呼び出せる。
呼び出せる、という意味だとクロージャも似てる。
実際、クロージャを要求するところに関数ポインタを渡すこともできる（それはそうだよな、関数自体も環境に何も束縛がないクロージャとしてみなせるので）。
逆に、クロージャを関数ポインタとして扱うことも限定的にできる（これも、そのクロージャが環境束縛が無いときだけ）。
そう考えると、コールバックを受け取る関数を提供するケースでは、引数にはクロージャを構えておくのがよい、ってことになるんかな。
この辺は実際のライブラリとかをちゃんと触ってみないと肌感わからんな。。。

## TypeScript

Halloween ネタで Type | Treat ってのをやってたのを知った。

https://dev.to/typescript/the-typescript-team-presents-type-treat-1c35

## Misc

Storybook で Rendering Performance 取る Addon。試してはいない。 https://github.com/atlassian-labs/storybook-addon-performanc://github.com/atlassian-labs/storybook-addon-performance

typescript-eslint-language-service が速い！って褒めて貰えた。嬉しい。 https://github.com/Quramy/typescript-eslint-language-service/issues/32#issuecomment-719080315

---

# 11/9

## Storycap

Storybook v6 での addon の configure や parameter 指定について、Storycap の README に書いてなかったので、v6-managed の e2e 書きがてら、README も書き換える。

## Rust のお勉強

「実践 Rust 入門」の 5 章。ユーザー定義型。

他でも聞きかじったことのある内容の復習、って感じではある。

`'static str` （文字列リテラル）と、 `&str` （文字列スライス）と、`String` （文字列型）が区別されてるのはちゃんと意識して置かないとなー。
「配列とスライスと Vec の関係と似てる」という説明は得心がいった。

本とは関係がないんだけど、rls でどうにも補完が全然効かない（そのスコープで利用可能な変数は保管されるけど、例えば `String::` とタイプしても `from` とか出てこない）という件、rust-analyzer に乗り換えたら大分改善された。
利用可能なマクロも表示されるようになったし、これはかなり DX が上がった感。

https://rust-analyzer.github.io/

ありがたかったので、Open Collective で donation しておいた。

## Blog 生成

このレポジトリの markdown を HTML に吐き出す、というのに手を付け出す。

JAMStack でいいし、Gatsby.js とかでやるのが早いんだろうけど、折角ちまちま Rust やってるわけだし、ここは Rust で吐き出すようにしたい。

https://github.com/raphlinus/pulldown-cmark や glob, 標準の fs モジュールを触りだしてみる。

「`*.md` を引っ張って、html を吐く」というのはさして問題がなく書けるんだけど、メニューや記事同士のリンクのことを考えると、画面側の要件（というかデザイン）決めてからじゃないと、内部で使う struct のフィールド一つとっても決めにくい。
このまま、このファイルをただ HTML にしたとしても、H1 に日付がくるだけになってしまうけど、リンク作ること考えると、「11/9 Rust のお勉強 / Blog 生成」みたいな感じになってて欲しくて、これをやるには markdown を parse しつつ、H1 や H2 の情報をかっさらってきて struct につめる、というのも必要。

一旦 figma か何かでカンプ起こしてからプログラム書くようにした方がいいんだろうなー。

---

# 11/10

## typescript-eslint-language-service

TypeScript ESLint の 4.1 対応が終わってる模様。 https://github.com/typescript-eslint/typescript-eslint/releases/tag/v4.7.0

@typescript-eslint/estree に String Literal Types の対応入ってるから、 `ts.TemplateLiteralTypeNode` が Compile 通らなくなるのか。
11/17 に 4.1 出るし、そのときに取り込むか。

## Blog 生成

Figma 立ち上げてデザイン切り出してみる。
考えれば考えるほど、余分な機能いらない気持ちになってきた。

- タグ: 「自分で見返す」という目的であれば、そもそもレポジトリで grep するか GitHub 上で検索した方が早い。「特定のタグで絞って記事の一覧を表示する」というユースケースが殆どいらない。どうせ流入的には Referral, Organic Search が大半だろうから、indexing されるようにだけ気を付けておけば十分だろ。。。SSG でやるの面倒だし。
- リンク + OGP の embed: 自分が既にあげてる Medium の記事で Twitter や GitHub issue を embed で表示しているところがあってので、「コンテンツ中のリンクから OGP 引っ張ってきて表示したら格好いいかも？」とか思ったけど、逆にうるさくなりそう。やるとしても、「ここは embed で」と選択的に出来ないとだめ。Markdown ってそういう拡張できるのかな。

Figma でサイトヘッダ部分を描く段になって、サイトのタイトル全然決まってないのに思い当たる。現状で思いついた原案「Quramy | tail」だけど、もう少し考えるか。

## Rust のお勉強

「実践 Rust 入門」の 7 章。所有権関連の章。鬼門感ある。

> 自分の型を定義した際に Copy トレイトを実装できる要件が揃っているなら、一般的には Copy トレイトを実装することが推奨されます。

なるほど。

ついでに https://doc.rust-lang.org/std/marker/trait.Copy.html#when-cant-my-type-be-copy も目を通してみた。

heap を管理しなきゃいけないようなコンテナ系（Vec とか String とか）が Copy できない、というのは String 自身の `len` や `capacity` （こいつらはスタックにいる）と heap のアドレスをコピーしちゃうと、確保している heap の解放管理が、どちらの String でやらないといけないかがわからなくなってしまうから（これを "double free"と言ってるのかな）ということかな。この「"double free"が発生してはならない」をもう少し一般化して言ったのが、「デストラクタを実装している（= `Drop` トレイトを実装している）型は Copy を宣言できない」ということになるのか。

Borrow Checker のくだりがやっぱりちゃんと理解できていない気がしてきた。 NLL の説明ででてきた下記のコードで、

```rust
fn process_or_default(key: char, map: &mut HashMap<char, String>) {
    match map.get_mut(&key) {
        Some(value) => value.push_str(", world"),
        None => {
            map.insert(key, Default::default());
        }
    };
}
```

> `get_mut` は `Option<&mut String>` 型の値を返します。この戻り値（可変の参照）が生存している間は `map` の可変の借用が有効です。

という文が出てくる。多分これが腹落ちしてない。
HashMap の例なので、 「その Map 全体が可変であれば、値も変更してよい」と思えば直感的には理解できるんだけど、「一般化するとどういうこと？」ってなっていたが、 O'Reilly の「プログラミング Rust」を引っ張り出して、参照の解説（5 章）を読んで納得（買った直後に目は通したはずだけど、全然消化できてなかったってことだな）。以下抜粋。

> 共有アクセスは読み出しのみのアクセスとなる
>
> 共有参照が借用した値は読み出すことしかできない。共有参照の生存期間の間、参照先だけでなく、**参照先から辿ることのできるものはすべて**、どのような方法でも変更することはできない。
> その構造体内の何であれ、可変参照で参照することはできない。所有者が読み出ししかできない状態になっているからだ。
> 共有参照で参照されているものは完全に凍結されるのだ。

> 可変アクセスは排他アクセスになる
>
> 可変参照で借用された値は、その参照を通じてのみアクセスすることができる。可変参照の生存期間の間、参照先および、**参照先から辿ることのできるすべてに対して**、他のパスから参照することはできない。
> 可変参照の生存期間と重なっていてよいのは、その可変参照から借用された参照だけだ。

借用時に、借用先の所有権（何かの変数をルートとした純粋な木構造）について、子の方向にも親の方向にもアクセスのロックが掛かる、ということだった。

上記のコード例で言えば、 `map.get_mut` は `&mut self` が所有している値について、その値の可変参照を借用して返している。
値の可変参照を借用した時点で、その所有権ツリーのルートである `map` も排他ロックが掛かり、 `value` で借用した可変参照を返却するまでの間、 `map` は読み出しも書き出しもできなくなる、ということになっていたのか。

## GraphQL

Apollo Day、11/11 の深夜 2 時開始だった。 https://www.twitch.tv/apollographql からアーカイブ見れることを期待してリアタイ視聴は諦めるか。。。

## Misc

VSC の Live Share の Local Server Share や Terminal Share を使ってホントに凄いなと思った。もはや綺麗なトロイの木馬じゃん、これ。大体のフロントエンド開発におけるペアプロやモブプロ、Live Share で全然困らないな。

---

# 11/11

## ts-graphql-plugin

CONTRIBUTING.md 修正したり、apollo のサンプルプロジェクトの細かい箇所をいじったりした（graphql-tag が apollo client から直接供給される、など）。

久々に自分で language service 部分触っていて、graphql-language-service-interface を自分で実装したい欲求が湧いてきた。
ここを独自実装にできれば、本当に runtime dependencies をゼロに出来るんだよな。lang server の実装、ちょっとやってみたさはあるし。

## Apollo Day

アーカイブは https://www.twitch.tv/videos/798172368 から見れる

### Understanding Caching in Apollo Client 3

基本的に Client Side Cache の話。

- GraphQL の data を cache するのは簡単ではない
  - Single Endpoint
  - Query が柔軟
- Apollo Client がやってること
  - 不要な N/W req の削減
- AC 3 の重要テーマ
  - Normalize
  - Fetch Policies
  - Type Policies
  - Field Policies
  - Pagination
- Type Policies で、Normalize に用いる unique key となる Field を設定できる
- Fetch Policies:
  - default の policy は cache-first（(cache があれば N/W を発生させない）
  - 頻繁に更新がある data を扱うのであれば、 cache-and-network を使うべき
  - network-only は dirty な cache を利用しない設定
  - cache に保存しない policy は cache-only
- Pagination Helper
  - Generic にページングができるとのこと。あんまり説明なかった。

### Ask Apollo Anything with @benjamn and @gurlcode

- Q. 一番楽しい AC3 機能は？
  - A. Apollo Client の config で宣言的に書けることが増えた
  - A. Reactive variables と Local State Management 部分
- Q. いつ、どうやって GraphQL を導入すべきか？簡単に導入できる？
  - A. 描画に必要な data を single request で取得できるのはとてもよい。performanc の観点でも。

(色々質問あったっぽいけど、英語聴き取るのが辛くて途中で挫折)

### 所感

ザッピングして適当にいくつかのセッション見た程度だけど、さして興味深いものがなかった。。。

## Rust のお勉強

昨日に引き続き、「実践 Rust 入門」の 7 章。簡単なベクタを実装する、というやつ。

pop で「引っこ抜いた要素の所有権を呼び出し元に返す」という部分について、 `self.elements[self.len]` でエラーが発生する理由はわかるんだけど、その解決方法（ここでは `replace` 関数）に自分でたどり着ける気がしない。

```rust
    pub fn pop(&mut self) -> Option<T> {
        if self.len == 0 {
            None
        } else {
            self.len -= 1;
            // 可変借用から所有権を奪えないので、これは駄目
            // let element = self.elements[self.len];

            let element = std::mem::replace(&mut self.elements[self.len], Default::default());
            Some(element)
        }
    }
```

O'Reilly 本を読み返したら、やっぱり所有権の章に `stg::mem::replace` にちゃんと触れてた。全く記憶になかったけど。

これみて思い出しのは、Bitonic Sort の章をやってたときに、「rayon のそれぞれのスレッドに Slice を分割して渡す」という部分で、 Slice の`split_at_mut` で分割して可変借用を得る、という件。
エラーメッセージの意味はわかるけど、それを解消するためのメソッドに辿り着く術について皆目見当が付かない。

にしても、実践 Rust 入門を通しで読みつつ、補足が欲しいときはプログラミング Rust で関係するところを調べる、っていう進め方はしっくり来るな。
