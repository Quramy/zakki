# 10/1

## react-hook-form

`register` の利用法の基本は下記の通り。

```tsx
function SomeForm() {
  const { register } = useForm<FormProps>();
  return (
    <form>
      <CustomInput {...register} />
    </form>
  );
}
```

ただし、 `register` は `ref`, `name`, `onChange`, `onBlur` の 4 つの property を同時に返却する関数なので、 `CustomInput` も ref だけでなく、 `onChange` や `onBlur` を props から受け取って、input にわたすようにしておかないと正しく動かない。

---

# 10/4

## React.js

共通部品の設計的な話。

割と今まで PDS(Presentation Domain Separation) よりで開発標準を敷くことが多かったんだけど、最近この辺りの指針が自分の中で揺らいできている。

下記のような Component があったとして

```tsx
import { useMutation } from "react-query";

function AwesomeComponent() {
  const { mutate, isError, error, isLoading } = useMutaion(/* ... */);
  reutn(
    <>
      {isLoading && <p>loading...</p>}
      {isError && <Error error={error} />}
      <div>
        <button onClick={() => mutate()} disabled={isLoading}>
          Mutate
        </button>
      </div>
    </>
  );
}
```

この Component の表示要件は下記のようであったとする。

- `isLoading` のときに ローディングインジケータを表示
- `isError` のときに、エラーに応じた文言を表示

俺が PDS にこだわってるのは、基本的に「Component の描画を Storybook で行えるようになっているかどうか」に端を発している。

なので、

- API 通信のようなブラウザの外部に情報を取りに行くような副作用は分離したい
- State は外側から Control できるようにしたい

といったあたりが Presentational Component の切り出し基準。

たとえば下記のような分離は成り立つ。

```tsx
type PresentationalProps = {
  loading: boolean;
  error: any;
  onClick: () => void;
};

function AwesomePresentation({ onClick, loading, error }: PresentationalProps) {
  reutn(
    <>
      {loading && <p>loading...</p>}
      {!!error && <Error error={error} />}
      <div>
        <button onClick={onClick} disabled={isLoading}>
          Mutate
        </button>
      </div>
    </>
  );
}
```

また、"loading..." の箇所や `<Error />` Component は往々にして Application 全体で 1 個しか表示しない系統のものなので、これらの見た目そのものも Provider で提供しつつ、表示制御だけを hooks で行ってしまうようなパターンも考えられる。

```tsx
type PresentationalProps = {
  onClick: () => void;
};

function AwesomePresentation({ onClick }: PresentationalProps) {
  reutn(
    <div>
      <button onClick={onClick} disabled={isLoading}>
        Mutate
      </button>
    </div>
  );
}

function useAwesomePresentation() {
  const mutation = useMutation();
  useSetError(mutation);
  return {
    onClick: async () => {
      useLoadingIndicator(true);
      await mutation.mutate();
      useLoadingIndicator(false);
    }
  };
}
```

どっちも設計として成り立ってしまったためにちょっと迷った、ということなんだろうけど、現状の自分の好みでいうとやっぱり Storybook first な開発の方が性にあってるな、と感じた。

一方であんまり Presentation にバケツリレーさせるのも好きじゃないので、半分あきらめで `UseMutationResult` と同型の props を Presentation 側に用意してしまう、という結論に落ち着きつつある。

```tsx
type PresentationalProps = {
  mutationResult: {
    isLoading: boolean;
    isError: boolean;
    error: unknown;
  };
  onClick: () => void;
};

function AwesomePresentation({
  onClick,
  mutationResult: { isLoading, isError, error }
}: PresentationalProps) {
  reutn(
    <>
      {isLoading && <p>loading...</p>}
      {isError && <Error error={error} />}
      <div>
        <button onClick={onClick} disabled={isLoading}>
          Mutate
        </button>
      </div>
    </>
  );
}

function useAwesomePresentation() {
  const { mutate, ...mutation } = useMutation();
  useSetError(mutation);
  return {
    mutationResult: mutation,
    onClick: async () => {
      await mutate();
    }
  };
}
```

---

# 10/5

## Jira

JQL で日付系の項目に対して、「◯ 週間以内に〜」という検索がしたいときに `endOfWeek` という関数が使える。例えば下記は一週間以内の例。

```
due < endOfWeek("+1")
```

https://www.tweeeety.blog/entry/2017/11/14/000746

---

# 10/6

## react-hook-form

react-query と react-hook-form を組み合わせて、form を組むときに頻出しそうなパターン

```tsx
type FormProps = {
  readonly id: string;
  readonly name: string;
  readonly description: string;
};

export function MyForm({ id }: { readonly id: string }) {
  const {
    register,
    reset,
    handleSubmit,
    register,
    formState: { isDirty }
  } = useForm<FormProps>({ mode: "onblur" });

  const {
    data,
    isLoading: queryIsLoading,
    refetch,
    dataUpdatedAt,
    isRefetching
  } = useFormQuery(); // form データの GET に相当する useQuery をラップした custom hook

  const { mutateAsync, isLoading } = useFormMutation(); // form データの PUT に相当する useMutation をラップした custom hook

  useEffect(() => {
    if (!data) return;
    reset(data);
  }, [dataUpdatedAt, reset]);

  const onSubmit = useCallback(
    async (formProps: FormProps) => {
      await mutateAsync(FormProps);
      await refetch();
    },
    [mutate, refetch]
  );

  if (!data || queryIsLoading) return <div>Loading...</div>;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <label>
        Name:
        <input type="text" {...register("name")} />
      </label>
      <label>
        Description:
        <input type="text" {...register("description")} />
      </label>
      <button type="submit" disabled={!isDirty || isRefetching || isLoading}>
        Submit
      </button>
    </form>
  );
}
```

not `mutate` but `mutateAsync` だった。

---

# 10/7

## Apollo

いままでずっと避けてきた Cache の状態やそれに伴う refetch 周りの動きについて、真面目に調べだす。

https://www.apollographql.com/docs/react/data/queries/#supported-fetch-policies

ドキュメントを読んだのみだと、以下の 2 つが指定できる模様。

```ts
const { data, isLoading } = useQuery(QUERY, {
  fetchPolicy,
  nextFetchPolicy
});
```

- `fetchPolicy` : 初回の動きに対する Policy
- `nextFetchPolicy`: 2 回目以降の動きに対する Policy

ここをうまく使って取得ポリシーを制御する。
かなり柔軟なことが出来るし、 swr や react-query との比較も込でまとめてアウトプットしたいな。

---

# 10/8

## CSS

先週くらいにかいた、 `writing-mode: vertical-rl` の件の続き。

> もちろん実際はもっと複雑なんだけど、このときに Safari でのみ、flex item の幅計算が壊れるような現象に遭遇した。
>
> 今これを書きながら、そもそも flex をやめて writing-mode の指定をもっと親まで引き上げればいいのでは？という気がしてきた。

この話を社内で共有する機会があったのだけど、その場で参加者から「 `writin-mode` はテキストの方向を定める property なので、それを用いて flex の bug を解消するのは workaround では？」という指摘があった。

やっぱり `writing-mode` という名前がミスリーディングだよな、と思った次第。

https://www.w3.org/TR/css-writing-modes-3/#block-flow

---

# 10/12

## typescript-eslint-language-service

ついに ESLint v8 が出てしまった。。。

https://github.com/Quramy/typescript-eslint-language-service/pull/339

無傷で乗り越えられるとは思ってなかったが、やっぱりガッツリ落ちてる。

このタイミングと合わせて、 `@typescript-eslint` の側も v4.x から v5.0.0 にアップデートがかかっていた。

https://github.com/Quramy/typescript-eslint-language-service/pull/340

手元の実 prj でたまたま `@typescript-eslint` だけ v5、という構成になっていたので試した感じ、基本的には動いていそうなので、こちらは Type Check 系だけだとおもう。

---

# 10/13

## TypeScript

v4.4.4 って patch が出ていた。

https://github.com/Microsoft/TypeScript/releases/v4.4.4

> This patch release contains fixes for a performance regression in --build mode by only calling realpath on package.json files only when those files are known to exist on disk, and to only perform this work under --watch mode.

## Suparstruct

知らなかったんだけど、form validation 系のライブラリ.

https://github.com/ianstormtaylor/superstruct

yup とかと同じレイヤー？ react-hook-form との連動の文脈にて知った。

---

# 10/14

## react-hook-form

ラジオボタンってどうすんだって思ってたけど、普通に `register` に name 相当を渡すだけだった

```tsx
function Component() {
  const { register } = useForm<{ selected?: "yes" | "no" }>();
  return (
    <form>
      <label>
        <input type="radio" {...register("selected")} value="yes" /> yes
      </label>
      <label>
        <input type="radio" {...register("selected")} value="no" /> no
      </label>
    </form>
  );
}
```

アンケート系でよくある、選択肢に応じて活性制御が変わったりするパターン。 `watch` を使えばよい。

```tsx
function Component() {
  const { register, watch } =
    useForm<{ selected?: "yes" | "no"; detail?: string }>();
  const selected = watch("selected");
  return (
    <form>
      <label>
        <input type="radio" {...register("selected")} value="yes" /> yes
      </label>
      <label>
        <input type="radio" {...register("selected")} value="no" /> no
      </label>
      <label>
        deital
        <input
          type="text"
          disabled={selected !== "yes"}
          {...register("detail")}
        />
      </label>
    </form>
  );
}
```
