# 10/1

## react-hook-form

`register` の利用法の基本は下記の通り。

```tsx
function SomeForm() {
  const { register } = useForm<FormProps>();
  return (
    <form>
      <CustomInput {...register} />
    </form>
  );
}
```

ただし、 `register` は `ref`, `name`, `onChange`, `onBlur` の 4 つの property を同時に返却する関数なので、 `CustomInput` も ref だけでなく、 `onChange` や `onBlur` を props から受け取って、input にわたすようにしておかないと正しく動かない。

---

# 10/4

## React.js

共通部品の設計的な話。

割と今まで PDS(Presentation Domain Separation) よりで開発標準を敷くことが多かったんだけど、最近この辺りの指針が自分の中で揺らいできている。

下記のような Component があったとして

```tsx
import { useMutation } from "react-query";

function AwesomeComponent() {
  const { mutate, isError, error, isLoading } = useMutaion(/* ... */);
  reutn(
    <>
      {isLoading && <p>loading...</p>}
      {isError && <Error error={error} />}
      <div>
        <button onClick={() => mutate()} disabled={isLoading}>
          Mutate
        </button>
      </div>
    </>
  );
}
```

この Component の表示要件は下記のようであったとする。

- `isLoading` のときに ローディングインジケータを表示
- `isError` のときに、エラーに応じた文言を表示

俺が PDS にこだわってるのは、基本的に「Component の描画を Storybook で行えるようになっているかどうか」に端を発している。

なので、

- API 通信のようなブラウザの外部に情報を取りに行くような副作用は分離したい
- State は外側から Control できるようにしたい

といったあたりが Presentational Component の切り出し基準。

たとえば下記のような分離は成り立つ。

```tsx
type PresentationalProps = {
  loading: boolean;
  error: any;
  onClick: () => void;
};

function AwesomePresentation({ onClick, loading, error }: PresentationalProps) {
  reutn(
    <>
      {loading && <p>loading...</p>}
      {!!error && <Error error={error} />}
      <div>
        <button onClick={onClick} disabled={isLoading}>
          Mutate
        </button>
      </div>
    </>
  );
}
```

また、"loading..." の箇所や `<Error />` Component は往々にして Application 全体で 1 個しか表示しない系統のものなので、これらの見た目そのものも Provider で提供しつつ、表示制御だけを hooks で行ってしまうようなパターンも考えられる。

```tsx
type PresentationalProps = {
  onClick: () => void;
};

function AwesomePresentation({ onClick }: PresentationalProps) {
  reutn(
    <div>
      <button onClick={onClick} disabled={isLoading}>
        Mutate
      </button>
    </div>
  );
}

function useAwesomePresentation() {
  const mutation = useMutation();
  useSetError(mutation);
  return {
    onClick: async () => {
      useLoadingIndicator(true);
      await mutation.mutate();
      useLoadingIndicator(false);
    }
  };
}
```

どっちも設計として成り立ってしまったためにちょっと迷った、ということなんだろうけど、現状の自分の好みでいうとやっぱり Storybook first な開発の方が性にあってるな、と感じた。

一方であんまり Presentation にバケツリレーさせるのも好きじゃないので、半分あきらめで `UseMutationResult` と同型の props を Presentation 側に用意してしまう、という結論に落ち着きつつある。

```tsx
type PresentationalProps = {
  mutationResult: {
    isLoading: boolean;
    isError: boolean;
    error: unknown;
  };
  onClick: () => void;
};

function AwesomePresentation({
  onClick,
  mutationResult: { isLoading, isError, error }
}: PresentationalProps) {
  reutn(
    <>
      {isLoading && <p>loading...</p>}
      {isError && <Error error={error} />}
      <div>
        <button onClick={onClick} disabled={isLoading}>
          Mutate
        </button>
      </div>
    </>
  );
}

function useAwesomePresentation() {
  const { mutate, ...mutation } = useMutation();
  useSetError(mutation);
  return {
    mutationResult: mutation,
    onClick: async () => {
      await mutate();
    }
  };
}
```
