# 3/1

## TypeScript

4.6 がリリースされてた。

https://devblogs.microsoft.com/typescript/announcing-typescript-4-6/

RC とほぼ同等の内容だが、 https://github.com/microsoft/TypeScript/pull/47257 への言及が追加されてた。

47257 での変更は、 `@ts-check` というディレクティブコメントが追加されていて、JSDoc における `@params` と 実際の関数シグネチャの整合性を確認してエラーを吐いてくれる機能とのこと。

```js
// @ts-check

/**
 * @param {string} s <-- s という名前のパラメータがないので誤り
 */
function f(untyped) {}
```

## ts-graphql-plugin

TypeScript 4.6 にて一部 Language Service のシグネチャが変更されていたために build failure となっていた。
修正して patch release.

---

# 3/2

## GraphQL

TypeScript で言うところの `Record<string, string>` のような「任意の文字列の map」を GraphQL Schema で表現するの、Custom Scalar くらいしか案がなかったけど以下のような Schema でも対応できることに気づいた。

```gql
type Query {
  record(key: String!): String
}
```

クエリ投げる側が Field Alias 使えばいいだけ。

```gql
query {
  hoge: record(key: "hoge")
  fuga: record(key: "fuga")
}
```

そもそも「任意の〜」とか言ってる時点で割れ窓になる可能性があることは否定できないが、それは Custom Scalar でも同じだし。

---

# 3/3

## Apollo Client

ある意味で昨日の「 `Record<string, string>` 的な Schema」の話の続編。

以下のクエリは勿論 GraphQL Syntax 上 valid なものだけど、これを apollo-tooling の `client:extract` コマンドや、 引いては apollo-graphql の `operationRegistrySignature` と組み合わせるときは要注意。

```gql
query {
  hoge: record(key: "hoge")
  fuga: record(key: "fuga")
}
```

抽出された Query は、以下のようにリテラルとして与えたパラメータが削除された状態になる。

```gql
query {
  __typename
  hoge: record(key: "")
  fuga: record(key: "")
}
```

https://github.com/apollographql/apollo-tooling/pull/1703 にあるように、`preserveStringAndNumericLiterals` を有効にすると直せるが、 `client:extract` の引数だったり、 persisted-query-link の設定だったり全てに仕込んでおく必要がある。

https://github.com/apollographql/apollo-tooling/pull/1703#pullrequestreview-333256311 でも書かれてるとおり、削除する挙動の方を opt-in にしておいてくれよ、、、という気持ち

> I'm hopeful that we can make preserving all literals the default behavior.

---

# 3/4

## DOM

おしごとにて。

```tsx
function Input() {
  return <input type="text" onBlur={e => console.log(!!e.relatedTarget)} />;
}
```

「Blur 発生時にどの要素をクリックしたのかを知りたい」という欲求で `relatedTarget` を使っていたが、Safari だと null になってしまう問題を踏む

---

# 3/7

## GraphQL

[RESTful API との比較で GraphQL API を作ることの難しさ](https://note.com/qsona/n/n8362e4721748)

IMO ではあるものの、「RESTful にやっても設計が難しいリソース」というのはあるし、それって名詞としての抽象化が難しいものでしかないと思ってる。REST であれば URL の命名で苦しみ、GraphQL の場合、Type 名で苦しむことになる。

どちらの場合も、一度公開してしまったら容易に変更できないのは一緒だし、 `/api/v1` みたいなのでバージョニングができなくはないが、一度作ったエンドポイント(もしくは GraphQL Type) を簡単には捨てられないのも一緒では。

一つ、RESTish と GraphQL で異なる点と言えば、誤って設計された Type が Schema 全体で共有されてしまうことか。可視性に関するコントロールが一切できない、と言い換えてもいいかもだが、新しく Schema を拡張するときに、常に「イケてない Type」の存在を考慮しないといけない。RESTish であれば、その汚さは特定のエンドポイントに押し込めて無視することができるけど、GraphQL の場合はそうもいかない、ということ。

## a11y

WCAG 3.0

W3C Accessibility Guideline (Ag = Silver) の略称らしい。

---

# 3/8

## Misc

https://github.com/prettier/prettier/pull/12305

しばらく前に出した Prettier の変更が週末に Release されるみたい

## GraphQL

@joe_re や @mtsmfm と喧々諤々に色々話す。

Client の Store を Server と同期取りたいのであれば「Subscription で Type の変更を購読すればいいのでは？」というの意見あり。なるほど、と思うもののそのためだけに WebSocket の基盤導入すんの面倒だなぁ。。。という印象。

---

# 3/9

## Webview 開発

`<audio autoplay/>` のような要素があっても、Safari の設定(Auto Play Blocking) によっては大体再生されない、というのを知った。

`NotAllowed` の DOM Exception になる。

---

# 3/10

## Misc

jQeuery v4 の話を少しした。 v2 以降くらい全然触ってなかったけど、v4 の話とか上がってるのね。。。

https://www.infoq.com/jp/news/2018/03/jquery-3-3-released/

---

# 3/15

## Sentry

https://docs.sentry.io/product/sentry-basics/grouping-and-fingerprints/

> Sentry uses its own built-in grouping algorithms to generate a fingerprint based on information available within the event such as a stack trace, exception, and message.

自分でグルーピングを制御したい場合、 `fingerprint` プロパティを明示的に指定すればよい。

```js
Sentry.captureException(new Error("Some Error!"), {
  fingerprint: ["{{ message }}", someValue]
});
```

## CSS

`column-count` や `column-width` などのプロパティで段組みレイアウトを組める、というのを初めて知った。

https://developer.mozilla.org/ja/docs/Learn/CSS/CSS_layout/Multiple-column_Layout

---

# 3/16

## Prettier

ようやく Release された :tada:

https://prettier.io/blog/2022/03/16/2.6.0.html#yaml

## Misc

Google Domain ってまだ beta だったのか。。。！ とっくに beta 外れてたと思ってた。

https://domains.google/learn/out-of-beta/

---

# 3/17

## CSS

縦書き / 多段組レイアウト + ルビで苦しめられた。具体例を書くと、以下のような HTML / CSS のイメージ。

https://jsfiddle.net/Quramy/oL89vu2z/

```html
<main>
  <section>
    <header>走れメロス</header>
    <p>
      メロスは激怒した。必ず、かの<ruby
        ><rb>邪智暴虐</rb><rp>（</rp><rt>じゃちぼうぎゃく</rt><rp>）</rp></ruby
      >の王を除かなければならぬと決意した。メロスには政治がわからぬ。メロスは、村の牧人である。笛を吹き、羊と遊んで暮して来た。けれども邪悪に対しては、人一倍に敏感であった。きょう未明メロスは村を出発し、野を越え山越え、十里はなれた<ruby
        ><rb>此</rb><rp>（</rp><rt>こ</rt><rp>）</rp></ruby
      >のシラクスの市にやって来た。メロスには父も、母も無い。女房も無い。十六の、内気な妹と二人暮しだ。この妹は、村の或る律気な一牧人を、近々、<ruby
        ><rb>花婿</rb><rp>（</rp><rt>はなむこ</rt><rp>）</rp></ruby
      >として迎える事になっていた。結婚式も間近かなのである。メロスは、それゆえ、花嫁の衣裳やら祝宴の御馳走やらを買いに、はるばる市にやって来たのだ。先ず、その品々を買い集め、それから都の大路をぶらぶら歩いた。メロスには竹馬の友があった。セリヌンティウスである。今は此のシラクスの市で、石工をしている。その友を、これから訪ねてみるつもりなのだ。久しく逢わなかったのだから、訪ねて行くのが楽しみである。歩いているうちにメロスは、まちの様子を怪しく思った。ひっそりしている。もう既に日も落ちて、まちの暗いのは当りまえだが、けれども、なんだか、夜のせいばかりでは無く、市全体が、やけに寂しい。のんきなメロスも、だんだん不安になって来た。路で逢った若い衆をつかまえて、何かあったのか、二年まえに此の市に来たときは、夜でも皆が歌をうたって、まちは賑やかであった<ruby
        ><rb>筈</rb><rp>（</rp><rt>はず</rt><rp>）</rp></ruby
      >だが、と質問した。若い衆は、首を振って答えなかった。しばらく歩いて<ruby
        ><rb>老爺</rb><rp>（</rp><rt>ろうや</rt><rp>）</rp></ruby
      >に逢い、こんどはもっと、語勢を強くして質問した。老爺は答えなかった。メロスは両手で老爺のからだをゆすぶって質問を重ねた。老爺は、あたりをはばかる低声で、わずか答えた。<br />
      「王様は、人を殺します。」<br />
      「なぜ殺すのだ。」<br />
      「悪心を抱いている、というのですが、誰もそんな、悪心を持っては居りませぬ。」<br />
    </p>
  </section>
</main>
```

```css
main {
  padding: 20px;
}

section {
  width: 100%;
  writing-mode: vertical-rl;
  font-family: serif;
  line-height: 1.5;
}

header {
  width: 24px;
  font-size: 24px;
  letter-spacing: 0.5em;
  margin-left: 32px;
}

p {
  width: calc(100% - 56px);
  column-fill: auto;
  column-gap: 24px;
  column-width: 200px;
}
```

おそらく Chrome(blink)のバグだと思うけど、段送りをした際に `<rt>` 要素が段の境界にまたがった状態で描画されしまう。Firefox でも Safari でも再現しない。

挙動を見ている感じ、layout 計算よりも深い部分で何か起きていそう。一番驚いたのが、window を一切 resize しないまま、サブディスプレイにもっていくだけで結果が変わったりする、という動きをすること。

---

# 3/18

## Storycap

Next.js と Storycap の `isScreenshot` を組み合わせたときに妙な挙動になってしまう問題に遭遇。

Next.js が起動する際、next client component の `componentDidMount` にて、Router の以下部分が呼び出される。おそらく Router の state を初期化するためのコード？

```ts
// The build manifest needs to be loaded before auto-static dynamic pages
// get their query parameters to allow ensuring they can be parsed properly
// when rewritten to
let pages: any, rewrites: any;
try {
  [pages, { __rewrites: rewrites }] = await Promise.all([
    this.pageLoader.getPageList(),
    getClientBuildManifest(),
    this.pageLoader.getMiddlewareList()
  ]);
} catch (err) {
  // If we fail to resolve the page list or client-build manifest, we must
  // do a server-side transition:
  window.location.href = as;
  return false;
}
```

https://github.com/vercel/next.js/blob/v12.1.0/packages/next/shared/lib/router/router.ts#L1072-L1087

ここで問題になるのは、 `Promise.all` で纏められている 3 本の非同期処理のいずれかが失敗すると、画面の再読み込みが誘発されるようになっている点。

`getPageList` は実質 Client Build Manifest の参照と同義になる。

そして、Client Build Manifest の取得は以下のようになっており、 `markAssetError` とある通り、取得に失敗した場合に reject するための Error オブジェクトを事前に作っておくようなコードになっている。

```ts
export function getClientBuildManifest() {
  // 中略
  return resolvePromiseWithTimeout(
    onBuildManifest,
    MS_MAX_IDLE_DELAY,
    markAssetError(new Error("Failed to load client build manifest"))
  );
}
```

さらに、 `markAssetError` は Symbol を利用してフラグを立てておくような実装になっている。

```ts
const ASSET_LOAD_ERROR = Symbol("ASSET_LOAD_ERROR");

// TODO: unexport
export function markAssetError(err: Error): Error {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}
```

ここで、`isScreenshot` が Component 中で使われている場合に、特定の環境下において `defineProperty` に Polyfill が当たってしまう、ということが起きていた。
特定の条件下、というのはいわゆる iOS / Android の Webview から Next.js のアプリケーションをロードしているパターンで遭遇したのだが、正確な条件の切り分けには至っていない。

`defineProperty` が monkey patch された結果、Symbol を `defineProperty` で作用させる瞬間に以下の TypeError が発生してしまう。

```
TypeError: Cannot convert a Symbol value to a string
```

もちろん、 native func としての `defineProperty` が利用されれば、正しく `err` に `ASSET_LOAD_ERROR` Symbol に property が生えるので、Next.js 側は何の罪もない。

ただ、patch された `defineProperty` が利用される結果、 `getClientBuildManifest` が Error となるため、Next.js の初期化処理としては以下の catch 節に流れてしまい、結果的に無限リダイレクトのような構造になってしまっていた（ `as` の URL は location が指し示している値と同値のため）。

```ts
// If we fail to resolve the page list or client-build manifest, we must
// do a server-side transition:
window.location.href = as;
return false;
```

正確な機序解明には至っていないが `import { isScreenshot } from "storycap"` の declaration がこの問題を引き起こしていたことは明らかだった。

下記のような Component を書いたとしても、Production Build には影響を与えないようにできればよいはずなので、 Dual Export と[webpack の side effects](https://webpack.js.org/guides/tree-shaking/#clarifying-tree-shaking-and-sideeffects) をきちんと設定するようにした。

```tsx
import { isScreenshot } from "storycap";

export function AwesomeComponent() {
  if (process.NODE_ENV !== "production" && isScreenshot()) {
    return <Dummy />;
  }
  return <AnimatedComponent />;
}
```

この過程で、Storybook v4 での build が危うくなってきたため、Storycap v4 として提供することを検討中。

## Node.js

@sindresorhus さんの ESM 移行ガイド。

https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c

> My repos are not the place to ask ESM/TypeScript/Webpack/Jest/ts-node/CRA support questions.
