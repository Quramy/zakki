# 12/1

## GraphQL

Cookpad のアドカレ https://techlife.cookpad.com/entry/2020/12/01/093000 を軽く読んだ。

既存の RESTish な API を GraphQL でラップすると、N+1 が容易に発生しそうと思ったが、 Rails 側で利用している https://github.com/cookpad/garage という Cookpad 製の Framework が GraphQL フレンドリなお陰で GraphQL gateway が起きやすい、という模様。

## typescript-eslint-language-service

`@typescript-eslint` v4.9.0 の update で落ちてた。

extra options を作る箇所が原因。

build が失敗した直接の原因は、

```ts
interface Extra {
  projects: string[];
}
```

から

```ts
interface Extra {
  projects: CanonicalPath[];
}
```

に型変更が起きていたため。また `CanonicalPath` は所詮ただの string なんだけど、例の `Phantom Type` 的な hack がされている型。
`CanonicalPath` の生成をしているコードを読むと、glob やらを使った割と泥臭いコードが internal function として書かれていて、「同じ部分をコピーしてくるのか？ダルい...」と思っていたけど、よくよく考えたら https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/typescript-estree/src/ast-converter.ts#L9 にわたす部分だけちゃんと設定すれば後は関係ないことにコードを読んでいて気づく。

## TypeScript

@kazupon さんが作っている Doc 生成系ツール https://github.com/kazupon/api-docs-gen

（tsdoc 使われてないよねーの文脈で教わる）

ts-graphql-plugin で放置している addon の interface 定義を markdown にする部分で使えそうな気配ある。

## Misc

昨日書いた Puppeteer の記事、結局アドカレ化することになるという（上司公認）。。。

---

# 12/2

## GraphQL

アドカレネタ考えないとなー。

- 何かしらの Client lib (state manager) を実装する
- Language Service 実装する（ts-graphql-plugin を zero dependencies にする活動）
- New Relay Compiler のコード読む
- [PayPal のコレ](https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55) 読んで解説

試しに https://github.com/graphql/graphiql/tree/main/packages/graphql-language-service-parser を読み出してみた。
npm の graphql は incomplete な(syntax invalid な) token 列を parse できないので、そのまま使えない。
ので、lang server 側で lexer と parser を別に持つ必要があって、、、というのはわかる。が、パットはどういう実装なのかわからないな。

## Angular

こっちもアドカレネタをそろそろ収集しないと。
ESLint + Angular の何かをうっすら考えていたけど、 https://blog.lacolaco.net/2020/11/angular-state-of-linting-2020/ に最近の status が書いてあって助かる。

> 当初は Angular CLI のデフォルト Linter を ESLint に移行するために、ESLint 対応のファーストパーティ実装を追加する方向で進んでいたが、 すでにサードパーティで存在していて活発に開発されている angular-eslint の意向を尊重し、angular-eslint と連携する方針に固まった。

ネタとしては、Offline Compiler と ESTree の繋ぎがどうなってるか、とかそういう辺りかと思っていたが、`@angular-eslint/template-parser` のコードが薄すぎて読み応えが全然なかった。

ふと「AST Explorer でこの parser が見れたら面白くね！？」って思ったので、これはやってみてもいいかも。PR 出すとこくらいまでは持っていけるかしら。

調べてみたところ、AST Explorer の HTML シリーズに Angular の offline compiler 自体は登録されてたので、そこまでの impact はないかもしれないけど、一応「AST Explorer で Angular HTML の ESTree が見れれば自分でカスタム ANgular Template ESLint rule 作るときに役に立つよ！」という建前は付けられる、のか...?

## ng-japan on air

久々にリアタイで聴く。`@Injectable` の深堀り会で興味あったので。

```ts
@Injectable({ providedIn: "platform" })
class AwesomeService {}
```

のように引数指定が可能ということを知る。 `root` がデフォルトだが、 `platform` とすると platform-browser 全体で 1 つの instance になる。

逆に、 `root` は飽くまで 1 bootstrap に対して 1 個。

基本的に `bootstrap(AppModule)` 自体を複数個の Module に対して実行すること自体がレアケースなので、普段は問題にならないが、angular-elements が出てくると話が変わってくる、ということ。

確かに、elements は Custom Component 相当が bootstrap の対象、すなわちそれ自体が小さい Angular の application として振る舞うイメージなので、複数の angular-elements で作った Custom Component 間で Service を共有したい場合は `{ providedIn: 'platform' }` にしないとバグになるケースがあり得る。

とはいえ、angular-elements を使うということはほぼ Micro Frontent がモチベーションにあると思うんだけど、その場合に全体の DI が Angular way にロックインされるのってどうなの？ってなりそうなのよね。
Lit Element + angular-elements みたいなことをしたいと思っても、angular-elements 側にしか注入されない DI なのであれば「じゃぁ普通に Angular の Module でやれば十分じゃん」ってなりそう。

## CSS

IE を対応ブラウザから落としてれば `width: fit-content;` ってとっくに使えるの、つい忘れがち。

`display: inline-block` に頼っちゃうことが多いんだけど、 block 要素の幅を成り行きに任せたい、というときは一番これが便利なのよね。

## E2E もやつき

先日書いた Puppeteer の ARIA ハンドラの文脈で、E2E のことをもやもやと考えていた。

`@puppeteer/recorder` そのものはあまりにも使い物にならないから、何か Recorder 相当を作りたい欲求が出てきている。

Runner の作りやすさや柔軟性を考えると、出力形式は .ts が良い。ただ、それって飽くまで「俺の欲求」でしかなくて、本当に必要とされているものなのかどうかは怪しいんだよな。
Arlecchino アレを作り出したときは、npm エコシステムの外側に使ってもらうために、シナリオを生 JavaScript ではなくて YAML の DSL に限定したんだった。
Arlecchino は完全に放置していた（というより、Puppeteer + ARIA の話をやるまで忘れきっていた）けど、何もしなくても query に ARIA 書けるんだよね。作っていたときは Recorder は Scope に入れないっていう強い気持ちがあったけど、Remote Object ID の取り回しが良くなってきているし、その部分が 2 年前とは大きく違う。

ざっと想定している要件を書き出すと下記になりそう。

1. Recording 結果を GUI で操作できる
2. 操作した内容を Human Readable な形式で保存、実行できる
3. テキストエディタで保存結果を編集できる
4. テキストエディタで編集後であっても GUI で読み込み・編集ができる
5. 実行結果のレポートやログから、エラー発生時（assertion error / panic 的な error 両方とも）に、シナリオのどの部分で失敗したかが理解できる

理想的には、TypeScript ( or JavaScript）のソースコードそのものをシナリオのモデルとできればいいのか？

擬似コード的に考えると、以下の `login_scenario` は YAML と.ts 表現は等価で、 YAML -> .ts へのコンパイルはさほど難しくない。

```ts
/* login_scenario.ts */

import { scenario } from "@arlecchino/core";

scenario("ログイン", "https://awesome.example.com/login", async ctx => {
  await ctx.waitForFirstIdle();
  await ctx.find("aria/ユーザーID");
  await ctx.$0.type("くらみー");
  await ctx.find("aria/パスワード");
  await ctx.$0.type("zxcvbn");
  await ctx.find("aria/ログインする");
  await ctx.screenshot();
  await ctx.$0.submit();
});
```

```yaml
/* login_scenario.yml */

description: ログイン
url: https://awesome.example.com/login
steps:
  - wait_for_first_idle
  - find:
    query: "aria/ユーザーID"
    action:
      input: くらみー
  - find:
    query: "aria/パスワード"
    action:
      input: zxcvbn
  - screenshot
  - find:
    query: "aria/ログインする"
    action: submit
```

さすがに .ts -> YAML の方向に convert する需要はまぁ無いのでそこは無視する。

多分、.ts における Statement Node を元に、GUI の操作単位だと思えば行けるんじゃないのだろうか。

要件 4. を考えると、下記みたいに編集されたとして、 `myCustomFunction` の Call Expression Statement はもはや「カスタム関数呼び出しステップ」としか言いようがないんだけど、それはまぁしゃぁないわな、っていう感じ。

```ts
await ctx.find("aria/ログインする");

// ちょっと独自処理を追加
await myCustomFunction();

await ctx.screenshot();
```

---

# 12/3

## AST Explorer

昨日思いついた `@angular-eslint/template-parser` を追加するやつ件に着手。
新しく parser を追加するの自体は瞬殺だったけど、AST Node の location 情報を parser 側が ESTree 形式で提供してくれていないのに戸惑った。

template-paresr が公開している `parseForESLint` の戻り値の `services.convertNodeSourceSpanToLoc` で ESTree の location に変換できるけど、自分で traverse するの馬鹿らしいし、そこまで重い処理でもないから default でやって欲しいけど、利用側でやるべきなのかどうかが判断付かないので issue にして回答待ち。 https://github.com/angular-eslint/angular-eslint/issues/209

```js
const {
  ast,
  visitorKeys,
  services: { convertNodeSourceSpanToLoc }
} = parseForESLint(code, options);
```

とりあえず workaround として、自分でも各 node に loc を生やすようにして PRed.

久々に gh-pages 使ったら `The "path" argument must be of type string. Received type undefined` の error message で悩まされた。明らかに Node.js の path module に変なもの渡したときの error だし。

https://github.com/tschaub/gh-pages/issues/354#issuecomment-674552919 に

> This only happens on 3.1.0. 3.0.0 works fine,

とあったので ver 指定して直ったからよかったけど。

## Angular ESLint

AST Explorer の文脈で codelyzer の rule で template 系を眺めてみたけど、 https://github.com/mgechev/codelyzer/blob/master/src/templateAccessibilityAltTextRule.ts とかは割と簡単に ESLint rule 化できそうではある。PR にしてみるか？

## React

仕事で React app の performance tuning をやる。
Redux state に繰り返し構造を持っているような form について、 `<li>` に相当する Component を `React.memo` しているにも関わらず全要素で reconcile が発生してしまう、というやつ。

object な props が幾つかあったので、そのうちのどれかの参照が変わってて、shallow equal じゃ駄目なんだろうなってのは即推察がつくものの、「全部で 15 個くらいある prop のうちどれなんだ？」ってがわからないので、memo の 2nd argument にロギング仕込んじゃうんだけど、もうちょっと賢いやり方ないんかな？

```js
const Item = React.memo((props) => (/* 略 */), (prev, next) => {
  Object.keys(prev).forEach(k => console.log(k, prev[k] === next[k]));
  return false;
});
```

## Relay

久々に @koichik さんと会話する機会があったので、色々と教えてもらう。

- Relay と密接に絡んでいる React の feature で Transport というものがあるらしい
  - React element 相当（JSX の実行結果を json にしたようなイメージ？）を Intermediate Representation にした上で何かしようとしている？
  - `react-transport-dom-webpack` みたいな npm package がある
- https://github.com/relay-tools/relay-hooks Relay 本体の hooks は Concurrent Mode での Suspense for data fetch 専用に作られているが、こちらの package の同名の `useQuery` を使うと、Apollo Client の `useQuery` のように、data, error, isLoading などが同期的に返ってくる signature として使うことができる。要するに React の Legacy Mode でも利用可能。

`@defer` や `@stream` 対応といい、やっぱり React 上での Application Framework としては Relay の方が Apollo Client よりも筋が良さそうに思ってしまう。

久しく Relay 触ってないけど、GraphQL アドカレあたりのネタとしても良さそうかも。

---

# 12/4

## Import Assertion

@Jxck さんの ["CSS Module" をめぐる混乱](https://zenn.dev/jxck/scraps/dc8780fd5b8ea6) を見かけて、Import Assertions という spec が提案されているのを知る。

https://github.com/tc39/proposal-import-assertions

```js
import { data } from "./hoge.json" assert { type: "json" };
```

Module Specifier はただの String Literal であって、suffix に '.json' があろうがなかろうが、それがどのような MIME type なのかを決定できるわけではない。

多分、「.json だから何かのデータのつもりで読み込んだが、それは実際には悪意のあるスクリプト実行だった」というようなことが起こりうる。

「Module を load する側が対象の Module 形式を厳密に指定できなれけば、複数 type の module を安全にロードすることができない」という意味だと思う。
この問題が解決できなかったことで、JSON Modules は（複数のベンダが実装していたが）頓挫している。

- https://github.com/whatwg/html/issues/4315
- https://github.com/WICG/webcomponents/issues/839

「load する側が対象の Module 形式を厳密に指定」のためには、マーカーとなる Syntax が必要になるので、それが Import Assertion の範囲。
Syntax の提供でしかないので、上記の例のような、 `{ type: "json" }` という表記の Semantics には踏み込まない。

たとえば json については [JSON Modules](https://github.com/tc39/proposal-json-modules) のように、別個の proposal として切り出されている。

## GraphQL

spec 眺めてたらそろそろ `@defer` と `@stream` 入りそう？ https://github.com/graphql/graphql-spec/pull/742
graphql-js にはもう入ってるんだよな。

## reg

社内の reg-suit 利用案件で「絶対に差分があるはずなのに passed になっちゃう！」という相談を受ける。
マジかよ、と思いつつ手元で最新の reg-suit 使ってイチからやってみたら再現して冷や汗かいた。

完全には原因を究明できていないが、pixelmatch にわたす Threshold が undefined になってしまうと発動する。
reg-cli の場合、undefined ではなく null 渡しするように CLI を書いていたので気づきにくい構造だった（というより null / undefined で挙動が変わるのもどうかと思うが）。

reg-suit と img-diff-js 側双方に patch 当てる。

## Chrome の Cache Partitioning

Chrome 85 から、リソースの cache のキーに、リソースの URL だけでなく、リクエスト元となるオリジンも使われるようになっていた。

https://developers.google.com/web/updates/2020/10/http-cache-partitioning

知らなかったー。
Cache Hit Rate が下がるが、 Performance 影響はそこまで大きくない、とのことだが、Google fonts など、「ユーザーが別サイトでロードしたことがあることを前提にしていた高速化」は役に立たたなくなるのか。

https://wicki.io/posts/2020-11-goodbye-google-fonts/

タグマネから配信される広告系の SDK とかもそうなのかな？（あの手のやつはクエリに client id みたいのを入れるようになっている気もするけど）

## a11y

自チームで、「運用しているサイトに VoiceOver で読み上げさせた際にどういう課題があるのか」を知るために実際に読み上げさせて聴いてみる会をやってみた。

- そもそも VoiceOver の使い方を知らなかった
- ページ遷移後の navigation イチが header から始まってしまう
  - skip link 案件かな？と思ったけど、 https://weba11y.jp/basics/faq/skip-link/ HTML5 以降の考え方では必須というわけではないらしい。とはいえ、WCAG2.0 達成を考慮するのであれば、あったほうがよいとのこと
- 画像の中身に関する詳細を本文で言及しているけど、alt すら貼っていないので意味が不明
- `・` （中黒）が意味不明の音で読み上げられてる
- validation error が読み上げられていない（role="alert" が抜けている）
- etc...

ちなみに、Chrome 自体の読み上げも試してみたけど、かなり辛い（文と文の切れ目が全然わからない）。

VoiceOver 動かしながら、つい目で追っちゃうけど、全盲の人は本当に音だけから情報を拾ってるんだよな。。。
これ、本当は目隠ししつつ試してみるのがいいのかもしれない。Dialog in the Dark を思い出した。

## React

たまたま @koba04 さんが呟いてんのを見て気になった。 https://github.com/facebook/react/pull/20372

これも `[Flight]` が付いてるけど、もはや意味が全然わからない。。。 Postgres に query 飛ばすのがなんで React に関係あるんだ!??
Suspense for Data Fetch で Postgres にクエリぶん投げるってのは分かるけど、これって transport とかそういう話なのかしら。

やっぱり Flight or Transport が何なのかがわからないと、この PR の意義が理解できなさそうではある。

## Misc

「達人プログラマー」の第二版を購入。物理。 「デザイニング Web アクセシビリティ」も購入。こっちは kindle 版

---

# 12/5

## a11y

「デザイニング Web アクセシビリティ」読了。

書籍としては読みやすかった。扱っているテーマがテーマだけに、読みやすさや文章の平易さにも気を配って書いた、とかそういう背景があるのだろうか？

コーディング的な tips は少なめで、プロジェクト立ち上げ時やサイトデザイン時の留意点に重点が置かれていた。

同じフロントエンドの括りでも、コンテンツ制作系とアプリケーション制作系で気にする箇所が違うと思うけど、両方をカバーしつつ、前半〜中盤をコンテンツ系の話に、後半をフォームなどアプリケーション系の話にまとめてある。

観点や WCAG との対応など、網羅性的な部分も確保されているので、入門書としてよかった。逆に開発ですぐに試せそうな tips の比重は少ないので、そういったテクニックを求めるのであればあまり向かない。

気になる箇所が多いのはやはりフォームまわり。

エラー箇所について、「テキストなどを明確に置いて、どんな環境でも識別できるようにしましょう」とあるが、「それがエラーメッセージであること」を示すための `invalid` や `alert` の話には触れられていない。スクリーンリーダーの章でも特に言及がなかった。
また、「必須項目を明確にする」についても「ラベルの後ろについても『必須』というテキストをつけるのが最も良いでしょう」とあるが、 `aria-required` や `required` といったマシンリーダブルを考慮した説明は出てこなかった。

ここのところ業務でやっている案件のフォーム周りについては考える機会が多かったため、正直「いや、それだけじゃ片手落ちじゃない？」と思ってしまった。コーディング寄りの本も対で出ているらしいので、そっちに書いてあるのかもしれない。ただ、2015 年の本となると、その頃から仕様が変わっているところも多いだろうし、ベストプラクティスを本に求めるのは止めた方がいいかも。

## Angular ESLint

折角なので、codelyzer の Template 用 rule を ESLint 化してみる。

対象は正直なんでもよかったんだけど、難易度が中くらいっぽく見えたので http://codelyzer.com/rules/template-use-track-by-function/ を選択。「`ngFor` 使うときに `trackBy` の指定を強制する」というやつ。

https://github.com/mgechev/codelyzer/blob/master/src/templateUseTrackByFunctionRule.ts が移植元のコードになるわけだけど、これの中身は殆ど理解してない。「あー、正規表現使ってる箇所があるんだなー」程度。

https://github.com/mgechev/codelyzer/blob/master/test/templateUseTrackByFunctionRule.spec.ts を見て、valid / invalid なコードを spec として、それを満たすように ESLint としての rule を組むだけだった。

一番ハマったのは、RuleTester が失敗したときに、jest の child process を跨いで結果を送信する箇所で AST の children <-> parent の循環参照のせいで、jest がよくわからない落ち方をして、どこでテスト失敗してるのかさっぱり分からなくなってしまったところ。

rule の実装そのものは、普通に昨日自分で組んだ AST Explorer を見ながら、esquery で絞り込みを書いていく程度で、余裕過ぎて手応えがまるでなかった。

とにかく、これでアドカレネタとしては十分かな。あとはそれぞれが merge されるのを待つだけだけど、まぁ最悪間に合わなくてもいいや。

---

# 12/6

## Angular ESLint

昨日と一昨日でやったことをアドカレ用の記事としてまとめておく。あとは 12/8 に公開するだけだ。

---

# 12/7

## Husky

Renovate から各 OSS Repository に Husky の v5 upgrade 通知が来ていたけど、よくよく読んでみたら、まだ early access 扱いっぽい。(OSS 利用ならいいよ、と読めるけど）。

なんか使い勝手悪くなってそうな気配あるし、もうちょっと待つか。

## STAC2020

- [WingArc 社の資料](https://medium.com/wingarc/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%83%86%E3%82%B9%E3%83%88%E8%87%AA%E5%8B%95%E5%8C%96%E3%82%AB%E3%83%B3%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B92020-%E7%99%BA%E8%A1%A8%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%89%E5%85%AC%E9%96%8B-191d38586984)
- [E2E テストの flaky と向き合う](https://speakerdeck.com/pineapplecandy/stac2020)

## Misc

[GitHub の 2020 統計](https://octoverse.github.com/)。中身はともかく、セクションが viewport に入ってから数字が countup されるような演出が入ってるのが気になる（誰得？という意味で）。

https://nihonbuson.hatenadiary.jp/entry/2018/03/10/110000 Flaky っていう言葉があるのか。VRT やってると、こいつをいかに減らすかが課題になるんだけど、いつも言葉を探すのに苦労していた。

https://github.com/Quramy/eslint-plugin-tutorial の Dependencies を上げておく。ついでに prettier と renovate も突っ込む。

---

# 12/8

## GraphQL

いくつかアドカレ眺める

- [Shopify/graphql-batch がどのように batching するのかを追う](https://ravelll.hatenadiary.jp/entry/2020/12/04/235719) Ruby だけど、例がシンプルなので読みやすそう。
- [クエリ結果を軸とした GraphQL のエラーハンドリング](https://indigolain.hatenablog.com/entry/2020/12/06/065823) https://sachee.medium.com/200-ok-error-handling-in-graphql-7ec869aec9bc で紹介されている Error modeling のパターンについて。これ面白いな。「クエリがエラーを持つのか、フラグメントがエラーを持つのか」で client のエラーハンドリングのやり方の大きく変わりそう。Exception と思うか Result と捉えるのか。error の性質次第ってのはあるだろうけど、Result っぽく fragment に Union する方が設計上の綺麗さがあるように感じる。

自分のアドカレネタは `@defer` にしようかな。とりあえず現状と参照実装っぽいものを調べよう。

[GraphQL ASIA](https://graphql.asia/2020/) というイベントがあるらしい。 Hasura 主催。GraphQL tokyo の slack より。日本語登壇ありで、締切は 2021/1/7 とのこと。

## CSS

[State of CSS の 2020 版](https://2020.stateofcss.com/en-US/)

- Tailwind の人気は変わらず。一方で Utility First が BEM と逆転してるのはちょっとおもしろいな（Methodologies は僅差だから、あまり意味ないかもだけど

なんだこれ系。 知らない[features](https://2020.stateofcss.com/en-US/features/)が多い。。。

- [CSS Scroll Snap](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Scroll_Snap)

## TypeScript

「async function が Promise 以外を返せない」っていう言葉を切り取って、クッソどうでもいい tweet がなされてるのを見てウンザリする。

## a11y

`aria-role="radiogroup" aria-required="true"` が valid であることを知った。

## Spreadsheet

いまだに `VLOOKUP` の使い方が調べないとわからなくなる...

## Java

凄く久々に仕事で Java のコード書いた。

結果的に関係なかったんだけど、Jackson annotation と Java 8 の `localDate` のマッピングを調べたりしていた。
Custom Serializer でないと、Java 8 Date にマッピングできなかった時代があったらしく、その方向の記事に吸い込まれてしまっていた。
Java だと少し古めの投稿でも何となく信用してしまうけど、やはりそんなことは無いんだな。。。

というか、Java 8 って全然触ったことなかったな、そういえば。Spring 全体の雰囲気が昔と一緒過ぎて、全く気にしてなかったけど。

---

# 12/9

## GraphQL

[GraphQL Asia 2021](https://graphql.asia/) の CFP 募集、わざわざ GMail の個人アカウントに来た（悪い気はしない） Guild の方にも流しておいた。Hasura、日本人の Marketing Operators がいるのか。道理で CFP や登壇が日本語 OK になってるのね。

graphql tokyo の slack の流れで、もういっこアドカレ書くことになってしまった。自発的に追い込んだだけなんだけど、ネタ考えないとなー。

`@defer`, `@stream` の件、 https://github.com/graphql/foundation.graphql.org/pull/50 を参考にできそう。
これに付随して、 https://github.com/graphql/foundation.graphql.org/pull/50#issuecomment-741759755 で grapqlh-helix がサポートしている、とある。

https://github.com/contrawork/graphql-helix

シンプルな GraphQL Server 用ライブラリ。特定のフレームワークに依存せずに、かつ `@defer` や `@stream` が使えて dog fooding に良さそう。

## QUIC

helix の流れで、GraphQL over HTTP/3 ってどんな感じだろう？という興味がちょっと湧いたので、QUIC について調べようという気持ちに。

[Leko さんの Node.js で QUIC 記事](https://blog.leko.jp/post/http-over-quic-on-nodejs15/#quic%E3%80%81http-over-quic%EF%BC%88http3%EF%BC%89%E3%81%A8%E3%81%AF%EF%BC%9F)

上を読むまでは「Node.js v15 で使える！」くらいに思い込んでいたが、自分で Node.js のビルドするところからか。。。ハードルたかいなー。(helix の example に PR 出せるレベルじゃない)

https://http3-explained.haxx.se/ja

## GitHub

GitHub Universe に合わせて new features の blog 投稿が。 https://github.blog/2020-12-08-new-from-universe-2020-dark-mode-github-sponsors-for-companies-and-more/

GH actions のとこに書いてある "Deployment Review" っての気になる。以前に CircleCI でやってた approve を UI から実行して tag 打ち（特に `lerna version patch` のような、deployment trigger となるようなコマンド操作）を Actions に寄せられるのかな？

たまに「今開いてる GitHub の画面が会社の GHE なのか個人で使ってる github.com なのか」を見失うことがあるので、github.com の方を dark mode にしてみる。目が慣れない！

## CSS

CSS Modules に対する Defacto と Spec で standard がかちあいそう問題.

https://webpack.js.org/blog/2020-12-08-roadmap-2021/#css-as-modules

> But there is a big "BUT" here: There is work towards a different "CSS Modules" proposal in the WebComponents community, which is planned to become natively supported by browsers.

WebComponents の これのことかな？ https://github.com/WICG/webcomponents/blob/gh-pages/proposals/css-modules-v1-explainer.md

そんで、https://github.com/WICG/webcomponents/issues/759#issuecomment-416515836 に webpack team の意見がチラ見え。

で、さらに今年の 2 月の https://github.com/webpack-contrib/css-loader/issues/1050#issuecomment-592541379 (webpack CSS Modules やめるってよ騒動の件)に繋がって、それが https://github.com/vercel/next.js/issues/15542 とかで言及されてきて今に至る、、と。

webpack team の jhnns さんが書いてるみたいに、

> In the long run, I'd really appreciate if there was a way to import assets into JS while allowing the importer to define the how.

っていうのくらいしか折り合いつく方法ないんじゃないかなぁ。。。

とはいえ、(デフォルトの loading 方法じゃなくなった) webpack-contrib な CSS Modules を使うには、正しく assertion を書いてください！とかなったらなったで面倒だよな。
でも、JSON Modules のことを考えると、Web Components の CSS Modules も、下みたいに、 `assert` の利用が強制されるのであれば、「既存のコードから見たら関係ない」って話になるのか？？？

```html
<html>
  <head>
    <script type="module">
      import styles from "./my-stylesheet.css" assert { type: "css" };

      class MyElement extends HTMLElement {
        constructor() {
          const shadowRoot = this.attachShadow({ mode: "closed" });
          this.shadowRoot.adoptedStyleSheets = [styles];
        }
      }
    </script>
  </head>
</html>
```

分かんなくなってきた...

## Prisma

Migration 機能、ようやく preview になったのか。1 年くらい前に、（まだ LIFT って呼ばれてた頃）に一回試したっきりだけど、大きくは変わって無さそう？

https://www.prisma.io/blog/prisma-migrate-preview-b5eno5g08d0b

## Misc

- [チームで運用と戦い、おいしい牛カツと出会った話](https://engineering.mercari.com/blog/entry/20201209-f086bc2dfe/): 簡易な Google Form + Spreadsheet で運用コストを可視化した話など。よい。
- https://github.com/geelen/shellac : Glen Maddern が作った shell 系の lib
- angular-eslint の PR、レビューしてもらえたで、指摘対応して push

---

# 12/10

## Chrome Dev Summit

字幕助かるなぁ。

### Chrome and the Web in 2020

- Adventure 気になる https://developer.chrome.com/devsummit/adventure/

#### Chrome team の働き方 by Parisa Tabriz

- Accessible な PDF の生成
- 在宅の TV 会議はロックダウン以前の 4 倍に
- Chrome Tab Group を社内で活用

#### 拡張機能 by Dion Almaer

Manifesto が v3 に(2021)
テーマは Privacy の強化

#### Privacy Sandbox

3rd party tracking の軽減, same site policy
Privacy バジェット prj, user-agent client hints API, conversion measurement API, trust token API,

#### Performance by Dion Almaer & Sunit Jindal

- JavaScript の memory を節約する仕組み (V8 の GC 関連？)
- Core Web Vitals
  - [Web Almanac](https://almanac.httparchive.org/ja/2020/)
  - GA での計測
  - web vitals report ページ

#### CSS

- Flex で親から子の gap を制御する方法
- content-visibility
- `@property` by Houdini
- Nest selector
- セレクタの圧縮(ってなんだ?)
- 親コンテナのサイズ設定
- etc

#### Devtools

- Grid
- Accessibility
- Lighthouse updates
- react-create-app + workbox
- workbox v6(webpack v5, migrate TypeScript)

#### Web Assembly

- 画像の codec と Squoos htool
  - https://github.com/GoogleChromeLabs/squoosh/tree/dev/cli
- etc

### Partner spotlight: experience Adobe Spark on Chromebooks

Adobe Spark というアプリを PWA でリリースした、という話。(ヨイショ感がすごい)

- Chromebook が教育現場での利用が多いため、PWA での実装につながった。
- Core PWA Checklist を参照している
- 大変だったのはオフラインサポートとパフォーマンス
  - まずは offline dinosaur を見せないこと
- 最初は Lighthouse スコアはかなり悪かった
  - 計測を自動化
  - new relic と Splunk に Performance API metrics を送信
  - Lighthouse の自動実行と Performance Budget の策定
- 結果的にフィールドデータも改善された
- CWV の改善はまだ
- 今後活用していきたい機能
  - リンクキャプチャで PWA を web から開く
  - File Access API
  - Web Assembly での C++資産の活用
- これから Play ストアに Chrome OS APP として配布していく予定

### Intersection

言葉当てゲーム

「Vim ユーザーはこの言葉が大嫌いです」「emacs?」「正解！」

### State of speed tooling

シンプルなフィールドデータとして使える指標が必要だった。

- Lighthouse Performance score の構成要素
- CWV のうち、CLS だけは重みが低いが、これは調整中
- [Lighthouse Scoring Calculator](https://googlechrome.github.io/lighthouse/scorecalc/)
- Third party facades: YouTube のような、読み込み遅延（？）の機会を audit が教えてくれる？
- CWV と devtool
- LCP: Performance tab
- TBT/FID: Audit に時間が長い順に task が表示
- CLS

### Fixing common Web Vitals issues

#### CLS

Performance Observer で `onLayoutShift` で計測できる。

devtool の"Layout Shift Redions" が便利

Scroll だけは他の input と扱いが異なる。Labo tool はスクロールを発生させないので注意

よくあるのは、ページ上部に banner 出現で全体が shift するケース

#### RUM(Real User Monitoring)

Search Console は HTML の中身で URL をグルーピングできる

web-vitals-js で自分で送信することが可能

cloudflare は無料で CWV を計測できる

### UX patterns optimized for Core Web Vitals

コロナに対する情報提供で CLS が起こるケースが増えている。Fixed Placeholder でバナーなどに対応できるが、動的にサイズが変わるような広告バナーには当たり前だが対応できない。
どうしても、事前に決定できない場合は、 `min-height` をもたせてシフト値を軽減させる。
広告が返ってこない場合に、placeholder を折りたたむのはやめたほうがよい。

無限スクロールのときに、コンテンツ追加文で footer がシフトしてしまうパターンについて:
placeholder, prefetch などで対応可能

ボタンをクリックしてコンテンツが追加される系:
同期的に(500ms 以内に)loading placeholder を表示させてから、本体のコンテンツを待つべき

### Exploring the future of Core Web Vitals

- 現在の指標の update:
  - FID の閾値の調整(ちょっと見直さないとわからん)
  - CLS: speed metrics change log で詳細が見れる
- 今後やりたいこと:
  - SPA での遷移を指標化したい
  - FID だけでなく、Interaction 全体の計測
  - scroll junk の指標化
  - Performance 以外の UX 指標(セキュリティ関連など)の指標化

### Core Web Vitals and SEO

- まずは high quality な content を提供しろ
- Accessible であれ
- SEO が見るのは Field Data
- サチコで issue をトラッキングして、改善したら再 audit させることができる

### Beyond fast

- CSS の content visibility と content intrinsic size で子要素の layout 計算を skip. Chrome v85 から
- font metric override で font が持っている微妙な高さ情報などを上書きすることで、font swap 時の layout shift を軽減させる
- BF cache の Chrome 版？
- potal 要素: modal を podal で実装する例など
  - prerender, prefetch を cross origin でできるようにするには？
  - quicklink というライブラリがある

### Enable and debug crossOriginIsolated

crossOriginIsolated を有効にすると `sharedArrayBuffer` など強力な API が使えるようになる（ようは Specter を利用した攻撃を別オリジンのサイトから受ける可能性があるから、ということか）

使うには: cross origin opener policy(COOP)と cross origin embedded policy header(COEP)をつける

Chrome v88 の devtool の application tab で isolated の状況がわかるようになる

### Introducing the Privacy Budget

Browser fingerprint とは: ローカルに install している font の種類などの情報を使ってユーザーを一意に特定する方法のこと

飽くまで、複数の API の戻り値の組み合わせが fingerprint となる。32bit あれば個人を特定しうる。
したがって、利用可能な API が一定の Budget を超えないように制限すれば、開発側が必要な API を選択しつつ、fingerprint に利用されない範囲で利用することができる。

まだまだ研究段階。

### A more private way to measure ad conversions

今まで: 個人を特定するための cookie を 3rd party cookie として送信されていた

基本的には、広告と CV イベントが発火するリンクを特定の ID で紐付けておくと、ブラウザ内に「広告を見て CV したかどうか」の情報が保存され、AdTech 側に CV のレポートのみが送信される、という仕組み。
完全に広告 + CV のユースケースに特化した API（というか具体的には HTML の attribute）

### Sign-up form best practices

- web.dev の記事を読め、ということらしい。
- well known password change page というものがある

### SMS OTP form best practices

SMS OTP 自体には、電話番号の再利用問題などの穴があることに注意！

- OTP に type number を使うな. inputmode="numeric"を使え. Safari も使える
- autocomplete="one-time-code"を使え. Safari に suggestion でるぞ
- origin-bound な format を使うと、ドメインに紐付けられたもののみを選択できる
- `navigator.credintials.get` で API から取ることもできる

## Can I Use

ブラウザ周りの機能について、https://github.com/Fyrd/caniuse をいい感じに watch すれば、新しい機能があったときに、「それは何か」をキャッチできるかも？という気がしてきたので、まずは GitHub の Notification を設定してみる。一旦全 PR ウォッチでいいかなー。

## GraphQL

そろそろアドカレその 1 に着手するぞ。。 まずは https://github.com/graphql/graphql-spec/pull/742/files を読み取って、spec としての defer/stream を調べる。
graphql-js だけでその他の middleware 使わずに実装するところまで。

HTTP の `multipart/mixed` を初めてやった。

合わせて、Relay のコードなど資料読み始めたけど、時間があっと言う間に溶ける。

## Node.js

package.json の `repository` のとこって、`directory` っていうのが書ける？（React.js のコードがそうなってた）

```json
"repository": {
  "type": "git",
  "url": "https://github.com/quramy/hoge.git",
  "directory": "packages/foo"
},
```

## Misc

- [WEB + DB Press vol.120](https://gihyo.jp/magazine/wdpress/archive/2021/vol120) 予約購入。自作 OS x 自作ブラウザっていう言葉に惹かれた

---

# 12/11

## JavaScript

https://github.com/GoogleChromeLabs/estimator.dev

サイトで利用されている JS の改善余地（トランスパイルレベルなど？）を報告してくれるツール。worker で Babel かませてるらしい。

## AWS

AWS 勉強会メモ

- VPC: 仮想的な DC
  - Public subnet に internet facing な resource を配置し、public subnet に internet gateway をアタッチする
  - セキュリティグループ: whitelist, ネットワーク ACL: blacklist
- ELB
  - 冗長化, 負荷分散
  - ALB, NLB, (CLB: 以前のやつ)
  - リスナー: ユーザー側のリクエストを受ける側。ターゲット: 向け先
  - ALB はパブリックにおいて、ターゲットは
- EC2 & ASG
  - EC2 は AMI から起動する
- ECS
  - ECS: 各種サービス、ALB や SSM と組み合わせることが可能。「タスク」「サービス」という概念が出てくる
  - Task: 1 ついじょうのコンテナ. 実行単位。Task Definition で定義する
  - Service: Task を幾つ実行するか、などを管理する単位(Auto Scaling)
  - Cluster: EC2 上で動く service の実行 host. EC2 に ECS Manager を install -> EC2 の管理が発生する
- Fargate: ECS Cluster となる EC2 部分の管理を managed な service
- EKS: k8s をそのまま AWS で動かすための managed service
- ECR: コンテナレジストリ. Public Container Registry としても利用できるようになった(Docker Hub 問題の対応を受けた形)
  - https://gallery.ecr.aws/
- Lambda, API Gateway
  - コンテナ deploy ができるようになった https://aws.amazon.com/jp/blogs/news/new-for-aws-lambda-container-image-support/
- DynamoDB
  - PartiQL: https://dev.classmethod.jp/articles/dynamodb-support-partiql-operation/
- CloudWatch: サービスのメトリクスを記録・監視できる
  - EC2 に agent を仕込んで、CW logs に送信するなど
- X-Ray: tracing のためのツール. Zipkin てきな感じか

## GraphQL

昨日に引き続き、アドカレ用ネタ仕込み作業。コーディングばかりしていてもあまり先に進まないので、一旦 HTTP Transport + データ復元までで止めて、そこまでに対する本文書きに集中することにする。

---

# 12/12

## HTTP

GraphQL の文脈で[MIME の RFC](https://tools.ietf.org/html/rfc2046#section-5.1) を読んだ。ストリームの話のせいでごっちゃになっていたけど、2046 は分割された Content-Type の話であって、これが stream かどうかとは関係ない。逐次送信という意味では、[Transfer-Encoding](https://tools.ietf.org/html/rfc7230#section-3.3.1) の chunked と組み合わせないと意味がない。

---

# 12/14

## GraphQL

引き続きアドカレの defer, stream の記事を書く。ただ、12 日の記事でネタかぶり発生してる。。。。正直あのクオリティで書くの止めてほしかったなー。

## reg

12/12 日の PHP Conference 2020 の資料: https://speakerdeck.com/blue_goheimochi/phpcon2020

> 導入障壁はやや高いと感じている

うーん、多分これ以上下げるのは今の reg-suit のアプローチだと難しいだろうなー。GH Action で提供する、とかそういう方向しか無いんだろうけど、ストレージが無いのよね。

## Misc

Asciinema を久々に触ろうと思ったら、サーバーが完全に落ちてる。

---

# 12/15

## ts-graphql-plugin

https://github.com/Quramy/ts-graphql-plugin/issues/290 の調査開始。

Input Type で循環参照起きてた。ぐぬぬ、、、って感じだ。

```graphql
input User {
  posts: [Post!]!
}

input Post {
  author: User!
}

Mutation {
  addUser(user: User!): Boolean!
}
```

query(というか Selection Set)だと、構造的に循環参照発生しえないから、、、って思ってたけど input だと普通に起き得るパターンなのか。。。

素直に Type Reference に分割して、循環参照チェック入れて直した。

## Relay

Suspense と `useFragment` 的なものと `@defer` の関係について悩みだす。悩む、というよりも GraphQL Client の Cache と、Suspense for Data Fetch があまり自分の中で理解出来てないのが問題な気がする。
雰囲気は理解できてる（はず）なんだけど、じゃぁ自分でコード書け、と言われると全然わからん。

```jsx
const App = () => {
  const result = useQuery("query { post(id: 100) { ...PostFragment @defer } }");
  return (
    <div>
      <Suspense fallback={<Loading />}>
        <PostDetail post={result.post} />
      </Suspense>
    </div>
  );
};

const PostDetail = ({ post }) => {
  const fragment = useFragment("PostFragment on Post { id, name }", post);
  return (
    <div>
      <span>{fragment.name}</span>
    </div>
  );
};
```

こういうコードで何が起きてるのが、全然理解できてないので、https://github.com/relayjs/relay-examples 動かして、Runtime の雰囲気に慣れることにする。

疑問点:

- `useFragment` の第二引数の実体は何？ ただの JSON データではないはずで、Cache から fragment の値を直接取り出すための key になっているべき
- ↑ が正しいとして、その key はどういう構造になっている？

以下、relay-example を debugger で止めつつ、Relay Experimental のコードリーディングメモ。

- https://github.com/facebook/relay/blob/master/packages/relay-experimental/useFragmentNode.js#L32 : `useFragment` の実体。「cache が無かったら promise を throw する」処理が Suspense 関連っぽい
- https://github.com/facebook/relay/blob/master/packages/relay-experimental/FragmentResource.js#L122 : `readWithIdentifier` が実際に fragment のデータを読み出す部分。最終的に `RelayReader#read` を利用している。
- https://github.com/facebook/relay/blob/master/packages/relay-runtime/store/RelayReader.js#L103 : 実際にデータを（多分 cache から）読み出す処理

また、以下のクエリ - フラグメントの構造に対して、

```js
/* IssueDetailRoot.js */

const { node: issue } = usePreloadedQuery(
  graphql`
    query IssueDetailRootQuery($id: ID!) {
      node(id: $id) {
        ... on Issue {
          title
          number
          author {
            login
            avatarUrl
          }
          body
          closed
          url
          ...IssueDetailComments_issue
          ...IssueActions_issue
        }
      }
    }
  `,
  props.prepared.issueDetailQuery
);
```

```js
/* IssueActions.js */

const data = useFragment(
  graphql`
    fragment IssueActions_issue on Issue {
      id
      closed
    }
  `,
  props.issue
);
```

下記のようなオブジェクトが `RelayReader` への selector として渡されていた。

```js
const fragmentSelector = {
  kind: "SingularReaderSelector", // 種別 FragmentResource の中で決定されるっぽい
  dataID: "MDU6SXNzdWUyMzgyNjI1MzY=", // 多分、このfragmentのconditionとなっているObject typeのID。このケースだと、issueのID.
  node: { ... }, // useFragmentの第一引数のGraphQL文字列をAST化したもの(fragmentDefinitionNode)
  owner: { // useFragmentの第二引数である `fragmentRef` の中の `__fragmentOwner` というオブジェクト。この場合だと、IssueDetailRootQuery に相当
    identifier: "...", // このクエリのテキスト表現の末尾に variablesをstringifyした文字列を連結した値(クエリの一意識別子になりうるもの)
    node: { ... }, // クエリのAST
    variables: { ... } , // GraphQLクエリの変数オブジェクト
  },
}
```

## a11y

WAIC って日本の団体なのね。。。 https://waic.jp/

- https://waic.jp/docs/WCAG21/Techniques/ : WCAG 2.1 達成方法集

## Fronend Study

### メタ・パフォーマンスチューニング by yosuke_furukawa

https://speakerdeck.com/yosuke_furukawa/metapahuomansutiyuningu

- AWP: https://github.com/GoogleChromeLabs/AutoWebPerf

### Web フロントエンドのパフォーマンスと、WebAssembly 期待できること、できないこと

https://speakerdeck.com/chikoski/festudy02-wasm

### 高速なメディアを実現するための戦術と戦略

https://docs.google.com/presentation/d/1ZE_95-mflu2yhzEdnYLorXLD2xK_ncjS3DSC6T_d8jc/edit#slide=id.ga7eaabf21f_2_67

## Misc

GraphQL アドカレその 1 は整えて Publish できるように準備まで。明日もっかいチェックしてから流すか。

自社向けのアドカレの 2 発目、何にするかなぁ、、、と思っていたけど、Puppeteer + Coverage の件、どこにも書いてなかったし、それにするかー。土日あれば記事の形にはできるだろ、多分。

---

# 12/16

## React

GraphQL について考える前に、まずは Suspense についてちゃんと素振りしないと。

そういえば v17 使うの初めてかも。折角なので、TypeScript の `--jsx "react-jsx"` も試す。

`createRoot` するために、experimental type をロードしておかないといけない、というのを初めて知る。

```ts
import type {} from "react-dom/experimental";
import { unstable_createRoot as createRoot } from "react-dom";

const App = () => <div>hello!</div>;

const elm = document.getElementById("app")!;
createRoot(elm).render(<App />);
```

### GraphQL Collocation と Render as you fetch

`@defer` が無い世界の場合:

Fetch on render にしろ、Fetch then render にせよ、データが到着すれば、本質的に 1 回の reconcile で rendering される。
Query を root(page component)に集約してあれば、 「データの取得」という行為は中央集権的に行われていた。

```js
// Fetch on render

export const Page = () => {
  const { isLoading, data } = useQuery(query);
  if (isLoading) {
    return <div>Loading...</div>;
  }
  return <div>{/* render props.data */}</div>;
};
```

```js
// Fetch then render

export const Page = props => <div>{/* render props.data */}</div>;

export async function getServerSideProps(context) {
  const { data } = await apolloClient.query(query);
  return {
    props: { data }
  };
}
```

ここに `@defer` が登場すると、そもそもこの directive をどう捉えるか、という話が出てくる。

- (A): `@include` の親戚だと考える。言い換えると、クエリの結果そのものが変化すると考える
- (B): defer された fragment を yield していると考える

既存のアプローチ（Fetch-then-render / Fetch-on-render）から見たときに、(A) は比較的連続的な変化になっているはず。

```graphql
fragment ProductPrice on Product {
  id
  specialPrice
}

query ProductDetailQuery($shouldInclude: Boolean!) {
  product(id: 100) {
    id
    name
    ...ProductPrice @include(if: $shouldInclude)
  }
}
```

のようなクエリがあったとして、下記のような順番で variable を変化させたと思えばよい。

- ページロード時: `$shouldInclude: false` でクエリを取得して render
- render 後: variable から `$shouldInclude: true` に変化させる。結果的に`useQuery` が再度 emit される

`@defer` の場合、クエリの variable に出てくるわけではないが、この `@include` と同じことが起こっている、と考えることはできる。別の言い方をすると、query result が 2 回 yield されている、という解釈。

無論、Root Component から reconcile されていくので、reconcile のコストは大きいし、 `ProductPrice` Fragment に相当する Component はデータが nullable となるので、それに対する null ハンドリングは必要。
とはいえ、 `@include` や `@skip` の延長なので、今までにも同じようなコードを書いた経験もあるだろうし。

Redux の例でいうのであれば、Root Component**だけ**が、store に connect しておいて、後はバケツリレーで頑張るアプリケーションと考え方が似ている。

一方で、(B) の考え方は、今までの既存アプローチとのギャップが大きく、代わりに Render as you fetch との相性が良い。

```js
export const fragment = gql`
  fragment ProductPrice on Product {
    id
    specialPrice
  }
`;
const ProductPrice = ({ ownerKey }) => {
  const { data } = useFragment(fragment, ownerKey);
  return <div>{/* render data */}</div>;
};
```

```js
export const ProdutDetail = ({ productDetail }) => {
  return (
    <Suspense fallback={<Loading />}>
      <ProductPrice ownerKey={productDetail} />
    </Suspense>
  );
};
```

これは、先の Redux の例えでいうと、Root Component だけでなく、様々なところから `useSelector` を許容するパターンと似ている。 `useSelector` には非同期性は無いが、非同期部分は Suspense for data fetch として、 `ProdutDetail` 側で吸収されているので、 `ProductPrice` Component から見たら「データが未到着」という状況は存在しない。

`@defer` / `@stream` の出自を考えると、少なくとも Facebook が見据えている世界は (B) のパターンの方のはず。
React.js の Concurrent Mode Suspense の docs でも、Relay experimental でしか使ってない、という旨が書いてあるし。

まぁ Relay Modern であれば Fragment Container がほぼそのまま `useFragment` に相当しているので、それほどのギャップは無いだろうけど、Apollo Client ユーザーからすると結構な差分があるんじゃなかろうか。

Apollo Client Cache の `readFragment` を使えば似たようなコードが書けるような気がしないでもないが、そもそもそういう作りになってないだろうし、上記の例でいうところの `ownerKey` , Apollo Cache では `${__typename}${id}` に相当すると思えばいいんだろうけど、この「fragment を所有している側から selector 用の key だけを渡す」というのが相当遠いような。

Relay も `fragmentOwner` や `fragmentRef` については compiler で隠蔽しようとしてるし。

Suspense for data fetch と SSR の兼ね合いが分からない、というのもあるので、(A) と (B) のどっちがいいのかはわからない。
SSR は React の Transport が何かしてくれそうな気配もあるけど。

(A) と (B) の構造、ほぼそのまま Apollo v.s. Relay の構造なのよね。この 2 つのいいとこ取りしたような React 向けの Client があればいいんだけど。

## Storycap

Managed mode で正しく CSS animation が off にならない、という件。 https://github.com/reg-viz/storycap/issues/327

前職のときも、何となくその気配あったんだよなぁ。。。preview head html で対応しちゃってたけど。

## a11y

freee の事例: https://www.concentinc.jp/design_research/2020/12/accessibility-freee/

Concent ってとこが a11y のコンサルやってくれるらしい。

## Misc

GraphQL Nexus の 1.0 が正式リリース: https://www.prisma.io/blog/announcing-the-release-of-nexus-schema-v1-b5eno5g08d0b

Yahoo の GraphQL (Nest.js の活用事例）: https://techblog.yahoo.co.jp/entry/2020121530052952/

> GraphQL には、スキーマのサブセットを表現するために fragment という概念があります。

スキーマのサブセットというよりは Selection Set のサブセットじゃないだろうか。

---

# 12/17

## GraphQL

Suspense for data fetch + defer のサンプルを作る。動くとこまで持ってこれた。楽しい。

## reg

reg-suit に Chatwork に notify する plugin の PR が来てる！reg-suit の repository、公開して 3 年くらい経つけど、plugin まるっと PR でもらったのは初めてだ。嬉しい。
殆ど LGTM だったけど、nits なコメントして返した。

## Misc

このご時世に業務で SVN が必要になったので https://b-estack.com/2018/11/06/subversion_mac/ を読んでた。チェックアウトしてみるも、ファイル名に日付やら入ってるしでウンザリしたので途中で止めた。

---

# 12/18

## GraphQL

アドカレその２も草稿書き出す。話の持って行き方が難しいな。おもむろに書き出したら Apollo のダメ出しをする流れになっちゃいそう。

Suspense 周りの考察、 uhyo 君の https://qiita.com/uhyo/items/4a6315bfccf387407631 が色々書いてあって良さそうに見えた。特に `useTransition` については全然知識がない状態なので、ちゃんと身に付けておきたいところ。

## CSS

業務で何かしらの CSS フレームワーク探さなきゃって思ってて Tailwind 触ろうかと思ったけども結局触る時間取れず。

社内の共有会にて、 https://www.w3.org/TR/mediaqueries-5/#mf-user-preferences あたりに書いてある `prefers-reduced-motion` や `prefers-reduced-transparency` など電力消費に合わせたクエリの存在を知る。使いこなすの難しそう。

## TypeScript

社内の LT 用に https://speakerdeck.com/quramy/tsconfig-options-best5 を用意してしゃべった。久しぶりの 5 min LT だったので、高速で喋るパターンで乗り切る（勢いだけで誤魔化すやつ）。

---

# 12/21

## Coverage 関連

3 ヶ月前に作成した storycov がめっきり不安定になってた。

やっぱり `postInstall` で別 node modules にパッチとか当てるもんじゃないな。依存側（ここでは Puppeteer）の build 先のパス変わってるし、patch も合わなくなってるしで全然だめ。

仕方ないので、必要最小限の class を自分の PR から引っ張ってくる。結局生で CDP ぶっ叩いてるのと何ら変わらなくなってきたなぁ。。。

何はともあれ、動かせる状態に復活させたし、サンプル用の Storybook も用意したので心置きなく（？）アドカレの本文執筆ができるようになった。

というか、GraphQL アドカレとか他の仕事のこと考えると、これの記事作成に使える時間が全然無いので、何とか草稿までは書き上げることにした。疲れた。。。

## Storybook for HTML

仕事で生 HTML / CSS 案件出てきたので、レポジトリ作ったりなど。 Storybook for HTML を初めて入れてみるも、触る手前で時間終了。

同じレポジトリに呑気に gulp-postcss の設定入れて、postcss.config.js 置いたら SB 側がぶっ壊れる（多分 postcss-import 入れたから？もしくは SB の webpack が見てた postcss config を override しちゃった？）。
SB、こういうとこが fragile なの、割とイラつくんだけど、どうしようもないわな。。。

---

# 12/22

## React

React Server Components のアナウンス。少し前に聞いていた Flight や Transport の件っぽい。demo アプリに例の react-pg 入ってたし。

https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html

https://github.com/reactjs/server-components-demo

## reg

chatwork plugin の PR が指摘対応してくれていたので merge https://github.com/reg-viz/reg-suit/pull/329

## Storybook

Mobile first で開発するメル時は、以下あたりを設定しておくと捗りそう。

```js
/* .storybook/preview.js */

import { INITIAL_VIEWPORTS } from "@storybook/addon-viewport";

export const parameters = {
  actions: { argTypesRegex: "^on[A-Z].*" },
  layout: "fullscreen",
  viewport: {
    viewports: {
      ...INITIAL_VIEWPORTS
    },
    defaultViewport: "iphone6"
  }
};
```

```html
<!-- .storybook/preview-head.html -->

<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, viewport-fit=cover"
/>
```

## Renovate

特定のレポジトリだけ renovate bot から PR が飛んでこない（TypeScript とか絶対飛んでくるべきなんだけど。。。）なの、おかしくない？

## typescript-eslint-language-service

上記の Renovate の件で bot が何も PR してくれない、というレポジトリがこいつ。

プラグインの読み込みがちゃんと出来てないらしい件もとっとと対応してあげたいが、体力が尽きている。。。

https://github.com/Quramy/typescript-eslint-language-service/issues/49#issuecomment-746049029

## Coverage 関連

アドカレの記事にまとめ上げる件、完了。

---

# 12/23

## AWS のお勉強

マネコンをポチポチしながら Fargate で Docker コンテナを動かす、というのをやってみる。

やってみたいこと: nginx と Node.js の API で通信させる

- Fargate のウィザードにしたがって、ただの `nginx` コンテナが一個だけの ECS クラスタを動かす -> OK
- ECR のレポジトリを作成
  - 1 Dockerfile に対して、1 ECR レポジトリになるのかな？
- 作成した ECR レポジトリに対して、ローカルで用意した Docker image を push -> OK
- ECS 上のタスク定義を更新して、自分で作ったコンテナに差し替える -> NG

サービスは 1 つのまま、元々のタスク定義にコンテナを追加して、これのレポジトリを作成した ECR に差し替えてみるも、起動しない

CWLogs を見ると、nginx がポートに bind 出来ずに起動失敗し続けていて、ECS のサービス側のイベントを見ても start -> registered -> deregistered を繰り返していた（要するに起動できていない）

下記などに記載の「タスクが 1 つしか起動できない」系っぽい。そりゃ当たり前か。。。すでに古いリビジョンのタスクが動いてれば、そいつに固定ポート奪われてるもんな。。。

- https://toris.io/2015/12/a-few-things-i-wanted-to-know-before-playing-with-amazon-ecs/
- https://qiita.com/niisan-tokyo/items/d53afccaff1bf0914f47#%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%8C%E4%B8%80%E3%81%A4%E3%81%97%E3%81%8B%E8%B5%B7%E5%8B%95%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84

### Game day

あっという間に終わってしまった

## iTerm

tmux に切り替えてから数ヶ月たつけど、cmd + n で iterm の新しい窓立ち上げてから、さらに tmux 起動するのもわりと普通にできる？ window ってのの概念がよくわかってなくてまだ慣れない。
もとの iterm window 側で作ったセッションを新しい iterm 側の tmux window の方に引っ張りたいんだけど。。。

https://qiita.com/shoma2da/items/2e68c1e59938eb0c2f83

これを読むと、上記は言葉の使い方が間違ってた模様。やりたいことは「元の session の window を新しい session に付け替える」だ。

## React

GraphQL アドカレ第二弾書ききった。

心残りポイント

- React 用の GraphQL Client 作成しきれてないこと -> これは引き続きやるか...? どうしよっかな。defer の demo というより、Cache 層も含めてやってみたい感はある。
- Server Components との関連をもうちょっと上手くかければよかった
