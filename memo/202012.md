# 12/1

## GraphQL

Cookpad のアドカレ https://techlife.cookpad.com/entry/2020/12/01/093000 を軽く読んだ。

既存の RESTish な API を GraphQL でラップすると、N+1 が容易に発生しそうと思ったが、 Rails 側で利用している https://github.com/cookpad/garage という Cookpad 製の Framework が GraphQL フレンドリなお陰で GraphQL gateway が起きやすい、という模様。

## typescript-eslint-language-service

`@typescript-eslint` v4.9.0 の update で落ちてた。

extra options を作る箇所が原因。

build が失敗した直接の原因は、

```ts
interface Extra {
  projects: string[];
}
```

から

```ts
interface Extra {
  projects: CanonicalPath[];
}
```

に型変更が起きていたため。また `CanonicalPath` は所詮ただの string なんだけど、例の `Phantom Type` 的な hack がされている型。
`CanonicalPath` の生成をしているコードを読むと、glob やらを使った割と泥臭いコードが internal function として書かれていて、「同じ部分をコピーしてくるのか？ダルい...」と思っていたけど、よくよく考えたら https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/typescript-estree/src/ast-converter.ts#L9 にわたす部分だけちゃんと設定すれば後は関係ないことにコードを読んでいて気づく。

## TypeScript

@kazupon さんが作っている Doc 生成系ツール https://github.com/kazupon/api-docs-gen

（tsdoc 使われてないよねーの文脈で教わる）

ts-graphql-plugin で放置している addon の interface 定義を markdown にする部分で使えそうな気配ある。

## Misc

昨日書いた Puppeteer の記事、結局アドカレ化することになるという（上司公認）。。。

---

# 12/2

## GraphQL

アドカレネタ考えないとなー。

- 何かしらの Client lib (state manager) を実装する
- Language Service 実装する（ts-graphql-plugin を zero dependencies にする活動）
- New Relay Compiler のコード読む
- [PayPal のコレ](https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55) 読んで解説

試しに https://github.com/graphql/graphiql/tree/main/packages/graphql-language-service-parser を読み出してみた。
npm の graphql は incomplete な(syntax invalid な) token 列を parse できないので、そのまま使えない。
ので、lang server 側で lexer と parser を別に持つ必要があって、、、というのはわかる。が、パットはどういう実装なのかわからないな。

## Angular

こっちもアドカレネタをそろそろ収集しないと。
ESLint + Angular の何かをうっすら考えていたけど、 https://blog.lacolaco.net/2020/11/angular-state-of-linting-2020/ に最近の status が書いてあって助かる。

> 当初は Angular CLI のデフォルト Linter を ESLint に移行するために、ESLint 対応のファーストパーティ実装を追加する方向で進んでいたが、 すでにサードパーティで存在していて活発に開発されている angular-eslint の意向を尊重し、angular-eslint と連携する方針に固まった。

ネタとしては、Offline Compiler と ESTree の繋ぎがどうなってるか、とかそういう辺りかと思っていたが、`@angular-eslint/template-parser` のコードが薄すぎて読み応えが全然なかった。

ふと「AST Explorer でこの parser が見れたら面白くね！？」って思ったので、これはやってみてもいいかも。PR 出すとこくらいまでは持っていけるかしら。

調べてみたところ、AST Explorer の HTML シリーズに Angular の offline compiler 自体は登録されてたので、そこまでの impact はないかもしれないけど、一応「AST Explorer で Angular HTML の ESTree が見れれば自分でカスタム ANgular Template ESLint rule 作るときに役に立つよ！」という建前は付けられる、のか...?

## ng-japan on air

久々にリアタイで聴く。`@Injectable` の深堀り会で興味あったので。

```ts
@Injectable({ providedIn: "platform" })
class AwesomeService {}
```

のように引数指定が可能ということを知る。 `root` がデフォルトだが、 `platform` とすると platform-browser 全体で 1 つの instance になる。

逆に、 `root` は飽くまで 1 bootstrap に対して 1 個。

基本的に `bootstrap(AppModule)` 自体を複数個の Module に対して実行すること自体がレアケースなので、普段は問題にならないが、angular-elements が出てくると話が変わってくる、ということ。

確かに、elements は Custom Component 相当が bootstrap の対象、すなわちそれ自体が小さい Angular の application として振る舞うイメージなので、複数の angular-elements で作った Custom Component 間で Service を共有したい場合は `{ providedIn: 'platform' }` にしないとバグになるケースがあり得る。

とはいえ、angular-elements を使うということはほぼ Micro Frontent がモチベーションにあると思うんだけど、その場合に全体の DI が Angular way にロックインされるのってどうなの？ってなりそうなのよね。
Lit Element + angular-elements みたいなことをしたいと思っても、angular-elements 側にしか注入されない DI なのであれば「じゃぁ普通に Angular の Module でやれば十分じゃん」ってなりそう。

## CSS

IE を対応ブラウザから落としてれば `width: fit-content;` ってとっくに使えるの、つい忘れがち。

`display: inline-block` に頼っちゃうことが多いんだけど、 block 要素の幅を成り行きに任せたい、というときは一番これが便利なのよね。

## E2E もやつき

先日書いた Puppeteer の ARIA ハンドラの文脈で、E2E のことをもやもやと考えていた。

`@puppeteer/recorder` そのものはあまりにも使い物にならないから、何か Recorder 相当を作りたい欲求が出てきている。

Runner の作りやすさや柔軟性を考えると、出力形式は .ts が良い。ただ、それって飽くまで「俺の欲求」でしかなくて、本当に必要とされているものなのかどうかは怪しいんだよな。
Arlecchino アレを作り出したときは、npm エコシステムの外側に使ってもらうために、シナリオを生 JavaScript ではなくて YAML の DSL に限定したんだった。
Arlecchino は完全に放置していた（というより、Puppeteer + ARIA の話をやるまで忘れきっていた）けど、何もしなくても query に ARIA 書けるんだよね。作っていたときは Recorder は Scope に入れないっていう強い気持ちがあったけど、Remote Object ID の取り回しが良くなってきているし、その部分が 2 年前とは大きく違う。

ざっと想定している要件を書き出すと下記になりそう。

1. Recording 結果を GUI で操作できる
2. 操作した内容を Human Readable な形式で保存、実行できる
3. テキストエディタで保存結果を編集できる
4. テキストエディタで編集後であっても GUI で読み込み・編集ができる
5. 実行結果のレポートやログから、エラー発生時（assertion error / panic 的な error 両方とも）に、シナリオのどの部分で失敗したかが理解できる

理想的には、TypeScript ( or JavaScript）のソースコードそのものをシナリオのモデルとできればいいのか？

擬似コード的に考えると、以下の `login_scenario` は YAML と.ts 表現は等価で、 YAML -> .ts へのコンパイルはさほど難しくない。

```ts
/* login_scenario.ts */

import { scenario } from "@arlecchino/core";

scenario("ログイン", "https://awesome.example.com/login", async ctx => {
  await ctx.waitForFirstIdle();
  await ctx.find("aria/ユーザーID");
  await ctx.$0.type("くらみー");
  await ctx.find("aria/パスワード");
  await ctx.$0.type("zxcvbn");
  await ctx.find("aria/ログインする");
  await ctx.screenshot();
  await ctx.$0.submit();
});
```

```yaml
/* login_scenario.yml */

description: ログイン
url: https://awesome.example.com/login
steps:
  - wait_for_first_idle
  - find:
    query: "aria/ユーザーID"
    action:
      input: くらみー
  - find:
    query: "aria/パスワード"
    action:
      input: zxcvbn
  - screenshot
  - find:
    query: "aria/ログインする"
    action: submit
```

さすがに .ts -> YAML の方向に convert する需要はまぁ無いのでそこは無視する。

多分、.ts における Statement Node を元に、GUI の操作単位だと思えば行けるんじゃないのだろうか。

要件 4. を考えると、下記みたいに編集されたとして、 `myCustomFunction` の Call Expression Statement はもはや「カスタム関数呼び出しステップ」としか言いようがないんだけど、それはまぁしゃぁないわな、っていう感じ。

```ts
await ctx.find("aria/ログインする");

// ちょっと独自処理を追加
await myCustomFunction();

await ctx.screenshot();
```

---

# 12/3

## AST Explorer

昨日思いついた `@angular-eslint/template-parser` を追加するやつ件に着手。
新しく parser を追加するの自体は瞬殺だったけど、AST Node の location 情報を parser 側が ESTree 形式で提供してくれていないのに戸惑った。

template-paresr が公開している `parseForESLint` の戻り値の `services.convertNodeSourceSpanToLoc` で ESTree の location に変換できるけど、自分で traverse するの馬鹿らしいし、そこまで重い処理でもないから default でやって欲しいけど、利用側でやるべきなのかどうかが判断付かないので issue にして回答待ち。 https://github.com/angular-eslint/angular-eslint/issues/209

```js
const {
  ast,
  visitorKeys,
  services: { convertNodeSourceSpanToLoc }
} = parseForESLint(code, options);
```

とりあえず workaround として、自分でも各 node に loc を生やすようにして PRed.

久々に gh-pages 使ったら `The "path" argument must be of type string. Received type undefined` の error message で悩まされた。明らかに Node.js の path module に変なもの渡したときの error だし。

https://github.com/tschaub/gh-pages/issues/354#issuecomment-674552919 に

> This only happens on 3.1.0. 3.0.0 works fine,

とあったので ver 指定して直ったからよかったけど。

## Angular ESLint

AST Explorer の文脈で codelyzer の rule で template 系を眺めてみたけど、 https://github.com/mgechev/codelyzer/blob/master/src/templateAccessibilityAltTextRule.ts とかは割と簡単に ESLint rule 化できそうではある。PR にしてみるか？

## React

仕事で React app の performance tuning をやる。
Redux state に繰り返し構造を持っているような form について、 `<li>` に相当する Component を `React.memo` しているにも関わらず全要素で reconcile が発生してしまう、というやつ。

object な props が幾つかあったので、そのうちのどれかの参照が変わってて、shallow equal じゃ駄目なんだろうなってのは即推察がつくものの、「全部で 15 個くらいある prop のうちどれなんだ？」ってがわからないので、memo の 2nd argument にロギング仕込んじゃうんだけど、もうちょっと賢いやり方ないんかな？

```js
const Item = React.memo((props) => (/* 略 */), (prev, next) => {
  Object.keys(prev).forEach(k => console.log(k, prev[k] === next[k]));
  return false;
});
```

## Relay

久々に @koichik さんと会話する機会があったので、色々と教えてもらう。

- Relay と密接に絡んでいる React の feature で Transport というものがあるらしい
  - React element 相当（JSX の実行結果を json にしたようなイメージ？）を Intermediate Representation にした上で何かしようとしている？
  - `react-transport-dom-webpack` みたいな npm package がある
- https://github.com/relay-tools/relay-hooks Relay 本体の hooks は Concurrent Mode での Suspense for data fetch 専用に作られているが、こちらの package の同名の `useQuery` を使うと、Apollo Client の `useQuery` のように、data, error, isLoading などが同期的に返ってくる signature として使うことができる。要するに React の Legacy Mode でも利用可能。

`@defer` や `@stream` 対応といい、やっぱり React 上での Application Framework としては Relay の方が Apollo Client よりも筋が良さそうに思ってしまう。

久しく Relay 触ってないけど、GraphQL アドカレあたりのネタとしても良さそうかも。

---

# 12/4

## Import Assertion

@Jxck さんの ["CSS Module" をめぐる混乱](https://zenn.dev/jxck/scraps/dc8780fd5b8ea6) を見かけて、Import Assertions という spec が提案されているのを知る。

https://github.com/tc39/proposal-import-assertions

```js
import { data } from "./hoge.json" assert { type: "json" };
```

Module Specifier はただの String Literal であって、suffix に '.json' があろうがなかろうが、それがどのような MIME type なのかを決定できるわけではない。

多分、「.json だから何かのデータのつもりで読み込んだが、それは実際には悪意のあるスクリプト実行だった」というようなことが起こりうる。

「Module を load する側が対象の Module 形式を厳密に指定できなれけば、複数 type の module を安全にロードすることができない」という意味だと思う。
この問題が解決できなかったことで、JSON Modules は（複数のベンダが実装していたが）頓挫している。

- https://github.com/whatwg/html/issues/4315
- https://github.com/WICG/webcomponents/issues/839

「load する側が対象の Module 形式を厳密に指定」のためには、マーカーとなる Syntax が必要になるので、それが Import Assertion の範囲。
Syntax の提供でしかないので、上記の例のような、 `{ type: "json" }` という表記の Semantics には踏み込まない。

たとえば json については [JSON Modules](https://github.com/tc39/proposal-json-modules) のように、別個の proposal として切り出されている。

## GraphQL

spec 眺めてたらそろそろ `@defer` と `@stream` 入りそう？ https://github.com/graphql/graphql-spec/pull/742
graphql-js にはもう入ってるんだよな。

## reg

社内の reg-suit 利用案件で「絶対に差分があるはずなのに passed になっちゃう！」という相談を受ける。
マジかよ、と思いつつ手元で最新の reg-suit 使ってイチからやってみたら再現して冷や汗かいた。

完全には原因を究明できていないが、pixelmatch にわたす Threshold が undefined になってしまうと発動する。
reg-cli の場合、undefined ではなく null 渡しするように CLI を書いていたので気づきにくい構造だった（というより null / undefined で挙動が変わるのもどうかと思うが）。

reg-suit と img-diff-js 側双方に patch 当てる。

## Chrome の Cache Partitioning

Chrome 85 から、リソースの cache のキーに、リソースの URL だけでなく、リクエスト元となるオリジンも使われるようになっていた。

https://developers.google.com/web/updates/2020/10/http-cache-partitioning

知らなかったー。
Cache Hit Rate が下がるが、 Performance 影響はそこまで大きくない、とのことだが、Google fonts など、「ユーザーが別サイトでロードしたことがあることを前提にしていた高速化」は役に立たたなくなるのか。

https://wicki.io/posts/2020-11-goodbye-google-fonts/

タグマネから配信される広告系の SDK とかもそうなのかな？（あの手のやつはクエリに client id みたいのを入れるようになっている気もするけど）

## a11y

自チームで、「運用しているサイトに VoiceOver で読み上げさせた際にどういう課題があるのか」を知るために実際に読み上げさせて聴いてみる会をやってみた。

- そもそも VoiceOver の使い方を知らなかった
- ページ遷移後の navigation イチが header から始まってしまう
  - skip link 案件かな？と思ったけど、 https://weba11y.jp/basics/faq/skip-link/ HTML5 以降の考え方では必須というわけではないらしい。とはいえ、WCAG2.0 達成を考慮するのであれば、あったほうがよいとのこと
- 画像の中身に関する詳細を本文で言及しているけど、alt すら貼っていないので意味が不明
- `・` （中黒）が意味不明の音で読み上げられてる
- validation error が読み上げられていない（role="alert" が抜けている）
- etc...

ちなみに、Chrome 自体の読み上げも試してみたけど、かなり辛い（文と文の切れ目が全然わからない）。

VoiceOver 動かしながら、つい目で追っちゃうけど、全盲の人は本当に音だけから情報を拾ってるんだよな。。。
これ、本当は目隠ししつつ試してみるのがいいのかもしれない。Dialog in the Dark を思い出した。

## React

たまたま @koba04 さんが呟いてんのを見て気になった。 https://github.com/facebook/react/pull/20372

これも `[Flight]` が付いてるけど、もはや意味が全然わからない。。。 Postgres に query 飛ばすのがなんで React に関係あるんだ!??
Suspense for Data Fetch で Postgres にクエリぶん投げるってのは分かるけど、これって transport とかそういう話なのかしら。

やっぱり Flight or Transport が何なのかがわからないと、この PR の意義が理解できなさそうではある。

## Misc

「達人プログラマー」の第二版を購入。物理。 「デザイニング Web アクセシビリティ」も購入。こっちは kindle 版

---

# 12/5

## a11y

「デザイニング Web アクセシビリティ」読了。

書籍としては読みやすかった。扱っているテーマがテーマだけに、読みやすさや文章の平易さにも気を配って書いた、とかそういう背景があるのだろうか？

コーディング的な tips は少なめで、プロジェクト立ち上げ時やサイトデザイン時の留意点に重点が置かれていた。

同じフロントエンドの括りでも、コンテンツ制作系とアプリケーション制作系で気にする箇所が違うと思うけど、両方をカバーしつつ、前半〜中盤をコンテンツ系の話に、後半をフォームなどアプリケーション系の話にまとめてある。

観点や WCAG との対応など、網羅性的な部分も確保されているので、入門書としてよかった。逆に開発ですぐに試せそうな tips の比重は少ないので、そういったテクニックを求めるのであればあまり向かない。

気になる箇所が多いのはやはりフォームまわり。

エラー箇所について、「テキストなどを明確に置いて、どんな環境でも識別できるようにしましょう」とあるが、「それがエラーメッセージであること」を示すための `invalid` や `alert` の話には触れられていない。スクリーンリーダーの章でも特に言及がなかった。
また、「必須項目を明確にする」についても「ラベルの後ろについても『必須』というテキストをつけるのが最も良いでしょう」とあるが、 `aria-required` や `required` といったマシンリーダブルを考慮した説明は出てこなかった。

ここのところ業務でやっている案件のフォーム周りについては考える機会が多かったため、正直「いや、それだけじゃ片手落ちじゃない？」と思ってしまった。コーディング寄りの本も対で出ているらしいので、そっちに書いてあるのかもしれない。ただ、2015 年の本となると、その頃から仕様が変わっているところも多いだろうし、ベストプラクティスを本に求めるのは止めた方がいいかも。

## Angular ESLint

折角なので、codelyzer の Template 用 rule を ESLint 化してみる。

対象は正直なんでもよかったんだけど、難易度が中くらいっぽく見えたので http://codelyzer.com/rules/template-use-track-by-function/ を選択。「`ngFor` 使うときに `trackBy` の指定を強制する」というやつ。

https://github.com/mgechev/codelyzer/blob/master/src/templateUseTrackByFunctionRule.ts が移植元のコードになるわけだけど、これの中身は殆ど理解してない。「あー、正規表現使ってる箇所があるんだなー」程度。

https://github.com/mgechev/codelyzer/blob/master/test/templateUseTrackByFunctionRule.spec.ts を見て、valid / invalid なコードを spec として、それを満たすように ESLint としての rule を組むだけだった。

一番ハマったのは、RuleTester が失敗したときに、jest の child process を跨いで結果を送信する箇所で AST の children <-> parent の循環参照のせいで、jest がよくわからない落ち方をして、どこでテスト失敗してるのかさっぱり分からなくなってしまったところ。

rule の実装そのものは、普通に昨日自分で組んだ AST Explorer を見ながら、esquery で絞り込みを書いていく程度で、余裕過ぎて手応えがまるでなかった。

とにかく、これでアドカレネタとしては十分かな。あとはそれぞれが merge されるのを待つだけだけど、まぁ最悪間に合わなくてもいいや。

---

# 12/6

## Angular ESLint

昨日と一昨日でやったことをアドカレ用の記事としてまとめておく。あとは 12/8 に公開するだけだ。
