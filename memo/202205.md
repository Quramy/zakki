# 5/6

## TypeScript

4.7 の `--module=node16` の挙動など、Node.js 環境での ESM 周りの理解を整理するために、説明用のレポジトリを作成する。

https://github.com/Quramy/ts-node-dual-export-example

nits なネタではあるのだけど、 4.7-beta の blog 時点では `node12` という名前であったが、以下の issue と対応 PR によって `node16` に変更されていた。今日時点だとまだ RC ができていないけど、RC が出ればその変更アナウンスに載るはず。

https://github.com/microsoft/TypeScript/issues/48646

https://github.com/microsoft/TypeScript/issues/46452#issuecomment-95298724 で言及されているように、`moduleResolution=node16` の方が Node.js における Top level await 解禁との兼ね合いが綺麗に見える、という理由っぽい。

自分で example repo を書いてみて感じたこととして:

- Pure ESM の提供であるならば、 package.json に `type: module` を記載した上で tsconfig は `--module=node16` にするのがよい
  - `--module=esnext` でも何とかできるが、import specifier で拡張子を漏らした場合にキチンと警告がでる程度のメリットはある
- ESM / CommonJS の提供を検討する場合:
  - (そも論になるが) 本当にそこまでいるのか？は考えるべき
    - 恩恵を得られるのは、ESM に migrate できないユーザーのみ
    - 基本的に CJS -> ESM の依存が作れないため、.cts, .mts から共用するファイルはすべて CommonJS に compile することになる
    - 大半が cts にしかならないのであれば、dual export する意義も薄いし、利用側にとってもさしてメリットにならないのでは
  - 上記を考慮の上で尚、dual export が必要であれば `--module=commonjs` を付与した tsconfig も用意すればよいだけ

TypeScript の今回の対応でそこそこ効きそうなのは「.d.ts も Conditional Export の対象になる」という部分じゃないかしら。

4.7 以降の ts であれば、package.json に以下のように書かれていれば、適用させる Type Declaration を Node.js の Entry Point の判別に即して切り替えることができる。

```json
{
  "name": "@types/hoge",
  "types": "lib/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./lib_esm/index.d.mts"
      },
      "require": {
        "types": "./lib_cjs/index.d.cts"
      }
    }
  }
}
```

この恩恵が一番わかりやすいのが `@types/node` だと思うのだけど、DT の issue / PRs を軽く検索した感じ、関連するものがなさそう。

```ts
import fs from "fs";

// このファイルがCommonJSとして扱われるのであればOK, ESMとして扱われるのであればerrorにしたい
console.log(__dirname);
```

逆にこの機能が足枷として作用するケースもあり得る。

結論を先に書いてしまうと「Type declaration の出し分けが可能になる」に付随して「利用しているパッケージが正しく Type declaration を出分けていないと、利用する側で不都合が生じうる」という話。

具体例を考えてみる。とある npm package `hoge` が以下のように構成されていたとする。

```json
{
  "name": "hoge",
  "main": "index.js",
  "types": "index.d.ts",
  "exports": {
    ".": {
      "import": "./lib_esm/index.mjs",
      "require": "./lib_cjs/index.cjs"
    }
  }
}
```

この package を使っている側が、ts 4.6 までであれば、以下のコードは問題なく compile される。

```ts
/* main.ts */
import * as hoge from "hoge";
```

しかし、上記のファイルを `module: "node16"` として扱おうとした場合に、以下の問題が起きる

- Node.js の世界では `./lib_esm/index.mjs` は利用可能なのでランタイム上は問題ない
- TypeScript 4.7 の世界においては `./lib_esm/index.d.mts` のファイルが存在しなければ、 `./lib_esm/index.mjs` の型定義が解決できずにエラーになる

このシナリオについては https://github.com/microsoft/TypeScript/issues/46334 で議論されており、方向性として「トップレベルの `types` を exports map の各 block に merge するようなことはしない」となっている。

これは、Node.js における Conditional Export が*明示的に* エントリポイントを指定する機能であるため、その考え方に準じてのこと。

したがって、このシナリオに遭遇した場合、依存パッケージ側で、ESM のエントリポイントが利用されるときに型定義の場所も明示するように修正する必要が出てくる。

手元で雑に確認した感じ、以下のどのパターンでも修正として動作している。
[synckit が module: node12 で動作しない件](https://github.com/microsoft/TypeScript/issues/46408) も根本的には同じ話っぽいんだけど、Author の人曰く「この修正でもだめだった」と書いていてるのが若干不可解ではある。

```js
  "exports": {
    ".": {
      "import": {
        "node": "./lib_esm/index.mjs",
        "browser": "./lib_esm/index.mjs",
        "types": "./index.d.ts",
        "default": "./lib_cjs/index.cjs"
      },
      "require": "./lib_cjs/index.cjs"
    }
  }
```

```js
  "exports": {
    ".": {
      "import": {
        "node": "./lib_esm/index.mjs",
        "browser": "./lib_esm/index.mjs",
        "default": "./index.js"
      },
      "require": "./lib_cjs/index.cjs"
    }
  }
```

```js
  "exports": {
    ".": {
      "import": "./lib_esm/index.mjs",
      "require": "./lib_cjs/index.cjs",
      "default": "./index.js"
    }
  }
```

```js
  "exports": {
    ".": {
      "import": "./lib_esm/index.mjs",
      "require": "./lib_cjs/index.cjs",
      "types": "./index.js"
    }
  }
```

いずれにせよ、「自分がパッケージを提供する側として、Pure ESM にする目的で `module: "node16"` を試せる状態であったとしても、依存する npm パッケージ側が対応していないと積むケースがある」という意味では、この機能は foot gun になり得る。

cjs が不要なのであれば、 package.json に `type: "module"` を指定しておき、TypeScript 上は `module: "esnext"` にしておいても十分成り立つ訳だし、やっぱり使い所が難しい機能だよなぁ、これ。。。
