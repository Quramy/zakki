# 10/1

## ts-graphql-plugin

https://github.com/Quramy/ts-graphql-plugin/issues/147

クエリが引数を許容しないのであれば、そもそも variable 用の type を出力しない方がいいかもな。

## Others

変に Component の内側で impedance mismatch を吸収しようとすると、碌なものにならない。可読性やテスタビリティ的にも良いことない、というのを身を持って学ぶ。
理屈としては分かってるんだけど、ついいじる箇所を最小限にしたくなって、、、という囁きに騙されそうになってしまう。

---

# 10/2

## Semantic な form

aria-invalid のような属性や、HTML 標準の `required` 属性など、form をセマンティックに扱うための仕組みを使いこなせていなかったな、と反省。

これらの知識が最初からあったして（実際に `required` は知っていたし）、最初からそれを組み込めたのか、というとやはり厳しいだろうし、いきなり 100 点が取れるわけでもないと思う。

下記のようなアプリケーションコードを書いていたとして、

```tsx
<Form onSubmit={handleSubmit}>
  <label>
    PostalCode
    <Input
      name="posal_code"
      onChange={handleChangePostalCode}
      value={postalCode}
    />
  </label>
</Form>
```

ある日、 `input[name="posal_code"]` に対して、 `autocomplete="postal-code` を一気に付与したい、というようなケースがあったことを考える。
ここでの `autocomplete` 属性は一例であって、何某かの `aria-` かもしれないし、別の属性でも構わない（要するに SPA 開発者が忘れがちな属性、ってとこがポイント）。

愚直な書き方であれば、郵便番号を扱っているすべての箇所に、下記を追加して回ることになる：

```tsx
<Input
  name="posal_code"
  onChange={handleChangePostalCode}
  value={postalCode}
  autocomplete="postal-code"
/>
```

form に関する知識、すなわち「`postalCode` という値は郵便番号である」という情報と、 「input タグに`autocomplete="postal-code"`を付与したい」という欲求は密接に関連していると思うんだけど、この関連性と「状態は State management, DOM は JSX」という分離の相性が余り良くない。

「form に関する情報 -> HTML 属性の付与」という機構を最初から備えておければ、後からの属性追加についても、アプリケーション全体への影響は最小限にして進められるんじゃないか、という期待。Headless UI Component のパターンでそれができる？

よく出来た form ライブラリの設計を読み解いてみたい

https://www.merrickchristensen.com/articles/headless-user-interface-components/

https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#attr-fe-autocomplete

## Others

Puppeteer に出した PR にレスポンスがつかなくて悲しい。。。 :sob:

やることが思い浮かばないので、 https://github.com/reg-viz/img-diff-js の TS 化に着手。
合わせて AVA -> Jest, GH Actions の導入などもやる。reg-suit でもやった作業だし、今回はそもそものソースコードが少ないので余裕で終わった。renovate も突っ込んだ。

PR のコメント欄にて。"wdyt?" ってなんだろう？って思ったけど、 "What Do You Think (WDYT)" か。小文字で書かれるとより分からない！

---

# 10/3

---

# 10/4

https://tsconf.io/index オンライン開催か。。。 \$39 ね、、、悩まし。

---

# 10/5

## Coverage 関連

webpack で bundle した sourcemap の場合にどうなるのか、というのをやってみる。
istanbul の出力はでるものの、report が生成されない。 `CoverageMapData` の path の値として、webpack モジュール内での module ID 的なのになっていて、src ファイルとの紐付けが出来ないのが問題っぽい。
src のディレクトリを指定させる、というやりかたと、sourcemap の `sourcesContent` から復元するのとどっちがいいのかしら。 https://sourcemaps.info/spec.html
Storycap 文脈だと、delpoy されてるサーバーに対して、っていうパターンがあるし、sourcemap のコンテンツから復帰させる方がよさそうではある。

https://github.com/Quramy/puppeteer-coverage-study に実装してみた. convert-source-map に同梱されてる SourceMappingURL 取得する正規表現が先頭一致でコメント返してくるのにハメられる。
手元の Storybbok でも coverage 取れたし、PoC としては一通り完了。後は Puppeteer に PR が merge されるのを待つばかり。。。

## Others

vim-twiggy で、 `fix/1234` みたいな branch 名だとうまく pull できないなーと思ってたらバグだったので PR 作成。 https://github.com/sodapopcan/vim-twiggy/pull/36

TS Conf 申し込んだ。

headless UI 、これを見たら理解を深められるかしら？ https://github.com/tailwindlabs/headlessui

TypeScript で使えそうな ORM いろいろ。 Prisma が書いた blog なので、そこは念頭に入れて読んだほうがよさげ。 とはいえ Bookshelf.js とか MicroORM とか、初見のものも多いなぁ。 https://www.prisma.io/dataguide/database-tools/evaluating-type-safety-in-the-top-8-typescript-orms

---

# 10/6

## Coverage 関連

「Puppeteer の Coverage のとり方分かったら、後は Storycrawler に突っ込めばとりあえず SB の Coverage 取れるじゃん！」というのに気づく。
ありものを組み合わせるだけだったので一瞬で実装できた https://github.com/Quramy/storycov

## form もやつき

https://react-hook-form.com/ の getting started 辺りを読み出してみる

### Controlled v.s. Uncontrolled

react-hook-form が ref 使う(i.e. uncontrolled)であり、rerender 観点で performance メリットがあるとのこと。 https://react-hook-form.com/faqs#PerformanceofReactHookForm

- https://reactjs.org/docs/forms.html#controlled-components
- https://reactjs.org/docs/uncontrolled-components.html

これはまぁわかる。

"How to create an accessible input error and message?" ( https://react-hook-form.com/faqs#Howtocreateanaccessibleinputerrorandmessage ) の方だけど、「uncontrolled だから accessible な form が作りやすい」ってどういう理屈だろう？ controlled だろうと uncontrolled だろうと、あまり関係無い気がするんだけど。。。「hooks 経由で error オブジェクトが取れるから、それで `aria-invalid` を設定すればよい」と言っている？

## Others

Renovate 入れるようになるとリリースノート見るようになるなー、と思った（ typescript-eslint の rule 等眺めるので。あと Renovate の更新通知、 `@types/node` とかだと、複数の repository に片っ端から通知くるので、こういうのは GitHub の notifications から回って merge していくと効率的だ。

https://github.com/matteobruni/tsparticles 粒子描画系のライブラリ。ts 対応、各 UI(React, Angular, Svelte, etc...)対応もしている。使う機会あるか？ってのはあるけど。

新しく作った GitHub の repository に、ターミナルから `git push origin master` ってやって通らなくて、twiggy からだと push できるの何でだ！？ってなってたけど、よくよく考えたら not master but main じゃん。

---

# 10/7

## 生タグと CSS

`:first-of-type` って、少なくとも Component のトップレベルで使っていいセレクタじゃないと思った。

```tsx
/* components/CompA.tsx */
export const CompA = styled.div`
  &:not(:first-op-type) {
    margin-top: 16px;
  }
`

/* components/CompB.tsx */
export const CompB = styled.div`
  &:not(:first-op-type) {
    margin-top: 16px;
  }
`

/+ components/App.tsx */
const App = () => (
  <div>
    <CompA />
    <CompB />
  </div>
)
```

みたいな感じになってるとして、 `CompA` `CompB` に margin が付与されるかは、お互いの内部実装(=div タグであること)と結合してしまっていて、後からタグを編集すると CSS が壊れる

```
/* components/CompB.tsx */
export const CompB = styled.section`
  &:not(:first-op-type) {
    margin-top: 16px;
  }
`
```

ここまで書いて思ったけど、「自分が他の要素とどういう間隔で配置されるか」を自分で制御するのって間違ってるよな。。。

じゃぁ毎回、配置側で `styled(CompA)` みたいなことすんの？っていうのはバカらしい（emotion に insert される style タグもその分増えるし）。

Utility First CSS を持っておけば十分と思う。
以下のようなのを用意しておいて、

```css
/* util.css */
.mt-1 {
  margin-top: 8px;
}
.mt-2 {
  margin-top: 16px;
}
```

素直に class として使えばいい。

```tsx
const App = () => (
  <div>
    <CompA />
    <CompB className="mt-2" />
  </div>
);
```

emotion と util class が混在するのどうなの？という反論もありそうだけど、既存の CSS を utility で拡張するパターンも言及されている。

https://blog.usejournal.com/utility-first-css-ridiculously-fast-front-end-development-for-almost-every-design-503130d8fefc

> But even when you use other frameworks like Foundation or custom CSS, you can extend them with your own utility classes.

## 型パズル

ふと Union to Intersection のことを思い出した。 type-dungeon に追加するか。
理屈は https://qiita.com/suin/items/93eb9c328ee404fdfabc#comment-5218b3e9d13d93dfc98f がわかりやすい。こういう解説を書かせたら流石、という感じ。

## 英語

https://github.com/puppeteer/puppeteer/pull/6454 の件にて。

LGTM くれたけど merge してくれない、、、っていう状況が初めてだったので、英語でなんて書けばいいんだろ？ってなったんだけど、 https://www.englishforengineers.jp/post/122255688100/%E6%8A%95%E7%A8%BF%E3%81%8A%E9%A1%8C%E3%81%93%E3%82%8C%E3%83%9E%E3%83%BC%E3%82%B8%E3%81%97%E3%81%A6%E3%81%BB%E3%81%97%E3%81%84%E3%82%93%E3%81%A0%E3%81%91%E3%81%A9 に良いアドバイスが。

> 文章としては同等だったり、ニュアンスの差が云々という分析はできるとおもう。でもあくまで「マージしてほしい！」という実用性から考えるとこういう場合は「丁寧な英語を書く」より「何をして欲しいかはっきりわかる英語を書く」を主眼にしたほうがいいのではないだろうか、と思います。なので”Can you please merge this?”推し

確かに、「失礼にならないかな。。。」って考えちゃうけど、俺は「merge してほしい！」って本心では思ってるわけだし、今回は approve ももらってるわけだから、変に婉曲した表現しても仕方ないもんな。

## Others

https://github.com/Quramy/ts-graphql-plugin/issues/117 で「Template Literal Type 使わないの？」って無邪気に聞かれたけど、まぁ絶対に使わない。遊びならともかく、自動生成コード排除する目的だけのために型だけで再帰下降パーサー用意するとかどう考えてもおかしいだろ。

HTML の role 属性眺める: https://developer.mozilla.org/ja/docs/Web/Accessibility/ARIA/ARIA_Techniques
a11y 周り、何からやっていけばいいのかわからん、ってなるな。。。

この雑記帳、10 月の 1 週分が溜まったわけだけど、200 行 over か。1 ヶ月分貯めることを考えてたけど、1000 行とかになっちゃうのもちょっとやだな。。。

---

# 10/8

## Coverage 関連

ふと https://github.com/istanbuljs/nyc/blob/master/docs/setup-codecov.md や https://docs.codecov.io/docs/supported-report-formats#exhaustive-acceptable-report-formats を読んで、codecov に送信している report ファイルのフォーマットを別のものに変えたら、ちゃんとした結果に変わるかもしれない、と思い ts-graphql-plugin で試す。

今まで istanbul の json を送ってたけど、よくよく読んでみたら istanbul の json 形式に対応してるとはどこにも書いてないし、nyc の記載みても `--report lcov` ってなってた。

結果見ようと思ったらちょうどたまたま codecov が落ちてて運が悪い。

再 push したら codecov の画面から見れるようになったけど、やはり違う結果になってしまうので close

## Others

Safari って `<img src="hoge.pdf" />` 表示できるのか。。。 PDF のインラインプレビューに使える？って一瞬思ったけど、複数ページだめだし、まぁ止めとけって感じだ。

autocomplete 属性を眺める。 https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute

https://github.com/boa-dev/boa Rust で書かれた JavaScript interpreter らしい。自作言語の勉強に、、、と思ったけど、どうコード読んだらいいのかわからん。。。

「実践 Rust 入門」と「Web API の設計」の物理本を購入。

[これ](https://dev.to/_pthomann/how-i-lost-1-year-of-life-doing-failed-crypto-startup-5hlp) を読んでいたら、"whale" というのが仮想通貨界隈で特別な意味をもつ、というのを知った。 https://en.bitcoinwiki.org/wiki/Whales

---

# 10/9

## Emotion でハマった件

別に emotion が、、、というよりは「margin は親で」って言いたいだけのやつ。ちょっと人前で話せるようにまとめておくか。

流れで教えてもらった https://emotion.sh/docs/ssr#advanced-approach について調べておきたい。特に Next.js と組み合わせられるか、について

## Istanbul について

Coverage の流れでふと istanbul というツールの立ち位置について調べる

初代はここ: https://github.com/gotwarlost/istanbul
おそらく、Babel よりも古くから存在していそう。

これを後継しているのが、いまの Istanbul JS https://github.com/istanbuljs

細かいコードまでは読めてないけど、スクリプトを書き換えて計測パーツを埋め込んだ状態でスクリプトエンジンにわたす仕組みになっているのは一緒。

istanbuljs になってからもしばらくは babel 版ではなかったが、現状は babel による transpile を nyc の内部でやっている。このコア部分をラップしたのが babel-plugin-istanbul なので、どのようなコード変換なのかはコイツだけを config にして babel-cli 回してみるのがわかりやすそう。今度やってみるか。

ここで気になってきたのが、jest + ts-jest の構成で、この場合だと transform は ts-jest の TypeScript の transformer を適用させる形になると思うんだけど、istanbul 用の instrument（計器、的な意味合いかな？）は誰が差し込んでくるんだ？ってところ。

- ts-jest が TypeScript custom transformer で istanbul 互換な処理を行っている
- jest が transpiled なコードをさらに babel-istanbul にかけて、多段 transpile している

のいずれかだけど、多分 coverage 部分を jest が担保したい、という構造から考えると後者の設計になるのかな。
だとすると、jest の transformer って ts-jest より `@babel/preset-typescript` の方が早い可能性あるよな（jest が babel 優遇してた場合だけだけど）。

ついでに「なんで Istanbul っていう名前なんだろ？」って思ってたけど、

> coverage といえば carpet area(まずこれが日本の家事情からするとピンと来ない)、良い carpet を作っていそうな所といえばイスタンブール、という連想

と

> They Might Be Giants の曲に Istanbul ってタイトルのがあるんだけど、この曲の一節で “old New York was New Amsterdam”ってのがあって、だからコマンド名は nyc

という絶対に答えしらないと想像つかないヤツにたどり着いた。そして tweet についたリプに吹いた https://twitter.com/kawasima/status/1314567700597751808

## Others

https://github.com/davidkpiano/xstate ステートマシンの考え方で状態制御を行う、が思想の state manager らしい。結構 star ついてるけど知らなかった

https://blog.uedder.com/develope-java-with-vim.html vim-lsp で Java する設定

（多分）自分で書いたコードの中に `new Date()` がいるせいで、snapshot テストが時間差で落ちる現象に遭遇。よくないなぁ。。。

Cache-Control ヘッダに stale-if-error という仕組みがあることを知る。 stale-while-revalidate と似ているが、こちらは 「新しいレスポンスのチェックに失敗した場合に、クライアントが古いレスポンスを受け入れることを示します。」とのこと。

---

# 10/10

## TS Coonf 2020

### (discussion chat)

Orta に教えてもらった: https://www.typescriptlang.org/dt/search?search=

> BTW, is `awaited` keyword feature dropped ? (by TS 4.1, recursive cond type allows Awaited type )

に対して Ryan Cavanaugh から ↓ を教わる

> `awaited` is unlikely to be added as a primitive type operator now that it can be expressed in terms of "normal" type operations

### keynote by Anders Hejlsberg

#### Survey

TypeScript もう 8 歳

簡単に初められるように。jsdoc との統合や、JavaScript の lang service を触れるように、など JS ユーザーにも優しくしてきた
community に立ち寄っている

DL は 60M / month

PR が多い順の言語で言うと、JavaScript が 1 位, TypeScript は C++と同程度で 6 位。
Stackoverflow のサーベイで好きな言語は？に対して、TypeScript は Rust に続いて 2 位

#### コミュニティの動き

- babel: ??(聞き逃した
- tslint やめて ESlint community とやっている件。 typescript-eslint を初めた
- deno: built-in typescript, 良い project だ
- UI framework: Angular, React, Vue 3 in typescript, ember, svelte
- Playground: 午後の orta のとこで！
- DefinitlyTyped: type publisher の件(もう 4 年前か...)、めちゃくちゃ PR 来てる、

#### what's new

- ES new features (Optional chain, Nullish coalescing, private field, top level await, logical assignment operator)
  - private field の down leveling demo. weakmap になるやつ
  - logical assignment op: `a ||= b` は `a || (a = b)`
- new type system features
  - Type Only Imports
  - Variadic Tuple Types
    - fix に 5 年かかったらしい。
    - 3.0 で出した Rest Parameter Type 周りのやつで、末尾要素の spread はできたけど、途中の spread `[string, ...T, number]` みたいな）のはできなかった
    - Head, Tail, Init, List の Utility Type も作れる
    - 関数に値を bind する例
  - catch type にアノテーション触れるようになった（知らなかった）
- new tooling
  - `@deprecated` や partial semantic mode（正直よく分からなかった）

#### what's next

- Recursive Conditional Type
- Template Literal Type(組み合わせ爆発するデモある)
  - promisify で Callback 型の関数名に(Mapped Type と組み合わせて) `****Async` とする例
  - object path coordinate (`"a.b.c"` みたいなのを与えるやつ）
- String Case Utility Type (これちゃんと Utility Type になったんだな. keyword はイケてないと思ってたし)
- `--noUnchekedIndexedAccess` 存在確認せずに `arr[i]` のアクセスを禁止する（これいいな）

demo のスニペットは https://github.com/ahejlsberg/tsconf2020-demos から確認できる

### Type System Game Engine

Tic Tac Toe（三目並べ）を型で表現する話。（興味が無かったし、全然聴いてなかった）

### Pushing the Compiler to the Limit by Tim Suchanek (prisma の開発者)

Prisma の紹介から。Database アクセスを行う「夢の API」を考え始める。GraphQL のように DB にアクセスできるような TS API を夢想。

Conditional Types や Mapped Types を工夫しようとする？

手で作った型 ↓ を拡張するプランを試してみた(↓ みたいなやつを Conditional Type, Mapped Type で拡張して API の型定義を作れないか？）

```ts
type User = {
  id: number;
  name: string;
};
```

でも type safe には簡単には出来なかった。

そして Prisma2 の preview を出す
model （schema 定義）から、javascript と TypeScript 型定義を生成した。 裏側でかなり複雑な Conditional Type を作る実装

#### Generated Code の最適化

これってホントにスケールするのか？という部分に取り掛かる。
300 テーブル、5,150 カラムあるような例。
生成に 26s かかる上に、23M の.d.ts ファイルと 25M の.js ファイル。これを起動するのもかなり時間がかかる。

生成される d.ts の書き方を工夫して、生成後サイズを 15M に落とした！

index.ts を吐いた上で、これをさらに d.ts と.js に tsc で変換していたが、.d.ts と.js を直接生成するようにし、生成時間を 4sec に軽減

でもまだ js がデカいし、起動が遅い問題は残る。
これは bootstrap コードだけにして改善させた（これどういうことだ？、それまで生成してたコードの代わりになるものはどこにいった？Prisma engine 側か？）

↑ の部分、speaker の Tim Suchanek にチャットで質問してみたところ、

> I couldn't have explained it better. The code I showed is 100% implemented in JavaScript and stays in JavaScript. The Rust engine is only responsible for resolving the queries.
> The TypeScript implementation and Rust implementation started at the same time, last year in January. The types for the ORM are generated by Rust and consumed by the JS part, translated into TypeScript.
> Under the hood we have an internal type system, which both TS and Rust speak (it's a serialized JSON format), which TS can then use to generate the client
> As the TypeSystem is language agnostic (inspired by GraphQL), it can be used by any other language. That's why we not only have the TS client, but also a Go client in preview.

とのこと。この文脈では Rust は関係なく、純粋に JavaScript レイヤの最適化らしい。

#### .d.ts のサイズを落とした工夫について

↓ のパラメータ部分の型定義が無駄にコード量を増やしていた

````ts
UserModel.find({
  select: { // これ
    id: true,
  }
})
```

Model 型から、select 用の必須プロパティの key を列挙するテクニックを活用することで解決させた。

```ts
export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
````

こうすると、 `type UserParamsType = RequiredKeys<User>` みたいにできて、コード量減らせた。

### Lessons Learned Converting Sync Codebase to TypeScript

(興味ないので全然聴いてない)

### Adding Augmented Reality to Your TypeScript App

Babylon.js の話など。
(TS 関係無くね？っていう感じの内容なので、真面目に聞いてない)

## Others

TSConf の RequiredKeys のやつ、type-dungeon に書いておくか

---

# 10/12

## ts-graphql-plugin

webpack が 5 になったことで、webpack plugin のテスト落ちてるな。。。

## Others

（たまにしか触らないからだけど） IDEA の使い方よく分からん

---

# 10/13

## 読書

「実践 Rust 入門」と「Web API の設計」読み始める。

「CSS 設計完全ガイド」も購入。

## CSS 設計

「Component 志向で解決されない部分」を考えたくて https://github.com/hiloki/flocss を見てみる。
ちゃんと読んだことなかったけど、「Component」 の説明にも、

> 出来る限り、最低限の機能を持ったものとして定義されるべきであり、それ自体が固有の幅や色などの特色を持つことは避けるのが望ましいです。

とある。

また、「CSS 設計完全ガイド」にも以下のようにある。

> モジュール自体にはレイアウトに関する指定は基本的に行わないことがベストプラクティスになります。
> 「レイアウトに関する指定」とは、具体的に
>
> - position
> - z-index
> - top / right / bottom / left
> - float
> - width
> - margin

「上下余白の margin についてどうするか？」はそれでもやはり議論になりがちかもしれない。

- 標準 margin 持たせちゃうよ派
- Utility Class で頑張るよ派

が選択ポイントかな、とは思う。折衷案として、

- heading 系の Component については `margin` を入れてもいいよ派

とかもあるけど。

heading は後続にコンテンツが続くことが前提なので、margin-bottom を持つのは許されるとして、例えばカードのような Component ではそうもいかない。
じゃぁ `:first-child` なり `:last-child` まで Component の内側に書くのか？それって flex と組み合わせられるの？みたいなことを考えるくらいなら、Utility Class で良いのでは、と思ってしまうけど。

開発の(多分初期)で「やっぱり gutter 見直したい」みたいなことを言われてた場合に、つらいのは Utility Class の方なんだよね。。。
あるべき論では Utility Class なんだけど、実際問題悩ましいよなぁ。。。

## Rust のお勉強

実践 Rust 入門の写経初めてみる。どこまで続けられるのやら。。。

まずは逆ポーランド記法の評価から。

## Vim

Rust 本の流れで debugger を設定してみることに。長年逃げ続けてきたやーつ。

いくつかプラグインの候補はあるみたいだったけど、Star も多いし、CodeLLDB を Rust デバッガのアダプタとして使う、Chrome(多分 CDP?)にも attach できそう、といった具合に色々すごそうなので vimspector https://github.com/puremourning/vimspector を導入してみる。

いくつかドハマリ。

- 起動した瞬間に python のエラー: 例によって python2.7 がデフォだから？とか思ったけど、そうではなかった。 `LC_CTYPE` を明示的に export したら直るやつ。 https://qiita.com/uasi/items/d91b77a55280e4002aae 助かった。
- .vimspector.json をどこにどう置けばよいのかがよく分からん。project root でもいいし、directory の階層をさかのぼって上の方に traverse するみたい。とりあえず HOME に置いてみた

Node.js の簡単なスクリプトは Vim からデバッグできるようになったけど、そもそもデバッガをキーボードで扱うのが不慣れ過ぎて戸惑う。一応 Visual Studio のキーマップらしいんだけど。。。

## Others

https://webpack.js.org/blog/2020-10-10-webpack-5-release/#major-internal-changes ts-graphql-plugin で Renovate こけてるの、ここ見れば見当つくかしら？

久々に Vim を build した。以前にどんな config でやったっけ？ってなったけど、 src/auto/config.log に前回 configure のログ残ってることを初めて知る
