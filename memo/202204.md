# 4/4

## React.js

v18 出ちゃってるけど、 https://reactjs.org/blog/2022/03/29/react-v18.html をちゃんと読まねば。。。

---

# 4/5

## GCP

Cloud Pub Sub 、名前くらいしかしらなかったけど、利用方法のイメージが大分湧いてきた。

https://cloud.google.com/pubsub/docs/pull

## DB

外部キー制約貼ったときに、自動で index が貼られるのかそうじゃないかというのは製品ごとに異なる。

例えば、MySQL は暗黙的に index が作成されるが、PostgresSQL はそうじゃない。

なぜコレがきになったかというと、 Prisma のような、別言語で「model 定義を書いたら自動で migrate が発行される」類の OR マッパーでの外部キー制約と index の扱いが気になったため。

---

# 4/6

## チームビルディング

https://agile-monster.com/blog/5minutes-inception-deck/

## Prisma

MongoDB 向けの Connector が GA になる模様。

https://www.prisma.io/blog/mongodb-general-availability-pixnun6mffmu

---

# 4/7

## TypeScript

@uhyo さんの本が技術評論社から出版されるらしい。

https://gihyo.jp/book/2022/978-4-297-12747-3

同じく @uhyo さんの Qiita の記事。4.7 の新機能たる Module Suffix の解説だが、とても良い。

https://qiita.com/uhyo/items/22d851c3cbd2570864ce

## Storycap

@yamanoku さんより、「MSW + Storybook + Storycap の構成で CI がハングするケースがある」という報告を受けた。

https://twitter.com/yamanoku/status/1512071937681682434

おそらく、Storycap の `ResourceWatcher` に何かしらの考慮漏れがありそうな気がしているが、いかんせん Service Worker の理解が足りなさすぎて何もわからん。

## Ruby

本業でも副業でも Rails だらけになってきた。何年経っても書けないし、ちゃんと読めている自信も付かないのに、雰囲気で何とかしようとしまっていて良くないなー と思う。

## Misc

https://github.com/gayanvoice/top-github-users/blob/main/markdown/public_contributions/japan.md に自分の名前が載っていた。そこそこ上の方。follower が 100 人強いると日本で Top1000 扱いされて、ここにリストアップされる仕組みっぽい。だから何だ、というのはあるが、多少の励みにはなる。

---

# 4/8

## Micro Services

久しぶりに Architect 的な方式設計に頭を費やす。

https://microservices.io/patterns/index.html に色々な設計パターンの名前が載っていた。

とっくに知っている物も多いが、Reference として約に立つときがあるかも。

---

# 4/12

## JavaScript

Type Annotation の proposal についてざっと読む。

- https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/
- https://github.com/tc39/proposal-type-annotations

薄々理解はしていたが、Semantic ではなく Syntax の話だった。

JavaScript のエンジンが以下のような構文を parse でき、且つ Type Annotation に関する部分を strip できるようにする、というのが主題。

> It’s worth mentioning what this proposal isn’t.
>
> Our team isn’t proposing putting TypeScript’s type-checking in every browser and JavaScript runtime – nor are we proposing any new type-checker to be put in the browser. We think doing that would cause problems for JavaScript and TypeScript users alike due to a range of issues, such as runtime performance, compatibility issues with existing TypeScript code, and the risk of halting innovation in the type-checking space.
>
> Instead, we’re just proposing syntax that is compatible with and motivated by TypeScript, which could be used by any type-checker, but which would skipped over by JavaScript engines. We believe that this approach is the most promising for everyone, and would continue to allow TypeScript, Flow, and others to continue to innovate.

TypeScript と同等の型チェックを JavaScript ランタイムに求めるわけではない、というところがポイント。

例えば以下のコードは、TypeScript としては Error 扱いになるコードだが、JavaScript から見たらそもそも Syntax エラーで parse できない。

```ts
const a: string = 100; // compile error
console.log(a.trim());
```

上記のコードが以下と等価であるように評価してもらおう、という発想。

```js
const a = 100;
console.log(a.trim()); // runtime error
```

## TypeScript

4.7 beta が出ていたので、いくつか調べておく。

https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/

目玉は `--module="node12"` の部分だろうか。

そもそも mjs とか cjs ってなんだっけ、、、については、 @hiroppy の https://blog.hiroppy.me/entry/nodejs-experimental-modules を復習で読む。

## Vim

TypeScript に.mts や.cts が生えることになるので、これに合わせて凄く久しぶりに tsuquyomi のコードをイジる。

「JavaScript で言うところの `const l = Array.isArray(opt) ? opt : [opt]` のようなことってどうやるんだっけ？」となったが、 値の型検査をする方法を完全に忘れていた。

```vim
:echo type([])
```

## DataDog

久しぶりに Monitoring を Terraform で定義する件。昔のお仕事のときに少し習ったんだけど、全然身につかずに辞めてしまったので、リベンジ感ある。

https://registry.terraform.io/providers/DataDog/datadog/latest/docs/resources/monitor

---

# 4/13

## Next.js

ある意味で昨日も少し調べていた Native ESM の話と関係があるかもしれない?

### 表面的な現象

Next.js prj で Stroybook を利用する際に、 storybook-addon-next でやっているのと同様の hack をしていた。

https://github.com/RyanClementsHax/storybook-addon-next/blob/v1.6.2/src/images/next-image-stub.tsx

要点だけ抜き出すと下記と同じことをやっていた、という意味。

```tsx
// .storybook/preview.tsx

import * as _NextImage from "next/image";

const OriginalNextImage = _NextImage.default;

Object.defineProperty(_NextImage, "default", {
  configurable: true,
  value: (props: any) => {
    return <OriginalNextImage {...props} unoptimized />;
  }
});
```

Next.js v12.1.4 までは上記のコードが workaround として成立していたが、 v12.1.5 で動作しなくなった。

### 発生機序

PR を追いかけてみたところ、 https://github.com/vercel/next.js/pull/35933 を境に挙動が異なる。この PR では、Next.js 内の client コードを build する際の内部的なオプションとして `interopClientDefaultExport` が追加されていることがわかる。

```js
// next/dist/client/image.js

"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Image;

function Image(props) {
  // skip details
}

// The following code block added if `interopClientDefaultExport` is enabled.
if (
  typeof exports.default === "function" ||
  (typeof exports.default === "object" && exports.default !== null)
) {
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}
```

`interopClientDefaultExport` が有効になると、swc でトランスパイルされるコードの末尾に `module.exports` をゴニョゴニョするブロックが付与される。

ここで問題となるのは、このブロックにおける `Object.assign` が実行される際に `exports.__esModule` の property が列挙可能ではないため、`exports.default` にはコピーされないという点 (Property Descriptor における `enumerable` の既定値は `false` である)。したがって、 `interopClientDefaultExport` を有効にした場合には、next/image の `__esModule` は Undefined となる。

一方で、webpack はバンドル時に Import Declaration を以下のように変換する。

```tsx
// src/components/hoge.stories.tsx (source)

import Image from "next/image";
```

```js
// dist/iframe.main.js (bundled)

__webpack_require__.n = function (module) {
  var getter =
    module && module.__esModule
      ? function getDefault() {
          return module["default"];
        }
      : function getModuleExports() {
          return module;
        };
};

var next_image__MODULE = __webpack_require__("./node_modules/next/image.js");
var next_image__MODULE__default = __webpack_require__.n(next_image__MODULE);
```

`__esModule` という property を介して、トランスパイル前のロード対象モジュールが ESM を意図していたのか CJS を意図していたのかを判別し、ロードしている側のモジュールでの default import の意味を変更するようになっている。

`interopClientDefaultExport` によって `__esModule` が欠落したことによって、webpack は (`default` property ではなく) モジュール側の `module.exports` そのものを直接参照することになり、preview.tsx でいくら `default` property の記述を上書きしても、それが利用されることはなくなる、という流れであったわけだ。

### PR の経緯

そもそもなぜ今回の `interopClientDefaultExport` というオプションが入ったのか、という話になると、PR 35933 の元となっている https://github.com/vercel/next.js/issues/34412 を読むに、どうも以下のようなケースを考慮しているらしい。

```js
// index.js in package with `type: "module"`

import Image from "next/image";

console.log(Image); // The imported `Image` should be a function
```

ブラウザには cjs の概念は存在しないわけだから、モジュールを評価する機構の実装に依る話な気はするが、Node.js と同等のモジュール評価が働いたと仮定した場合、今回追加されている block がなければ、 index.js における `Image` は React Component ではなく、ただの `{ default: Image }` という object になるはず。

### 似たような話

これって、TypeScript に `esModuleInterop` が追加された背景の逆パターンとも言える。

`esModuleInterop` は、`default` の形式に対応していない古い CommonJS 形式のパッケージであっても、あたかもそれが default export であるかのように振る舞わせるために、Import Declaration 側のコードを無理やり変換する workaround。

```js
// node_modules/next/image.js

module.exports = function Image() {};
```

```ts
// index.ts (source)

import Image from "image";

console.log(Image);
```

```js
// index.js (transpiled with --module="commonjs")
const Image = require("image").default;

console.log(Image); // Image is not a function because image.js does not export `default` property
```

```js
// index.js (transpiled with --module="commonjs" --esModuleInterop)
function __importDefault(mod) {
  return mod.default || mod;
}

const Image = __importDefault(require("image"));

console.log(Image); // Image is a function!
```

### どこに問題があるのか

詰まるところ、ESM の面をしたソースコードが CJS としてトランスパイルされていて、ESM - CJS の間では default export の相互運用性に問題がある、というのが混乱の元なんだと思う。

一方で、本当に ESM であるのであれば、storybook-addon-next がやっているような「namespace object から property を差し替える」という hack 自体も dirty なものと見なされるはず(Namespace Object の property は Configurable ではない)。

```js
Object.defineProperty(namespaceObj, "default", {
  value: () => "override"
});
```

そう考えると、今回のような「特定のモジュールローディングコンテキストにおける依存対象モジュールの差替」というのを ESM の世界でどうにかしようという発想自体が間違っているわけだから、Next.js が `__esModule` property を無視したからと言って、それを責めることもできない。
静的なモジュール注入という要求自体は別段間違ったものでは無いと思うが、webpack なりのバンドラの機能で解決するのが王道なのかな、やっぱり。

---

# 4/14

## Angular

https://blog.angular.io/developer-survey-2021-results-38e653cbb36b
