# 5/1

## PicoML

Table, Element の parse 部分を作成する。Table が必要になるのは `funcref` と `call_indirect` で動的な関数呼び出しを実現するためだけだけなので、これらが表現できれば十分ということもあって、以下のパターンのみ対応。

```wat
(table $tbl 1 funcref)
(elem (offset i32.const 0) func $fn)
```

```wat
(table $tbl funcref (elem $fn))
```

WAT 関連の最後、Global も対応。

# 5/2

## PicoML

ようやく、ML -> WASM の Compiler 部分に着手。

まずは Literal など簡単な部分から実装していく。 Evaluate と構造は似ているようだけど、

- Evaluate: Traverser が値を返す
- Compiler: Traverser は Module の AST を作り上げていく

となるので、結構構造は違いそう。

多分、今ままでに実装したことがあるもので近しい系統でいうと、 ts-graphql-plugin の typegen 部分が近そう。あれも「GraphQL Document AST -> TypeScript AST」という系統だった。

基本的には「今着目すべき構造(e.g. Selection Set に対応する Type 定義の node)」など、幾つかのスタックを用意しておき、特定の node に enter したときに stack を積み、exit する際に stack を抜けるように実装していけばよいはず。今回だと、恐らく WAT の関数定義ノードが stack として必要になるはず。

にしても、動作確認を考えると、WAT AST -> string の unparser も欲しくなってしまったので、作成することに。さして手間もなく 500 loc 程度で完成する。

適当に組んだ四則演算と数値比較の式が WASM に Compile できたし、IR である WAT AST も可視化できたので、だいぶ満足感がでてきた。

```ocaml
(* Input *)
2 * 3 + 1 <= 2 + 2
```

```wat
;; Output
(module
   (func $main (result i32)
     i32.const 2
     i32.const 3
     i32.mul
     i32.const 1
     i32.add
     i32.const 2
     i32.const 2
     i32.add
     i32.le_s)
   (export "main" (func $main)))
```

最初に上記のスタックマシンについて考え始めたのが [4/10](202104.md#410) なので、足掛け 20 日間以上経ったわけだけど、ようやく実装が追いついてきた。

---

# 5/3

## CoPL

PicoML の `let` 式の Compile を実装するにあたって、環境の実装方法に向き合う必要がある。

今欲しい物は「変数名( `string` ) に頼らずに変数を環境から取り出せる仕組み」なので、CoPL 本の中で、唯一実装していなかった 6 章の名無し式に関する記述を再度読んでみる。

名無し式変換は、De Bruijn Indices という方法を用いるとのこと。

以下が変換例。

```ocaml
fun x ->
  fun y ->
    let z = y + 1 in
    x + y + z
```

```
fun . ->
  fun . ->
    let . = #0 + 1 in
    #2 + #1 + #0
```

`#1` であれば、そのスコープから見て 2 番目に定義が新しい、という意味。上記の `x + y + z` という式を評価する際の環境は下記のような構造になっているはずで、変数 `y` の値を取り出すには `env.parent.value` として
親を 1 つたどればよい。

```js
const env = {
  value: 3,
  parent: {
    value: y,
    parent: {
      value: x,
      parent: root
    }
  }
};
```

このように「index の回数分だけ親環境を辿る」というルールで変数名を使わずに値を取り出すことができる。

## PicoML

上述の De Bruijn Indices が利用できる前提で考えれば、以下の let 式を WAT に変換できそう。

```ocaml
let a = 10 in
let b = 20 in
a + b
```

```wat
(func $main (result i32)
  i32.const 10

  call $new_env ;; 新しい環境を用意して、 a に 10 をセットする

  i32.const 20

  call $new_env ;; 新しい環境を用意して、 b に 20 をセットする

  i32.const 1 ;; 環境における束縛 a に相当する index を引数とする
  call $get_val_from_env  ;; a の値を取り出してスタックに積む

  i32.const 0 ;; 環境における束縛 b に相当する index を引数とする
  call $get_val_from_env  ;; b の値を取り出してスタックに積む

  i32.add

  call $pop_env
  call $pop_env
)
```

一旦、Linked List で実装してみるか。ただの Array の方がアクセス効率は良さそうなんだけど、配列にすると、新しい環境を作るたびに `memory.copy` 相当しないといけないし。。。

何はともあれ、環境を実現するための WASM 側の基盤部品として下記を実装。

- Module の依存関係管理, Module 同士を結合する Builder
- WASM Module
  - Memory Allocator
  - Linker List Environment

Allocator に着手したところで、local の binary unparse を間違っていたことに気付いたため修正が必要になったりはしたが、何とか実装しきる。

それぞれの WASM Module のテストをちゃんと書いたお陰か、Compiler 部分は一発でテスト通ったので我ながらちょっと感動。記念に以下の ML コードを WAT にコンパイルした結果を残しておく。

```ocaml
let a = 10 in
let b = 20 in
a + b
```

```wat
(module
   (memory $__alloc_mem__ 10)
   (global $__alloc_st__ (mut i32)
     i32.const 0)
   (func $__malloc__ (param $size i32) (result i32) (local $next i32)
     global.get $__alloc_st__
     local.set $next
     global.get $__alloc_st__
     local.get $size
     i32.add
     global.set $__alloc_st__
     local.get $next)
   (func $__env_new__ (param $parent_addr i32) (param $value i32) (result i32) (local $addr i32)
     i32.const 8
     call $__malloc__
     local.set $addr
     local.get $addr
     local.get $parent_addr
     i32.store
     local.get $addr
     local.get $value
     i32.store offset= 4
     local.get $addr)
   (func $__env_get__ (param $addr i32) (param $idx i32) (result i32)
     local.get $idx
     i32.const 0
     i32.le_s
     if (result i32)
       local.get $addr
       i32.load offset= 4
     else
       local.get $addr
       i32.load
       local.get $idx
       i32.const 1
       i32.sub
       call $__env_get__
     end)
   (func $__env_parent__ (param $addr i32) (result i32)
     local.get $addr
     i32.load)
   (func $main (result i32) (local $current_env_addr i32)
     i32.const 0
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 10
     call $__env_new__
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 20
     call $__env_new__
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 1
     call $__env_get__
     local.get $current_env_addr
     i32.const 0
     call $__env_get__
     i32.add
     local.get $current_env_addr
     call $__env_parent__
     local.set $current_env_addr
     local.get $current_env_addr
     call $__env_parent__
     local.set $current_env_addr)
   (export "main" (func $main)))
```

昨日の四則演算だけのコードに比べて大分長くなった。冗長コードは何かしらの手段で排除できそうだけど、

- ML AST の段階で簡約
- WAT AST で最適化

のどちらがいいのだろう。まぁ一通り Compiler 部分が完成してから考えればいいか。

---

# 5/4

## PicoML

今日は if 式の compiler 実装から。 `then` もしくは `else` に相当するブロックを抜けるときの stack の値をそのまま if 式の値として扱えばよいだけなので、果てしなく素直な変換だった。秒殺。

引き続いて関数定義と関数適用を考える。

```ocaml
fun x -> 10
```

上記の関数定義式は、以下のように変換すればよいはず。

```wat
(module
  ;; (A)
  (func $fn_0 (param $current_env_addr i32) (result i32)
    ;; (B) function body expression
    i32.const 10
  )

  (func $main (result i32)
    ;; (C)
    i32.const 0 ;; element index for $fn_0
  )
  (table $tbl funcref (elem $fn_0)) ;; (D)
)
```

Compile のアルゴリズムは以下の通り。

1. 新しい関数定義を開始する
2. 関数本体式用の、De Bruijn Indexer を用意する
3. 関数本体式を構築する (B)
4. 関数定義を終了し、作成した (B) の WAT Expression を基に 関数定義 (A) の AST を用意してコンテキストに突っ込む
5. De Bruijn Indexer を、親スコープ用に戻す
6. (A) の関数の Table Element List 上の index 値を、この node の instruction にして返す (C)

(D) の Table 宣言については、関数定義の配列があれば作成可能なので、最後に module を書き出すときに `funcNodes(f => f.id)` で table を作成すればよい。

恒例となった WAT 魚拓は下記。

```wat
(module
   (func $__fn_0__ (param $current_env_addr i32) (result i32)
     i32.const 10)
   (func $main (result i32)
     i32.const 0)
   (table $__func_table__ funcref (elem $__fn_0__))
   (export "main" (func $main)))
```

関数適用はここまでに作ってきた部品の組み合わせで実現できるはず。

```wat
(func $main (result i32)
  ;; instructions for argument
  ;; stack head should be the argument
  call $__env_new__
  ;; instructions which returns function
  ;; stack head should be the index of the callee function
  call_indirect (type $fn_type)
)
```

スタックの先頭が [関数のインデックス, 環境のアドレス値] となるよう準備しておき、 `call_indirect` を叩けば戻り値が得られる。

このプランで実装してみたが、上手く行かない。

`(fun x -> 10)(1)` のような一階の呼出は問題なかったが、下記の二階の関数適用で失敗してしまった。

```ocaml
let add = fun a -> fun b -> a + b in add 10 20
```

上記の式に対して、`30` が返却されるべきところに `21` が返ってくる。 以下は実際の WAT 出力（の main 部分のみ）

```wat
   (func $__fn_0__ (param $current_env_addr i32) (result i32)
     local.get $current_env_addr
     i32.const 1
     call $__env_get__
     local.get $current_env_addr
     i32.const 0
     call $__env_get__
     i32.add)
   (func $__fn_1__ (param $current_env_addr i32) (result i32)
     i32.const 0)
   (func $main (result i32) (local $current_env_addr i32)
     i32.const 0
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 1
     call $__env_new__
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 20
     call $__env_new__
     local.get $current_env_addr
     i32.const 10
     call $__env_new__
     local.get $current_env_addr
     i32.const 0
     call $__env_get__
     call_indirect $__func_table__ (type $__fn_type__)
     call_indirect $__func_table__ (type $__fn_type__)
     local.get $current_env_addr
     call $__env_parent__
     local.set $current_env_addr)
```

それぞれにコメントを振ったものが下記。

```wat
;; fun b -> a + b
(func $__fn_0__ (param $current_env_addr i32) (result i32)
  local.get $current_env_addr
  i32.const 1
  call $__env_get__
  local.get $current_env_addr
  i32.const 0
  call $__env_get__
  i32.add)

;; fun a -> fun b -> a + b
(func $__fn_1__ (param $current_env_addr i32) (result i32)
  i32.const 0)

(func $main (result i32) (local $current_env_addr i32)
  i32.const 0
  local.set $current_env_addr

  ;; let add = ... (function index: 1)
  local.get $current_env_addr
  i32.const 1
  call $__env_new__
  local.set $current_env_addr

  ;; evaluate `add 10 20`

    ;; create new env with 20
    local.get $current_env_addr ;; (X)
    i32.const 20
    call $__env_new__

      local.get $current_env_addr ;; (X)
      i32.const 10
      call $__env_new__

      ;; get funciton index for `add`
      local.get $current_env_addr
      i32.const 0
      call $__env_get__

      call_indirect $__func_table__ (type $__fn_type__)

    call_indirect $__func_table__ (type $__fn_type__)

  ;; finalize `let add = ... in ...`
  local.get $current_env_addr
  call $__env_parent__
  local.set $current_env_addr
)
```

ここまで来てようやく間違ってる箇所に気付く。

やらかしているのは、上記の (X) のコメントの部分であり「関数に喰わせる環境を現在の環境から作成している」点。クロージャーの評価環境は、クロージャー定義時の環境から作成しなくてはならないのに、関数式だけで評価しようとしていたという大ポカ。

関数定義の Compiler がそもそも誤っていたことになる。

> 6. (A) の関数の Table Element List 上の index 値を、この node の instruction にして返す (C)

この実装が誤りで、「index 値とその時点での環境アドレスのタプルで Closure を表現し、このアドレスを返す」とする必要があった。

```ocaml
let add = fun a -> fun b -> a + b in add 10 20
```

実装しなおして、上記も正しく評価できることを確認。

魚拓、100 行超えたので、流石に一々このメモに貼るのはアレなので [Gist](https://gist.github.com/Quramy/ca6c2b3b8867257a7d553eb32f655e76) に残しておいた。

`fun a -> fun b -> a + b` という中断の関数定義部分だけ切り出すと下記のようになっている。

```wat
(func $__fn_0__ (param $current_env_addr i32) (result i32)
  local.get $current_env_addr
  i32.const 1
  call $__env_get__
  local.get $current_env_addr
  i32.const 0
  call $__env_get__
  i32.add)

(func $__fn_1__ (param $current_env_addr i32) (result i32)
  local.get $current_env_addr
  i32.const 0
  call $__tuple_new__)
```

これで、 `$__fn_1__` が呼ばれた際に「 `a` に 10 を束縛した環境 + `$__fn_0__` という関数本体式」という Closure を返却していることになり、この Closure から取り出した環境にさらに `b: 20` を付与したものが `$current_env_addr` に渡って正しく計算できる、という流れ。

自分への戒めの意味で、前半の間違った設計部分もメモに残しておこう。
