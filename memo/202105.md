# 5/1

## PicoML

Table, Element の parse 部分を作成する。Table が必要になるのは `funcref` と `call_indirect` で動的な関数呼び出しを実現するためだけだけなので、これらが表現できれば十分ということもあって、以下のパターンのみ対応。

```wat
(table $tbl 1 funcref)
(elem (offset i32.const 0) func $fn)
```

```wat
(table $tbl funcref (elem $fn))
```

WAT 関連の最後、Global も対応。

# 5/2

## PicoML

ようやく、ML -> WASM の Compiler 部分に着手。

まずは Literal など簡単な部分から実装していく。 Evaluate と構造は似ているようだけど、

- Evaluate: Traverser が値を返す
- Compiler: Traverser は Module の AST を作り上げていく

となるので、結構構造は違いそう。

多分、今ままでに実装したことがあるもので近しい系統でいうと、 ts-graphql-plugin の typegen 部分が近そう。あれも「GraphQL Document AST -> TypeScript AST」という系統だった。

基本的には「今着目すべき構造(e.g. Selection Set に対応する Type 定義の node)」など、幾つかのスタックを用意しておき、特定の node に enter したときに stack を積み、exit する際に stack を抜けるように実装していけばよいはず。今回だと、恐らく WAT の関数定義ノードが stack として必要になるはず。

にしても、動作確認を考えると、WAT AST -> string の unparser も欲しくなってしまったので、作成することに。さして手間もなく 500 loc 程度で完成する。

適当に組んだ四則演算と数値比較の式が WASM に Compile できたし、IR である WAT AST も可視化できたので、だいぶ満足感がでてきた。

```ocaml
(* Input *)
2 * 3 + 1 <= 2 + 2
```

```wat
;; Output
(module
   (func $main (result i32)
     i32.const 2
     i32.const 3
     i32.mul
     i32.const 1
     i32.add
     i32.const 2
     i32.const 2
     i32.add
     i32.le_s)
   (export "main" (func $main)))
```

最初に上記のスタックマシンについて考え始めたのが [4/10](202104.md#410) なので、足掛け 20 日間以上経ったわけだけど、ようやく実装が追いついてきた。
