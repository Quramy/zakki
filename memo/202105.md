# 5/1

## PicoML

Table, Element の parse 部分を作成する。Table が必要になるのは `funcref` と `call_indirect` で動的な関数呼び出しを実現するためだけだけなので、これらが表現できれば十分ということもあって、以下のパターンのみ対応。

```wat
(table $tbl 1 funcref)
(elem (offset i32.const 0) func $fn)
```

```wat
(table $tbl funcref (elem $fn))
```

WAT 関連の最後、Global も対応。

# 5/2

## PicoML

ようやく、ML -> WASM の Compiler 部分に着手。

まずは Literal など簡単な部分から実装していく。 Evaluate と構造は似ているようだけど、

- Evaluate: Traverser が値を返す
- Compiler: Traverser は Module の AST を作り上げていく

となるので、結構構造は違いそう。

多分、今ままでに実装したことがあるもので近しい系統でいうと、 ts-graphql-plugin の typegen 部分が近そう。あれも「GraphQL Document AST -> TypeScript AST」という系統だった。

基本的には「今着目すべき構造(e.g. Selection Set に対応する Type 定義の node)」など、幾つかのスタックを用意しておき、特定の node に enter したときに stack を積み、exit する際に stack を抜けるように実装していけばよいはず。今回だと、恐らく WAT の関数定義ノードが stack として必要になるはず。

にしても、動作確認を考えると、WAT AST -> string の unparser も欲しくなってしまったので、作成することに。さして手間もなく 500 loc 程度で完成する。

適当に組んだ四則演算と数値比較の式が WASM に Compile できたし、IR である WAT AST も可視化できたので、だいぶ満足感がでてきた。

```ocaml
(* Input *)
2 * 3 + 1 <= 2 + 2
```

```wat
;; Output
(module
   (func $main (result i32)
     i32.const 2
     i32.const 3
     i32.mul
     i32.const 1
     i32.add
     i32.const 2
     i32.const 2
     i32.add
     i32.le_s)
   (export "main" (func $main)))
```

最初に上記のスタックマシンについて考え始めたのが [4/10](202104.md#410) なので、足掛け 20 日間以上経ったわけだけど、ようやく実装が追いついてきた。

---

# 5/3

## CoPL

PicoML の `let` 式の Compile を実装するにあたって、環境の実装方法に向き合う必要がある。

今欲しい物は「変数名( `string` ) に頼らずに変数を環境から取り出せる仕組み」なので、CoPL 本の中で、唯一実装していなかった 6 章の名無し式に関する記述を再度読んでみる。

名無し式変換は、De Bruijn Indices という方法を用いるとのこと。

以下が変換例。

```ocaml
fun x ->
  fun y ->
    let z = y + 1 in
    x + y + z
```

```
fun . ->
  fun . ->
    let . = #0 + 1 in
    #2 + #1 + #0
```

`#1` であれば、そのスコープから見て 2 番目に定義が新しい、という意味。上記の `x + y + z` という式を評価する際の環境は下記のような構造になっているはずで、変数 `y` の値を取り出すには `env.parent.value` として
親を 1 つたどればよい。

```js
const env = {
  value: 3,
  parent: {
    value: y,
    parent: {
      value: x,
      parent: root
    }
  }
};
```

このように「index の回数分だけ親環境を辿る」というルールで変数名を使わずに値を取り出すことができる。

## PicoML

上述の De Bruijn Indices が利用できる前提で考えれば、以下の let 式を WAT に変換できそう。

```ocaml
let a = 10 in
let b = 20 in
a + b
```

```wat
(func $main (result i32)
  i32.const 10

  call $new_env ;; 新しい環境を用意して、 a に 10 をセットする

  i32.const 20

  call $new_env ;; 新しい環境を用意して、 b に 20 をセットする

  i32.const 1 ;; 環境における束縛 a に相当する index を引数とする
  call $get_val_from_env  ;; a の値を取り出してスタックに積む

  i32.const 0 ;; 環境における束縛 b に相当する index を引数とする
  call $get_val_from_env  ;; b の値を取り出してスタックに積む

  i32.add

  call $pop_env
  call $pop_env
)
```

一旦、Linked List で実装してみるか。ただの Array の方がアクセス効率は良さそうなんだけど、配列にすると、新しい環境を作るたびに `memory.copy` 相当しないといけないし。。。

何はともあれ、環境を実現するための WASM 側の基盤部品として下記を実装。

- Module の依存関係管理, Module 同士を結合する Builder
- WASM Module
  - Memory Allocator
  - Linker List Environment

Allocator に着手したところで、local の binary unparse を間違っていたことに気付いたため修正が必要になったりはしたが、何とか実装しきる。

それぞれの WASM Module のテストをちゃんと書いたお陰か、Compiler 部分は一発でテスト通ったので我ながらちょっと感動。記念に以下の ML コードを WAT にコンパイルした結果を残しておく。

```ocaml
let a = 10 in
let b = 20 in
a + b
```

```wat
(module
   (memory $__alloc_mem__ 10)
   (global $__alloc_st__ (mut i32)
     i32.const 0)
   (func $__malloc__ (param $size i32) (result i32) (local $next i32)
     global.get $__alloc_st__
     local.set $next
     global.get $__alloc_st__
     local.get $size
     i32.add
     global.set $__alloc_st__
     local.get $next)
   (func $__env_new__ (param $parent_addr i32) (param $value i32) (result i32) (local $addr i32)
     i32.const 8
     call $__malloc__
     local.set $addr
     local.get $addr
     local.get $parent_addr
     i32.store
     local.get $addr
     local.get $value
     i32.store offset= 4
     local.get $addr)
   (func $__env_get__ (param $addr i32) (param $idx i32) (result i32)
     local.get $idx
     i32.const 0
     i32.le_s
     if (result i32)
       local.get $addr
       i32.load offset= 4
     else
       local.get $addr
       i32.load
       local.get $idx
       i32.const 1
       i32.sub
       call $__env_get__
     end)
   (func $__env_parent__ (param $addr i32) (result i32)
     local.get $addr
     i32.load)
   (func $main (result i32) (local $current_env_addr i32)
     i32.const 0
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 10
     call $__env_new__
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 20
     call $__env_new__
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 1
     call $__env_get__
     local.get $current_env_addr
     i32.const 0
     call $__env_get__
     i32.add
     local.get $current_env_addr
     call $__env_parent__
     local.set $current_env_addr
     local.get $current_env_addr
     call $__env_parent__
     local.set $current_env_addr)
   (export "main" (func $main)))
```

昨日の四則演算だけのコードに比べて大分長くなった。冗長コードは何かしらの手段で排除できそうだけど、

- ML AST の段階で簡約
- WAT AST で最適化

のどちらがいいのだろう。まぁ一通り Compiler 部分が完成してから考えればいいか。

---

# 5/4

## PicoML

今日は if 式の compiler 実装から。 `then` もしくは `else` に相当するブロックを抜けるときの stack の値をそのまま if 式の値として扱えばよいだけなので、果てしなく素直な変換だった。秒殺。

引き続いて関数定義と関数適用を考える。

```ocaml
fun x -> 10
```

上記の関数定義式は、以下のように変換すればよいはず。

```wat
(module
  ;; (A)
  (func $fn_0 (param $current_env_addr i32) (result i32)
    ;; (B) function body expression
    i32.const 10
  )

  (func $main (result i32)
    ;; (C)
    i32.const 0 ;; element index for $fn_0
  )
  (table $tbl funcref (elem $fn_0)) ;; (D)
)
```

Compile のアルゴリズムは以下の通り。

1. 新しい関数定義を開始する
2. 関数本体式用の、De Bruijn Indexer を用意する
3. 関数本体式を構築する (B)
4. 関数定義を終了し、作成した (B) の WAT Expression を基に 関数定義 (A) の AST を用意してコンテキストに突っ込む
5. De Bruijn Indexer を、親スコープ用に戻す
6. (A) の関数の Table Element List 上の index 値を、この node の instruction にして返す (C)

(D) の Table 宣言については、関数定義の配列があれば作成可能なので、最後に module を書き出すときに `funcNodes(f => f.id)` で table を作成すればよい。

恒例となった WAT 魚拓は下記。

```wat
(module
   (func $__fn_0__ (param $current_env_addr i32) (result i32)
     i32.const 10)
   (func $main (result i32)
     i32.const 0)
   (table $__func_table__ funcref (elem $__fn_0__))
   (export "main" (func $main)))
```

関数適用はここまでに作ってきた部品の組み合わせで実現できるはず。

```wat
(func $main (result i32)
  ;; instructions for argument
  ;; stack head should be the argument
  call $__env_new__
  ;; instructions which returns function
  ;; stack head should be the index of the callee function
  call_indirect (type $fn_type)
)
```

スタックの先頭が [関数のインデックス, 環境のアドレス値] となるよう準備しておき、 `call_indirect` を叩けば戻り値が得られる。

このプランで実装してみたが、上手く行かない。

`(fun x -> 10)(1)` のような一階の呼出は問題なかったが、下記の二階の関数適用で失敗してしまった。

```ocaml
let add = fun a -> fun b -> a + b in add 10 20
```

上記の式に対して、`30` が返却されるべきところに `21` が返ってくる。 以下は実際の WAT 出力（の main 部分のみ）

```wat
   (func $__fn_0__ (param $current_env_addr i32) (result i32)
     local.get $current_env_addr
     i32.const 1
     call $__env_get__
     local.get $current_env_addr
     i32.const 0
     call $__env_get__
     i32.add)
   (func $__fn_1__ (param $current_env_addr i32) (result i32)
     i32.const 0)
   (func $main (result i32) (local $current_env_addr i32)
     i32.const 0
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 1
     call $__env_new__
     local.set $current_env_addr
     local.get $current_env_addr
     i32.const 20
     call $__env_new__
     local.get $current_env_addr
     i32.const 10
     call $__env_new__
     local.get $current_env_addr
     i32.const 0
     call $__env_get__
     call_indirect $__func_table__ (type $__fn_type__)
     call_indirect $__func_table__ (type $__fn_type__)
     local.get $current_env_addr
     call $__env_parent__
     local.set $current_env_addr)
```

それぞれにコメントを振ったものが下記。

```wat
;; fun b -> a + b
(func $__fn_0__ (param $current_env_addr i32) (result i32)
  local.get $current_env_addr
  i32.const 1
  call $__env_get__
  local.get $current_env_addr
  i32.const 0
  call $__env_get__
  i32.add)

;; fun a -> fun b -> a + b
(func $__fn_1__ (param $current_env_addr i32) (result i32)
  i32.const 0)

(func $main (result i32) (local $current_env_addr i32)
  i32.const 0
  local.set $current_env_addr

  ;; let add = ... (function index: 1)
  local.get $current_env_addr
  i32.const 1
  call $__env_new__
  local.set $current_env_addr

  ;; evaluate `add 10 20`

    ;; create new env with 20
    local.get $current_env_addr ;; (X)
    i32.const 20
    call $__env_new__

      local.get $current_env_addr ;; (X)
      i32.const 10
      call $__env_new__

      ;; get funciton index for `add`
      local.get $current_env_addr
      i32.const 0
      call $__env_get__

      call_indirect $__func_table__ (type $__fn_type__)

    call_indirect $__func_table__ (type $__fn_type__)

  ;; finalize `let add = ... in ...`
  local.get $current_env_addr
  call $__env_parent__
  local.set $current_env_addr
)
```

ここまで来てようやく間違ってる箇所に気付く。

やらかしているのは、上記の (X) のコメントの部分であり「関数に喰わせる環境を現在の環境から作成している」点。クロージャーの評価環境は、クロージャー定義時の環境から作成しなくてはならないのに、関数式だけで評価しようとしていたという大ポカ。

関数定義の Compiler がそもそも誤っていたことになる。

> 6. (A) の関数の Table Element List 上の index 値を、この node の instruction にして返す (C)

この実装が誤りで、「index 値とその時点での環境アドレスのタプルで Closure を表現し、このアドレスを返す」とする必要があった。

```ocaml
let add = fun a -> fun b -> a + b in add 10 20
```

実装しなおして、上記も正しく評価できることを確認。

魚拓、100 行超えたので、流石に一々このメモに貼るのはアレなので [Gist](https://gist.github.com/Quramy/ca6c2b3b8867257a7d553eb32f655e76) に残しておいた。

`fun a -> fun b -> a + b` という中断の関数定義部分だけ切り出すと下記のようになっている。

```wat
(func $__fn_0__ (param $current_env_addr i32) (result i32)
  local.get $current_env_addr
  i32.const 1
  call $__env_get__
  local.get $current_env_addr
  i32.const 0
  call $__env_get__
  i32.add)

(func $__fn_1__ (param $current_env_addr i32) (result i32)
  local.get $current_env_addr
  i32.const 0
  call $__tuple_new__)
```

これで、 `$__fn_1__` が呼ばれた際に「 `a` に 10 を束縛した環境 + `$__fn_0__` という関数本体式」という Closure を返却していることになり、この Closure から取り出した環境にさらに `b: 20` を付与したものが `$current_env_addr` に渡って正しく計算できる、という流れ。

自分への戒めの意味で、前半の間違った設計部分もメモに残しておこう。

---

# 5/5

## PicoML

再帰関数定義とその適用規則の Compiler を作る。

最初の実装としては、昨日作成した Closure の表現について、2 値の Tuple から 3 値の Tuple に変更し、先頭に「再帰 Closure かどうか」のフラグを持たせるようにしてみた。

これは、JS 版の評価器では、以下のように関数適用時に再帰 Closure かどうかを見分けて作成する環境を切り替えるように実装していたため、おなじやり方を無意識に踏襲していたから。

```ts
if (!isClosure(callee)) {
  return error({
    message: `should be function, but ${getEvaluationResultTypeName(callee)}}`,
    occurence: expression.callee
  });
}
if (!isRecClosure(callee)) {
  return next(
    callee.functionDefinition.body,
    createChildEnvironment(
      callee.functionDefinition.param,
      argument,
      callee.env
    )
  );
} else {
  const recEnv = createChildEnvironment(callee.recursievId, callee, callee.env);
  return next(
    callee.functionDefinition.body,
    createChildEnvironment(callee.functionDefinition.param, argument, recEnv)
  );
}
```

ただ、いざ実装してみたところ、関数適用時の Instruction に毎度 `if` の block が入り込んでくるし、一々 Closure にも Flag を用意しないといけないしで、あまりシンプルとは言えない実装になってしまった。

そこで今回は「常に Closure を環境に束縛しておく」という方法にしてみた。JS 版に即していうのであれば、常に上記のコードでいうところの `else` 節だけで評価されるようなイメージ。通常の `FunctionDefinitionNode` の場合、`recursievId` に相当する De Bruijn Index が歯抜けとなるように実装しておく。

出力されるバイナリのコード量的には、この「毎度 Closure 自身が環境に焼き付く」実装の方が得なんだけど、Runtime のコストとしてはどっちが正しかったのか分からないな。「関数内から自己を参照しているかどうか」は静的にわかるのだから、この結果に応じて、束縛の有無を決定するようにできればいいのかな。

いつものように魚拓をとったのだけど、試しに [wabt の demo](https://webassembly.github.io/wabt/demo/wat2wasm/) に貼り付けたところ、Parse Error になってしまった。Memory Argument の `offset` や `aligin` について、

```wat
i32.store offset= 4
```

のように トークンとトークンの間に white space を入れていたのが問題だった。 https://webassembly.github.io/spec/core/text/instructions.html#memory-instructions にも、これに関する記載はあったんだよね。。。

> Lexically, an 𝚘𝚏𝚏𝚜𝚎𝚝 or 𝚊𝚕𝚒𝚐𝚗 phrase is considered a single keyword token, so no white space is allowed around the ‘=’.

先日に unparser 実装した際も出力見て違和感あったんだけど、面倒だったので放置していたツケが回った形に。

諸々修正して完成した魚拓は[こちら](https://gist.github.com/Quramy/b6dc71d4d4c15ef575255e09357f7354) 。対象は定番の階乗計算。

```ocaml
let rec fact = fun n -> if n < 1 then 1 else n * fact (n - 1) in
fact 6
```

残すところは List 系。ひとまず単方向の Linked List 用の WASM Module と empty list の変換器を作成した。

```ocaml
[] == [] (* true *)
```

にしなくてはいけないため、「空リストは常にアドレス値として 0 を返す」という風にして逃げた。

---

# 5/6

## PicoML

Cons List Operation の Compiler を作成。Instruction 部分には問題が無かったが、特定の条件でよろしくない挙動になっていることに気付く。

昨日の

> 「空リストは常にアドレス値として 0 を返す」という風にして逃げた。

に関係するが、線形メモリから最初に払い出されたアドレスも 0 になっているため、`1::[]` だけの式において、このリストのポインタ値が 0 になって空リスト扱いされてしまっていた。Allocator 側で「アドレスとして利用する値は 4 以上」として修正。

これで残すところはパターンマッチのみになった。おさらいのために、JS 版の評価器での Matcher 実装を眺めてみる。

```ts
interface Substitution {
  readonly lhs: IdentifierNode;
  readonly rhs: EvaluationValue;
}

function isMatchInner(
  value: EvaluationValue,
  pattern: MatchPatternNode,
  substitutions: readonly Substitution[]
): readonly Substitution[] | null {
  if (pattern.kind === "WildcardPattern") {
    return substitutions;
  } else if (pattern.kind === "EmptyListPattern") {
    return isList(value) && value.length === 0 ? substitutions : null;
  } else if (pattern.kind === "IdPattern") {
    return [...substitutions, { lhs: pattern.identifier, rhs: value }];
  } else if (pattern.kind === "ListConsPattern") {
    if (!isList(value)) return null;
    if (value.length === 0) return null;
    const [head, ...tail] = value;
    const resultHead = isMatchInner(head, pattern.head, substitutions);
    const resultTail = isMatchInner(tail, pattern.tail, substitutions);
    if (!resultHead || !resultTail) return null;
    return [...substitutions, ...resultHead, ...resultTail];
  }
  // @ts-expect-error
  throw new Error(`invalid kind: ${pattern.kind}`);
}

export function isMatch(
  value: EvaluationValue,
  pattern: MatchPatternNode,
  env: Environment
): Environment | null {
  const substitutions = isMatchInner(value, pattern, []);
  if (!substitutions) return null;
  return substitutions.reduce(
    (env, { lhs, rhs }) => createChildEnvironment(lhs, rhs, env),
    env
  );
}
```

JS 版の評価器は Interpreter であったため、実行時に値と AST である `MatchPatternNode` の双方にアクセス可能であったので、上記のように `isMatch` 関数を Generic に用意できていた。

一方、 Compiler の場合、実行時には AST 情報は参照できないので、Compile 時に Adaptive に `pattern` に応じた Matcher 関数に展開するようにした。

```ocaml
match 0 with x::y::[] -> x | _ -> 0
```

例えば上記のような match 式について、以下のようになる。「match したらパターンで定義された変数を現在の環境に追加束縛した新しい環境を返す」という基本的な考え方は Interpreter と一緒。

```wat
(func $__matcher_0__ (param $current_env_addr i32) (param $value i32) (result i32)
  local.get $current_env_addr
  local.get $value
  call $__matcher_is_matched_wildcard_pattern__)

(func $__matcher_1__ (param $current_env_addr i32) (param $value i32) (result i32)
  local.get $value
  if (result i32)
    local.get $value
    local.get $value
    call $__list_head__
    local.set $value
    local.get $current_env_addr
    local.get $value
    call $__matcher_is_matched_identifier_pattern__
    local.set $current_env_addr
    call $__list_tail__
    local.set $value
    local.get $value
    if (result i32)
      local.get $value
      local.get $value
      call $__list_head__
      local.set $value
      local.get $current_env_addr
      local.get $value
      call $__matcher_is_matched_identifier_pattern__
      local.set $current_env_addr
      call $__list_tail__
      local.set $value
      local.get $current_env_addr
      local.get $value
      call $__matcher_is_matched_empty_list_pattern__
    else
      i32.const 0
    end
  else
    i32.const 0
  end)

(func $main (result i32) (local $current_env_addr i32) (local $value_for_matcher i32) (local $matched_env_addr i32) (local $prev_env_addr i32)
  i32.const -1
  local.set $current_env_addr
  i32.const 0
  local.set $value_for_matcher
  local.get $current_env_addr
  local.get $value_for_matcher

  call $__matcher_1__
  local.tee $matched_env_addr
  if (result i32)
    local.get $current_env_addr
    local.set $prev_env_addr
    local.get $matched_env_addr
    local.set $current_env_addr
    local.get $current_env_addr
    i32.const 1
    call $__env_get__
    local.get $prev_env_addr
    local.set $current_env_addr
  else
    local.get $current_env_addr
    local.get $value_for_matcher
    call $__matcher_0__
    local.tee $matched_env_addr
    if (result i32)
      local.get $current_env_addr
      local.set $prev_env_addr
      local.get $matched_env_addr
      local.set $current_env_addr
      i32.const 0
      local.get $prev_env_addr
      local.set $current_env_addr
    else
      unreachable
    end
  end)
```

if block の末尾の方にある下記の Instruction は、この match 式の評価が終わった後に、関数内で別の評価が走った場合に環境情報を戻すためのもの。これが無いと、

```wat
    local.set $current_env_addr
    local.get $current_env_addr
```

```ocaml
let a = 20 in
(match 100 with x -> x) + a
```

の評価結果が 200 になってしまう。

同一スタック内のローカル変数の戻し忘れに起因するミスについては既にやらかしていて、関数適用時に下記のように「今から利用する Closure のアドレス」を保持しているのだけど、これを関数適用終了時に戻し忘れていた。

```wat
call $__env_get__
local.tee $closure_addr
```

このせいで、以下の式をテストした際に無効な table アクセスが発生してしまった。

```ocaml
let rec fact = fun n -> if n < 2 then 1 else n * fact(n - 1) in
let rec range = fun s -> fun e -> if s >= e then [] else s::(range (s + 1) e) in
let rec map = fun f -> fun list -> match list with [] -> [] | x::y -> (f x)::(map f y) in
map fact (range 1 7) (* [1; 2; 6; 24; 120; 720] *)
```

最初どこでぶっ壊れたのかが全然わからなかったけど、たまたま match 式のときの変数戻しの対応が思い浮かんだので、ミスに当たりが付いたから良かったけど、WASM の Runtime Error が起こると手も足も出なくなるのは結構まずいな。。。

修正 & WASM Compiler Branch をマージしたタイミングでの上記の式のコンパイル結果は [こちら](https://gist.github.com/Quramy/fbfbb8738aa36482727e1dd6e7e1d8e4) 。

なんとか動くとこまで漕ぎ着けることができて感無量だ。

## Misc

ふと「どこかで WASM に関する勉強会やってないかな？」と思って Connpass 調べてみたところ、 Web24 という会が 5/7 に開催されるのを見つけた。 WASM のセッションもあるようで、 @bokuweb さんも登壇するみたい。

---

## Web24

アーカイブなし、資料なし、台本なしとのこと。同僚の分については後から話聞けばいい気がしてきたので、wasm のとこだけ観ることにしよっと。

## PicoML

大玉の Compiler が終わったので、落穂ひろい系をいくつかやっておきたい。気になってる箇所は下記あたり。

- コメントを Parse できるようにする
- WASM unparser のリファクタリング
- Compiler の Context 周りをもう少し綺麗にする
- `NumberLiteral` を `IntLiteral` に rename したい
- CLI のコマンドラインオプションパーサー

今日は下記を実装。

> - コメントを Parse できるようにする
> - `NumberLiteral` を `IntLiteral` に rename したい

## Vim

滅多に使わないので名前すら忘れてしまう、バイナリをいい感じに確認するためのコマンドである `xxd` 。これって Vim に付属している CLI だったのね。Linux の場合だと、標準的には `od` コマンドがあるようだけど、色々オプションを付けないと見にくいので、やはり `xxd` の方が優秀ではある。

Vim から使うときは、

- 適当なバイナリを Vim で開く
- `:%!xxd` を実行する

とすればよい。
