# 9/4

## jotai

今まで目をそむけてきたけど、「jotai で Redux で実現できていたことがちゃんとできる」というのをモノにしてきたような気がする。

以下のような、配列の要素ごとに状態( `selected` ) を管理するようなグローバルステートが必要になったとする。

```ts
type State = readonly { readonly id; readonly selected: boolean }[];
```

この件を考える発端となったのは、 Next.js App Router で「id ごとに必要最小限の CC で状態管理を行いたい」という要求に直面したため。

`splitAtom` など、幾つかのプランを試してみたが、結局のところ以下に落ち着いたと思う。

```ts
/* myArrayModule.ts */

import { useEffect, useMemo } from "react";

import { atom, useAtom } from "jotai";
import { selectAtom } from "jotai/utils";

type Item = { readonly id: string; readonly selected: boolean };

// 配列型を格納する atom
const myArrayAtom = atom<readonly Item[]>([]);

const createSelector = (id: string) => (list: readonly Item[]) =>
  list.find((item) => item.id === id)?.selected;

// Reducer for initializing whole array
const initMyArrayAtom = atom(
  null,
  (_, set, itemList: readonly { readonly id: string }[]) => {
    set(
      myArrayAtom,
      itemList.map(({ id }) => ({ id, selected: "main" } as Item))
    );
  }
);

// Reducer for updating each item state
const updateItemAtom = atom(null, (get, set, update: Item) => {
  set(
    myArrayAtom,
    get(myArrayAtom).map((item) => (item.id === update.id ? update : item))
  );
});

// Hook for initializer component
export function useInitMyArray(itemList: readonly { readonly id: string }[]) {
  const [, initMyArray] = useAtom(initMyArrayAtom);
  useEffect(() => {
    initMyArray(itemList);
  }, [initMyArray, itemList]);
}

// Hook for each item component
export function useItemInMyArrayAtom(itemId: string) {
  const selector = useMemo(() => createSelector(itemId), [itemId]);
  const itemReadAtom = selectAtom(myArrayAtom, selector);
  const [value] = useAtom(itemReadAtom);
  const [, update] = useAtom(updateItemAtom);

  return useMemo(() => [value, update] as const, [value, update]);
}
```

```tsx
/* app/items/page.tsx */

import Link from "next/link";

import { AtomInitalizer } from "./AtomInitalizer";
import { OnlySelected } from "./OnlySelected";
import { fetchItems } from "./api";

export async function Page() {
  const items = await fetchItems();
  return (
    <AtomInitalizer items={items}>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <h3>商品 {index + 1}</h3>
            {/* SelectableItem だけを CC にしたい */}
            <OnlySelected id={item.id}>{item.id} の詳細部分</OnlySelected>
          </li>
        ))}
      </ul>
    </AtomInitalizer>
  );
}

export default Page;
```

```tsx
/* app/items/AtomInitalizer.tsx */

"use client";

import { useInitMyArray } from "./myArrayModule";

type Props = {
  readonly items: ReadonlyArray<{ readonly id: string }>;
  readonly children?: React.ReactNode;
};

export function AtomInitalizer({ children, items }: Props) {
  useInitMyArray(items);

  return children;
}
```

```tsx
/* app/items/SelectableItem.tsx */

"use client";

import { useItemInMyArrayAtom } from "./myArrayModule";

export function OnlySelected({
  id,
  children,
}: {
  readonly id: string;
  readonly children: React.ReactNode;
}) {
  const [selected, update] = useItemInMyArrayAtom(id);
  return (
    <div>
      <div>
        <button onClick={() => update({ id, selected: !selected })}>
          click to toggle
        </button>
      </div>
      <div>{selected && children}</div>
    </div>
  );
}
```

書き上げてみると何のことはない、Redux での Re-ducks モジュールと同じである。

- State: Primitive Atom
- Selector: `selectAtom` による Read-only atom
- Action Creator + Reducer: ( `atom` の第一引数を null にした) Write-only atom

Redux と異なるのは、 `combieReducer` による Single State Tree として、 `_app.tsx` まで巻き上げないといけないかどうか、という点でしかない。

なんというか、開眼してみるとどうということはない、という系統の話だったような。

---

# 9/5

## Next.js

Server Action と `npm run dev --turbo` が併用できなくて悲しい。

---

# 9/8

## Next.js

v13.4.13 以降にログが表示されなくなっていた件、明示的な有効化が必要だった。

```js
module.exports = {
  experimental: {
    logging: "verbose",
  },
};
```

https://github.com/vercel/next.js/issues/53795#issuecomment-1672241238
