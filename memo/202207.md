# 7/1

## Node.js

Chalk と同等の機能を core の util に入れるかどうか、という問題 ( https://github.com/nodejs/node/issues/43382#issuecomment-1166267429 ) から波及して、「そもそも Node.js は ESM への移行を推奨しているのか」という issue が作られていた。

https://github.com/nodejs/TSC/issues/125://github.com/nodejs/TSC/issues/1251

---

# 7/4

## GCP

Cloud pub sub の順序指定キーの話。

https://cloud.google.com/pubsub/docs/publisher?hl=ja#using_ordering_keys

---

# 7/5

## Ruby

https://github.com/deivid-rodriguez/pry-byebug

割とデファクト的に利用されているデバッガツールなのかな。

https://github.com/deivid-rodriguez/byebug が Debugger 本体の機能で、 https://github.com/pry/pry がリッチなコンソール(より高機能な irb)。

インストールはシンプルに以下。

```ruby
gem 'pry-byebug'
```

```ruby
# main.rb
require 'pry-byebug'

RANGE=0...10

def main
  RANGE.each do |x|
    puts x
    binding.pry # Breakpoint
  end
end

main
```

`bundle exec pry main.rb` とか `bundle exec ruby main.rb` などで実行すれば、Breakpoint を打った箇所で pry の REPL が開始される。

コマンドは何種類か用意されているが、とりあえず `continue` と `step` あたりを頭の片隅に留めておけば後は何とかなりそう。

## Docker

上記の pry-byebug と関連する件。

docker-compose で Rails を立ち上げているときに、特定のコードに `binding.pry` を仕込んだ場合に、pry の操作をどうやるのか、という文脈。

以下のように `attach` sub command で、up したプロセスをターミナルにアタッチすることができる。知らなかった。

```sh
docker attach <CONTAINER_NAME_OR_ID>
```

https://docs.docker.com/engine/reference/commandline/attach/

---

# 7/7

## Rails

テーブルに index を付与するための方法:

https://forest-valley17.hatenablog.com/entry/2018/09/12/163849

## Misc

おしごとで「過去にまわしてしまったバッチに誤りがあった」という類の障害対応を行った。
そもそも、新卒の会社を辞めて以来数年は Web フロントにばかり軸足を置いていたので、バッチや DB 周りの修正であったり調査が自分自身のタスクになること自体がすごく久しぶりだ。というか、新卒の頃まで含めてもあったっけ、、というレベル。

正直、この手の瞬発力が必要な対応について、今時点の自分のスキルだとあまり具体作業レベルでは役に立たないんじゃないかと思っていたが、やってみたら意外とそうでもなかったのは嬉しい誤算だった。
もちろん、同僚のエンジニアと分担での作業ではあったが、思いがけない知識が途中途中で活きてきた。それは、例えば対応開始時点ではまったく思い出しもしなかった Google Analytics の知識であったり、スプレッドシートや JavaScript のちょっとした小技であったり。

[去年の 12 月に書いた内容](202112.md#firebase-analytics) が障害の対応で役に立つなんて、思いもよらなかったが、こうして書き溜めるという行為があったお陰で、知識としては頭に引っかかった状態になっていて、それを実際に情報として取り出せて利用できたわけだけど、何だかんだ、自分の性格に助けられたようなものだし、意外と経験って身についてるということを実感。

---

# 7/8

## PostgreSQL

CIC(Create Index Concurrently) というものを知った。

https://www.postgresql.org/docs/14/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY

> Normally PostgreSQL locks the table to be indexed against writes and performs the entire index build with a single scan of the table.

下記はインデックス作成完了まで users テーブル全体をロックしてしまう。

```sql
CREATE INDEX "index_name_on_users" ON "users" ("name");
```

CIC はインデックスの作成と、他のトランザクションが並行で行えるようにする、というもの。 `CONCURRENTLY` で修飾するだけ。

```sql
CREATE CONCURRENTLY INDEX "index_name_on_users" ON "users" ("name");
```

Rails の Migration であっても、`algorithm` オプションに `:concurrently` を渡せば利用できる。

https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_index

```ruby
class AddIndexToUserName < ActiveRecord::Migration[7.0]
  disable_ddl_transaction!
  def change
    add_index :users, :name, algorithm: :concurrently
  end
end
```

PostgreSQL の仕様として CIC はトランザクションを貼れないため、 `disable_ddl_transaction!` も必要になる。

勿論旨い話だけではなく、Cons もある。
インデックスのビルド処理自体が複雑になる分、CPU, IO ともに通常のインデックスビルドよりも負荷が増すことになるし、インデックス作成開始時点のスナップショットを参照しているトランザクションの全てが完了するまで作成したインデックスの利用を開始できない。

正直、Postgres のドキュメントに書いてある CIC の方式説明が割と難解で理解しきれなかったため、 https://www.2ndquadrant.com/en/blog/create-index-concurrently/ などの解説を読んでおきたい。

---

# 7/12

## Zig

https://ziglang.org/news/statement-regarding-zen-programming-language/

## TypeScript

久しぶりに GitHub の issues や PRs を探索。Milestone 4.8 がついた PR はほぼ見当たらず。

## GraphQL

https://github.com/Urigo/graphql-modules

そこそこ Monolithic で大きめな GraphQL API サーバーを構築するためのライブラリ、という感じなのかな？

一つ一つのモジュールが小さく動く Executable Schema になっていそう。

- typeDefs
- resolvers

雑にガイドななめ読みした感じだと、 Dependency Injection が出てくるけど、どうも Legacy Decorator っぽいなぁ。。。

## Svelte

https://www.the-guild.dev/blog/houdini-and-kitql

## Android

R8 という難読化・圧縮ツールで APK を小さくできることを知った。

https://android-developers.googleblog.com/2018/11/r8-new-code-shrinker-from-google-is.html

## Rails

おしごとにて New Relic から DataDog への APM 移行的な営みに関わることに。

公式のサンプルには Rails アプリケーションの場合の設定例として、Gemfile で `auto_instrument` を読み込む例が書いてあるが、割と罠だ。

```ruby
source 'https://rubygems.org'
gem 'ddtrace', require: 'ddtrace/auto_instrument'
```

最初、 `auto_instrument` を試してみたが、Rails Console から適当に `ApplicationRecord.connection` とかを叩いただけで `SystemStackError: stack level too deep` が発生した。
[README](https://github.com/DataDog/dd-trace-rb/blob/master/docs/GettingStarted.md#stack-level-too-deep) の最下部付近で触れられてはいるが、`alias_method` を使った Monkey Patch が依存ライブラリなどにあると発生することがあるらしい。

ちなみに、 `alias_method` での Method 書き換えは以下のような感じ（https://www.bearer.com/blog/module-overrides-ruby-prepend-alias より）

```ruby
class HTTPClient
  def get(url)
    ...
  end
end
```

```ruby
class HTTPClient
  alias_method :get_without_bearer, :get

  def get(url)
    puts "Calling API at #{url}"
    get_without_bearer(url) # this calls the original method
  end
end
```

ところで、ddtrace の導入を考えているプロジェクトは graphql-ruby を使っているため、GraphQL に特化した Instrument の設定周りも軽く読んでおく。やっぱり Instrument を trace に載せる手順が整っている。

- https://docs.datadoghq.com/tracing/trace_collection/dd_libraries/ruby/#graphql
- https://graphql-ruby.org/queries/tracing.html#datadog

```ruby
# app/graphql/schema.rb

class MySchema < GraphQL::Schema
  use(GraphQL::Tracing::DataDogTracing, options)
end
```

上記の設定方法はまぁ普通にわかるんだけど、以下のような書き方だとうまく行かず。おそらく initializer として GraphQL schema のクラスが読み込まれる前に動かそうとしているような意味になってる？

```ruby
# config/initializers/datadog.rb

Datadog.configure do |c|
  c.tracing.instrument :graphql, schemas: [MySchema]
end
```

## k8s

https://argoproj.github.io/argo-rollouts/

ArgoCD が提唱している Deployment と似た概念。

> A Rollout is Kubernetes workload resource which is equivalent to a Kubernetes Deployment object.

Canary Deployment や Blue-Green Deployment といった、デプロイ戦略の指定を行ったりすることができる。

k8s native な Deployment と Argo Rollouts の比較として、以下があるらしい。

- Deployment は ロールアウトの浸透速度をコントロールする術がほぼ存在しない
- Deployment は新しいバージョンへのトラフィックフローを制御できない
- Deployment だと Readiness Probe が不自由（one-time なチェックができない、など）
- Deployment だと更新の検証を行うための外部メトリクスを実行できない
- Deployment はロールアウトの進行を停止することはできても、自動ロールバックができない

たとえば Blue-Green Deployment であれば、以下のように Rollout リソースを構成する。 https://argoproj.github.io/argo-rollouts/features/bluegreen/

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: rollout-bluegreen
spec:
  replicas: 2
  revisionHistoryLimit: 2
  selector:
    matchLabels:
      app: rollout-bluegreen
  template:
    metadata:
      labels:
        app: rollout-bluegreen
    spec:
      containers:
        - name: rollouts-demo
          image: argoproj/rollouts-demo:blue
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
  strategy:
    blueGreen:
      activeService: rollout-bluegreen-active
      previewService: rollout-bluegreen-preview
      autoPromotionEnabled: false
```

---

# 7/13

## DataDog

昨日に引き続き、 DataDog APM 周り。

Node.js の server に trace を設定する場合、dd-trace の npm を利用することになるが、plugin に Prisma がない。

https://github.com/DataDog/dd-trace-js/issues/1244

---

# 7/14

## Vite

Vite 3 がアナウンスされていた。

https://vitejs.dev/blog/announcing-vite3.html

確かに急速に勢力拡大しているとは思うものの、使わなきゃ！という気持ちにはならないのが正直なところ。

Next.js 触ってることが多いから、というのが大半の理由だけど、例えばテストにせよ Jest + swc 辺りで満足してしまっている、というのもある。
まぁ昔も mocha + sinon で十分って思ってた頃もあったし、一年後にどう言っているかはわからないけど。

ちなみに、vite-ruby に Rails 向けのインテグレーションが記載されてた。

https://vite-ruby.netlify.app/guide/rails.html

やってることとして sprockets や webpacker と何が違うんだろう。

---

# 7/15

## Ruby

Sentry の Ruby SDK でも JavaScript SDK における `beforeSend` 相当がある。

https://docs.sentry.io/platforms/ruby/guides/rails/configuration/options/#optional-settings

Rails であれば、 initializers にこれを仕込めば、setnry.clieng.config.js 的なことができそう。

---

# 7/19

## Next.js

https://zenn.dev/akfm/articles/next-js-scroll-restore

## Rails

自分で Rails の素振り。

Docker Compose で PostgreSQL + Local の Ruby で Rails の構成。

```sh
ralis new active_record_reflection_study --api
```

```yaml
version: "3"

services:
  postgres:
    image: postgres:14
    restart: always
    environment:
      POSTGRES_USER: pguser
      POSTGRES_PASSWORD: user123
      TZ: "Asia/Tokyo"
    ports:
      - 5432:5432
    volumes:
      - postgres:/var/lib/postgresql/data

  pgadmin:
    image: dpage/pgadmin4
    restart: always
    ports:
      - 5433:80
    environment:
      PGADMIN_DEFAULT_EMAIL: pguser@example.com
      PGADMIN_DEFAULT_PASSWORD: user123
    volumes:
      - pgadmin:/var/lib/pgadmin
    depends_on:
      - postgres

volumes:
  postgres:
  pgadmin:
```

```ruby
# gem "sqlite3", "~> 1.4"
gem "pg"
```

```sh
bundle install
```

```yaml
# config/database.yml

default: &default
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000

development:
  <<: *default
  database: active_record_reflection_study_development
  url: postgresql://pguser:user123@localhost:5432

test:
  <<: *default
  database: active_record_reflection_study_test
  url: postgresql://pguser:user123@localhost:5432

production:
  <<: *default
  database: active_record_reflection_study_production
  url: postgresql://pguser:user123@localhost:5432
```

```sh
bundle exec rails db:setup
```

```sh
bundle exec rails generate model user
```

やりたかったことは https://qiita.com/tonluqclml/items/ba46331b28e021532254 の記事と同じ様なことで、「FK が貼られている table について、親テーブルの削除時にちゃんと association でも削除するようにしているかどうかチェックする」という件。

```ruby
namespace :models do
  desc "check dependent"
  task :check_callback => :environment do
    application_tables = ApplicationRecord.connection.tables - ["schema_migrations", "ar_internal_metadata"]

    application_tables.each do |table_name|
      ApplicationRecord.connection.foreign_keys(table_name).each do |fk|
        require_relative "../../app/models/#{fk.to_table.classify.underscore}"
      end
    end

    models = ActiveRecord::Base.descendants.reject(&:abstract_class).index_by(&:table_name)
    check_errors = []

    application_tables.each do |table_name|
      ApplicationRecord.connection.foreign_keys(table_name).each do |fk|
        r = models[fk.to_table].reflections
        association = r[fk.from_table] || r[fk.from_table.singularize] || r.to_a.map(&:second).index_by(&:class_name)[fk.from_table.classify]
        if association.nil?
          next check_errors << { message: "No association corresponding to FK from #{fk.from_table} to #{fk.to_table}" }
        elsif association.options.blank? || [:delete_all, :destroy, :nullify].none?(association.options[:dependent])
          next check_errors << { message: "#{fk.to_table.classify} must be annotated with dependent option for :#{association.name} association." }
        end
      end
    end

    if check_errors.present?
      check_errors.each { |error| $stderr.puts error[:message] }
      exit 1
    end
  end
end
```

---

# 7/20

## Ruby

Array に `flat_map` とか `filter_map` が標準であるのね。

昨日書いてたコードの下記部分も、

```ruby
    check_errors = []
    application_tables.each do |table_name|
      ApplicationRecord.connection.foreign_keys(table_name).each do |fk|
        #
      end
    end
```

もうちょっとシンプルに直せる

```ruby
    fks = application_tables.flat_map { |table_name| ApplicationRecord.connection.foreign_keys(table_name) }
    check_errors =  fks.filter_map do |fk|
      #
    end
```

---

# 7/21

## DataDog

ddtrace gem で言う所の span filter のようなことがしたかったのだが、 API ドキュメントには `blocklist` で簡単にできるようなことが書いてあったがどうも実装が異なっていそうなので issue 報告

https://github.com/DataDog/dd-trace-js/issues/2208

> This was removed because of issues with the previous plugin system which has since been replaced. It should be possible to restore this feature at this point. I'll have to take a look at how to handle propagation of the sampling decision for these spans.

とのことだったので、やはり bug だった。

## Rails

https://railsguides.jp/configuring.html#to-prepare

## Next.js

SWC が有効化されている場合、以下の `swcMinify` もデフォで有効化されるが、これが原因で特定の画面が動かなくなった（ `Next.Dynamic` 関係？詳細は不明

```js
/* next.config.js */

module.exports = {
  swcMinify: true // default vallue
};
```

割とまだ不安定説がある

https://github.com/vercel/next.js/discussions/30237
