# 4/1

## typed-css-modules

PR が来ていたのをさばく。正直中身はあんまり見ていない。Breaking Change ではないし、テスト書いてあるのでヨシ！の姿勢。

- https://github.com/Quramy/typed-css-modules/pull/102
- https://github.com/Quramy/typed-css-modules/pull/104

ついでに、TypeScript を最新版に更新しておく。

---

# 4/2

## CoPL

「エラー発生時に発生箇所を表示する」をやる。

- Syntax Error: Parser Combinator の問題
- Runtime Error: 評価器で評価中の node を発生箇所にすればよいだけ。というか現状ほとんど発生させられない（type check が効いてるため）
- Type Error: 「型エラーであること」は Unify の過程でわかるが、出現箇所ってなんだ...

現状のコードが、そもそも Unify する歳に node の位置情報を渡せていない、というよりも、「その型がどの node に由来するものか」の整理がついてない。

そもそもとして、 Type Error の場合、以下のどっちに表示すべきだ？というのもある。

```ocaml
let fn = fun x -> x * 2 in
(*                ~     *)

fn true
(* ~~~~                 *)
```

utop で試すと、 `fn true` のところでだけエラーになってくれる。ただ、 Flow type で同じようなコード書くと `x * 2` の方が主たるエラーになるのよな。Flow の方が違和感はある。

とりあえず、（言語内での）型を表す interface に「どの構文木の型か」の情報を持たせるようにしてみた。

```ts
interface TypeValue {
  kind: "Int" | "Bool" | "List"; // ...
  referenceBy: Position;
}
```

```ts
interface TypeEquation {
  lhs: TypeValue;
  rhs: TypeValue;
}
```

Unify は、上記で表される「左辺型 と 右辺型は等しい」という制約を解いていき、解無しであると判断された場合に error となるようにしているので、

- Left hand side : Actual
- Right hand side : Expected

のルールで扱うようにしておけば「実際の型は lhs だけど、期待する型は rhs だよ、ちなみに lhs に紐付いた node は x 行目の y 列だよ」というようなエラーを表示できるはず、という目論見でやってみる。

実際に実装してみて REPL を触ってみたところ、以下のようなケースになってしまって苦戦。

```ocaml
  let a = false in
(*       ~~~~~~     *)
(*  ここに出ちゃう  *)

  a + 1
(*~                 *)
(* ホントはこっちに出てほしい *)
```

let 式で型スキームの値を伝播させた際に、その出現位置まで伝播させてしまっていたのが良くなかった。型の値は束縛した対象の式の主要型であるべきだけど、その出現箇所は参照している Identifier にしておかないと読みにくくなる。

## ITP とか

https://note.com/martech/n/nef30036d405d に Apple と Google のトラッキング仕様戦争について長々と書かれているらしい。

## NPM

プロジェクトで利用しているライセンスの一覧を見るのに使える。

https://www.npmjs.com/package/license-checker

---

# 4/3

## PicoML

copl-ts のレポジトリについては、CoPL 本と同じ言語機能の状態で freeze して、fork した状態で新しく pico-ml という名前で作成する。

まずは一番簡単に実装できる比較演算子の追加を実装。秒殺。

---

# 4/5

## PicoML

そろそろ Compiler Backend のことも考えていきたい。

ターゲットとして考えられそうなものは以下あたりか。

- JavaScript transpile
- WASM
- LLVM IR

上記の中だと、WASM かな、という気持ちなので、まずは WASM の内部表現に慣れることを目標にしていく。

https://developer.mozilla.org/ja/docs/WebAssembly/Understanding_the_text_format

## WASM

WAST を実行する環境を整えるために、wabt を導入する。

https://github.com/webassembly/wabt

```sh
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .
$ make install
```

どうでもいいことだけど、今使ってる mac に cmake インストールしてなかった。衝撃。

---

# 4/6

## rtk-query

触ってみようかと思ったけど、rtk-query 自体が redux toolkit に強く依存している気配。 typescript-fsa や typescript-fsa-reducer はともかく、immer まで使いたいか、と言われると微妙なんだよなぁ。。。

react-query or swr の方がいいかも。

## Next.js

久々に Next.js の素振り

`<root>/pages` でも `<root>/src/pages` でもどっちでもよかった https://nextjs.org/docs/advanced-features/src-directory

ts-node-dev で custom server 監視するときは `ts-node-dev -P tsconfig.server.json --ignore-watch "/\.next/" src/server.ts` のように `--ignore-watch` オプションをつけること。
ただ、next.config.js を明示的に突っ込んだら、起動しなくなってしまった。仕方ないので nodemon に切り替え。

下記の構成のフィジビリを取った。

- Next.js / gSSP / custom server
- express / `@specter/specer`
- redux / redux-effects / redux-effects-steps / `@specter/redux-effects-specter`

redux-effects-steps の場合、steps で作成した action が Promise を返却するようになる。

```ts
const stepsAction = () => steps(/* */);
store.dispatch(stepsAction()); // Promiseを返すようになる
```

`getServerSideProps` でこの待ちを噛ませてから `store.getState()` すれば、preloaded state を確保できるので、これを page props に込めてやればよい。

```jsx
/* pages/SomePage.tsx */

export getServerSideProps = async ({ req }) => {
  const store = createServerSideStore(req);
  await store.dispatch(stepsAction());
  const _preloadedState = store.getState();
  return {
    props: { _preloadedState },
  }
};
```

```jsx
/* pages/_app.tsx */
const App = ({ Component, pageProps }) => {
  const { _preloadedState: partialStateToMerge, ...props } = pageProps;
  const store = createIsomorphicStore(partialStateToMerge);
  return (
    <Provider store={store}>
      <Component {...props} />
    </Provider>
  );
};
```

```ts
export function createIsomorphicStore(partialStateToMerge: PartialState) {
  if (isClient) {
    // 初回であれば store を生成し、preloadState に partialStateToMerge を利用する
    // 二回目以降であれば、生成済みの store に対して、partialStateToMerge を merge する action を dispatch する
  } else {
    // store を生成し、preloadState に partialStateToMerge を利用する
  }
}
```

Next router で routing した場合に、全 state を上書いてしまわないような仕組みは何かしら必要になるはず。 deep merge でもいいけど、そこまでしなくても、reducer の命名規約とかでも十分そう。

---

# 4/7

## Storycap

Twitter のエゴサ眺めてたら、「Storycap の patch version 上げたらスクロールある画面で結果変わった」っていうツイート見たんだけど、そんなことあり得る...?

## WASM

一昨日の続き。

手で書いた WAST からバイナリ表現を得て、Node.js で実行してみる。

```wast
(module
  (func $add (param $lhs i32) (param $rhs i32) (result i32)
        local.get $lhs
        local.get $rhs
        i32.add)
  (export "add" (func $add))
  )
```

```sh
$ wat2wasm hoge.wast -o hoge.wasm
```

Node.js で実行する場合は下記のような感じ。https://www.dynamsoft.com/codepool/use-webassembly-node-js.htm://www.dynamsoft.com/codepool/use-webassembly-node-js.html からコピペ。

```js
const fs = require("fs").promises;
const util = require("util");

async function main() {
  const source = await fs.readFile("./hoge.wasm");
  const bufferSource = new Uint8Array(source);

  const env = {
    memoryBase: 0,
    tableBase: 0,
    memory: new WebAssembly.Memory({
      initial: 256
    }),
    table: new WebAssembly.Table({
      initial: 0,
      element: "anyfunc"
    })
  };

  const { instance } = await WebAssembly.instantiate(bufferSource, { env });
  console.log(util.inspect(instance.exports, true, 0));

  console.log(instance.exports.add(1, 1));
}

main();
```

`WebAssembly.instantiate` の第二引数の意味がよく分かってない。

spec としては https://webassembly.github.io/spec/js-api/#modules なんだけど、 `memoryBase` とか `tableBase` ってどっから来たんだ？

## Vim

[OCaml 用の LSP](https://github.com/ocaml/ocaml-lsp) 突っ込んだ。公式が LSP 提供しているのはよき。

```sh
$ opam install ocaml-lsp-server
```

## OCaml

今更ながら OCaml のモジュールって何？というところに興味を持つ。「PicoML で WASM 出力しようと思ったときに、WASM としての export 対象をどう決定するか」が頭をよぎったのが切欠。

Yak shaving で OCamlMakefile などが気になってしまい、本筋の module を試すところに行き着かず。

---

# 4/8

## PicoML

すっかり抜け落ちていたけど、 `==` と `!=` の演算子が抜けてたので実装。

## iOS 開発

今使っている端末で `pod install` が叩けずにちょっと時間溶かした。

- `gem install cocoapods` -> 管理者権限じゃないよ、で怒られる
- 「Ruby の環境ちゃんと用意するかー」 -> "renv" でググる -> 正しくは "rbenv" だった orz

を数年に一回くらいの頻度でやっている気がする。成長しないなぁ。。。

## Misc

育成の文脈。「自分にとって出来て当然のこと」を他人に移管するのって難しいよな。

複数の人から「Quramy さんはどうやって成長したんですか」という意味合いのことを聞かれたけど、本当に返答に困る。というか、この質問に対してスパッと答えられる人の方が珍しいんだろうけど。

---

# 4/9

## TypeScript

4.3 の beta 出てた。しかも一週間以上前に。。。 https://devblogs.microsoft.com/typescript/announcing-typescript-4-3-beta/

ちょっと触ってみようかなと思ったけど、Playground がちゃんと plugin 読み込んでくれなくてつらたん。。。

とりあえず issue 立てた https://github.com/microsoft/TypeScript-Website/issues/1749

それはさておきとして、4.3 の機能メモ。

"Separate Write Types on Properties" の feature では、getter/setter に非対称な型を指定することができるようになった

```ts
interface Thing {
    get size(): number
    set size(value: number | string | boolean);
}
```

んー、使うかな？これ。。。

## Chrome

Prerender をもう一回やり直そう、の話があるらしい。

https://github.com/jeremyroman/alternate-loading-modes#prerendering-revamped

No State Prefetch ってどうなったんだろう？

## Misc

https://security.googleblog.com/2021/04/rust-in-android-platform.html

> In addition to memory-safe languages like Kotlin and Java, we’re excited to announce that the Android Open Source Project (AOSP) now supports the Rust programming language for developing the OS itself.

Android が OS 開発について、Rust をサポートした、となっている。同じ blog の下の方に「C/C++をすべて置き換えるのは現実的ではない」とも書いてあるので、「つまりどういうことだってばよ？」という気持ち。

## typescript-eslint-language-service

https://github.com/Quramy/typescript-eslint-language-service/issues/217 にて、「特定の typescript-eslint rule が動作しない」という報告を受けた。

ログ取ってみたらあっさり原因がわかる。

どういう風に利用されているかは定かではないが、 `options.projects` に TypeScript プロジェクトの file path を正規化した上で渡さないといけない。
これ自体は、 `parser.ts` を本家からパチってきたときに見た記憶はあったけのだけど、そのときに自分が面倒臭がったのか、「ここはコメントアウトでいいや」としていてしまった部分だった。きちんと parser.ts と同じようなコード書いたら、報告を受けた rule についても動作するようになった。

https://github.com/Quramy/typescript-eslint-language-service/pull/218

---

# 4/10

## WASM

スタックマシンとはどういうものか、という部分からおさらい。

関数は、空スタックから開始し、最後のインストラクションが完了したときのスタックから値をポップして戻り値とする。

例えば下記の場合、

```wast
(func (result i32)
  i32.const 1
)
```

- 開始時: `[]`
- `i32.const 1` : `[1]`

となるので、結果として `[1]` の末尾の値である `1` が返る。

二項演算子は、スタックから２つの値を消費して計算を行い、その結果をスタックに詰める。

i32 型の加算は `i32.add` というインストラクションで定義されており、これを使うと `1 + 2` は以下のようになる。

```wast
i32.const 1
i32.const 2
i32.add
```

スタックの動きとしては以下。

- 開始時: `[]`
- `i32.const 1` : `[1]`
- `i32.const 2` : `[1, 2]`
- `i32.add` : `[3]`

評価対象が `1 * 2 + 3` であれば、以下となる。

```wast
i32.const 1
i32.const 2
i32.mul
i32.const 3
i32.add
```

評価対象が `1 * (2 + 3)` であれば、以下となる。

```wast
i32.const 1
i32.const 2
i32.const 3
i32.add
i32.mul
```

この場合、スタックは次のような変遷をとる。

- 開始時: `[]`
- `i32.const 1` : `[1]`
- `i32.const 2` : `[1, 2]`
- `i32.const 3` : `[1, 2, 3]`
- `i32.add` : `[1, 6]`
- `i32.mul` : `[7]`

中置記法から後置記法に直すと理解しやすい。

- `1 * 2 + 3` -> `((1 2 *) 3 +)`
- `1 * (2 + 3)` -> `(1 (2 3 +) *)`

それぞれ、演算の優先度を見やすくするために `( )` で囲んだが、後置記法であればこの括弧は不要で、出てきた数値や記号をそれぞれのインストラクションに置き換えるだけで上述の WAST 命令になる。

## PicoML

先日に追加した `==` と `!=` で盛大にやらかしていたことに気付く。

- 数値前提で評価器を実装していた。ちなみに、OCaml の場合、 `[] == []` は真だが、 `[1] == [1]` は偽となる模様。
- 型検査器も、`<` などと同じく、int 値をオペランドに取る前提で作ってしまっていた。「どんな値でも許容するが、左右のオペランドの型は一緒でなくてはならない」が正しい
- `1<2==1<2` を正しく parse できていなかった。lt, le, gt, ge の比較演算子は eq, ne よりも優先度を高くしないといけなかった

上記を諸々修正。

WASM コンパイルについて少し考える。

シンプルな二項演算は簡単に AST からインストラクションに落とせそう。

```js
function getInstructions(node) {
  switch (node.kind) {
    case "NumberLiteral":
      return [`i32.const ${node.value}`];
    case "BoolLiteral":
      return [`i32.const ${node.value ? "1" : "0"}`];
    case "BinaryExpression":
      return [
        ...getInstructions(node.left),
        ...getInstructions(node.right),
        `i32.${getOpname(node.op)}`
      ];
  }
}
```

多分、簡単なのはここまでな気がする。

関数のことを考えた瞬間に疑問が色々。

```ocaml
let id = fun x -> x;;
```

この恒等関数は `'a -> 'a` と型付けされるが、WASM 側の関数定義でこういったことをどうやる？

`int`, `bool` は i32 なので、以下の関数で賄えるがそれだけだ。 `int list` や `int -> int`, `'a` などほぼすべての型でこの関数は使い物にならない。

```wast
(func $id (param $x i32) (result i32)
  local.get $x
  )
```

値を Memory 上に格納して、参照返しにする、ということも考えられるが、その場合、関数適用後のインストラクションが大きく変わってきそう。

型推論の結果を使って、うまく生成するインストラクションを切り替えたりするようなことができたりするんだろうか？（最適化の話になってしまっていそうな気もする）

環境のことも考えないといけない。

```ocaml
let main = fun z ->
  let a = 100 in
  let fn = fun x -> x * a in
  fn z
```

こんな式があるときに、 `fn` に相当する関数は環境から `a` を取り出せなくてはいけない。
これを実現しようとすると、 `let a = 100` がローカルのスタックに値を突っ込むだけではダメで、Memory 上に環境相当を用意してその offset を `fn` に相当する関数にわたす、的な実装が必要そう

---

# 4/11

## WASM

WAST でライフゲームを手書きした、というブログ。 https://www.kabuku.co.jp/developers/webassembly
メモリへのアクセスに `i32.store` や `i32.load` を使っている様がわかりやすかった。

昨日に引き続き、WAT でのインストラクションの基礎を学んでいく。

まずは if 文。

「引数同士を比較して、同じときは 100, そうでなければ 200」となるような関数は以下のように書ける。

```wat
(func $isEqual (param $a i32) (param $b i32) (result i32)
  local.get $a
  local.get $b
  i32.eq
  if (result i32)
    i32.const 100
  else
    i32.const 200
  end
)
```

条件となる値をスタックに積んだ状態で `if` を呼び、 `then` と `else` で更にスタックの操作を行うだけ。注意点は「式の戻り値となる型を `(result)` で明示する」こと。

話は逸れるが [WASM の Spec](https://webassembly.github.io/spec/core/valid/instructions.html#xref-syntax-instructions-syntax-instr-control-mathsf-if-xref-syntax-instructions-syntax-blocktype-mathit-blocktype-xref-syntax-instructions-syntax-instr-mathit-instr-1-ast-xref-syntax-instructions-syntax-instr-control-mathsf-else-xref-syntax-instructions-syntax-instr-mathit-instr-2-ast-xref-syntax-instructions-syntax-instr-control-mathsf-end) に if インストラクションの評価・型付けの判断規則が記載されていた。実際の言語の評価規則もちゃんとこうやって明文化されてるんだなー。こういうの、CoPL 読んでなかったら何を書きたいのかチンプンカンプンだったけど、今はちゃんと読めるようになってて感動。

次に関数呼び出し。

```wat
(module
  (func $localFn (param $a i32) (result i32)
    ;; $a を倍にして返す関数の例
    local.get $a
    i32.const 2
    i32.mul
  )
  (func $caller (result i32)
    i32.const 100
    call $localFn ;; この呼出が終わった状態ではスタックに200が積まれている
    i32.const 10
    i32.add
  )
  (export "caller" (func $caller))
)
```

基本的には、今までの `i32.add` のようなインストラクションと大差ない。スタックに引数を積んだ状態で `call` すればスタックに返り値が積まれた状態になる。

再帰呼び出しも普通に書ける。以下は定番の階乗計算。

```wat
(func $fact (param $n i32) (result i32)
  local.get $n
  i32.const 2
  i32.lt_s
  if (result i32)
    i32.const 1
  else
    local.get $n
    i32.const 1
    i32.sub
    call $fact
    local.get $n
    i32.mul
  end
)
```

続いてメモリ。 `WebAssembly.Memory` で定義される線形メモリについて。

現状の仕様では、1 モジュールについて利用可能な Memory は 1 つまで。

https://webassembly.github.io/spec/core/text/modules.html#memories

`memtype` として記述できるのはメモリの limit で、最小・最大値となるページサイズである。

```wat
(module
  (memory 1)
)
```

と書くと、最小ページサイズ 1 のメモリを定義することになる。 ちなみに、1 ページサイズ = 64KB = 65,536 byte。

`export` で JavaScript 側にメモリを露出させることもできる。

```wat
(module
  (memory $mem 1)
  (export "mem" (memory $mem))
)
```

この場合、JS からは以下のように `buffer` を経由すれば値を見に行くことができる。

```js
const {
  instance: { exports }
} = await WebAssembly.instantiate(bufferSource, env);

assert(exports.mem instanceof WebAssembly.Memory);
const typedArray = Uint8Array(exports.mem.buffer);
```

メモリへの値の格納は以下。

```wat
(func $memGet (result i32)
  i32 const 8 ;; アドレス
  i32.load
)
(func $memSet (param $val i32)
  i32 const 8 ;; アドレス
  local.get $val
  i32.store
)
```

```js
const {
  instance: { exports }
} = await WebAssembly.instantiate(bufferSource, env);

exports.memSet(100);
exports.memGet();

const typedArray = Int32Array(exports.mem.buffer);
console.log(typedArray(2 /* 2 = 8 / 4 */)); // 100
```

アドレスは byte offset、バイトオーダーはリトルエンディアン。https://github.com/WebAssembly/design/blob/master/Portability.md#portability

## PicoML

WASM 側の基礎を眺めてきて、いくつかコンパイラ実装のために見えてきた感。

`Environment` を WASM のメモリ上に構築する必要がある。必要な機能は以下あたりか

- 空の環境を作る
- 環境に新しく値を束縛した環境を作る
- 環境から名前を指定して値を取り出す

実際のところ、束縛した変数名はコンパイル前に番号に置き換えることが可能であることを考慮すると、 `Environment` は 「束縛した値のアドレスを詰めた配列」様のデータ構造で実現できるはず。

`Environment` が実現できれば、let 式は以下のようなインストラクションで表現できるし、

```ocaml
let x = 100 in x (* x のインデックスが 7 だっとして *)
```

```wat
call $createEnv
i32.const 7
i32.const 100
call $setEnv

i32.const 7
call $getEnv
```

「環境の参照を引数に取る関数」を用意すれば、「関数ポインタと環境ポインタの組」でクロージャーを定義できそう。

---

# 4/12

## PicoML

WASM における関数ポインタとは、が気になる。

すごく冗長な例だが、以下のようなコードを考えると、

```ocaml
let apply = fun fn -> fun x -> fn x in
let twice = fun x -> x * 2 in
apply twice 10
```

1 行目の関数適用の `fn x` は「環境から取得した `fn` に対して、これを関数として関数適用する」という意味になっているはず。
言い換えると「任意の関数が実行できる仕組み」が必要になる。

`call` インストラクションは静的なインデックスしか利用できないので、クロージャーの実現にはちょっと相性がよくない。

WASM の場合、 `call_indirect` インストラクションで関数ポインタ的なことを実現できる。ただし、セキュリティ上の理由で、関数ポインタ相当は線形メモリには露出できないようになっている模様。

`WebAssembly.Memory` ではなく、 `WebAssembly.Table` 上に関数参照を格納し、そのテーブル上のインデックス値を用いて動的な関数呼び出しを実現する。

例えば、 `(func (param i32) (result i32)` である任意の関数を呼び出すだけの `$apply` という関数を作ると、以下のようになる。

```wat
(module
  (table $tbl 2 funcref)

  (func $apply (param $fn_addr i32) (param $x i32) (result i32)
        local.get $x
        local.get $fn_addr
        call_indirect (type $fn_twice)
        )
  (type $fn_apply (func (param i32) (param i32) (result i32)))

  (func $twice (param $x i32) (result i32)
        local.get $x
        i32.const 2
        i32.mul
        )
  (type $fn_twice (func (param i32) (result i32)))

  (func $main (result i32)
        i32.const 1 ;;
        i32.const 100
        i32.const 0 ;; $apply のindexを指定
        call_indirect (type $fn_apply) ;; $apply の呼出
        )
  (elem (i32.const 0)
        $apply
        $twice
        )
  (export "tbl" (table $tbl))
  (export "main" (func $main))
  )
```

これで高階関数のようなことも実現できた。

```js
const { instance } = await WebAssembly.instantiate(bufferSource, {});
console.log(instance.exports.main()); // 200, $main を実行
console.log(instance.exports.tbl.get(1)(100)); // 200, $twice を直接実行
console.log(instance.exports.tbl.get(0)(1, 100)); // 200, $apply に $twice のindexを渡して実行
```

ところで、上記の例で言うと、 `$apply` に関しては `call_indirect` ではなく `call $apply` で普通に呼び出せるはずで、そうした方が実行時のオーバーヘッドは絶対に少ないはず。

これができる必要十分な条件を明文化したいけど、パッとわからないので、最適化の宿題だな。。

## WASM

https://webassembly.github.io/spec/core/text/types.html#function-types を見ると、result も vec として定義されているので少し気になっていた。

```wat
(type (func (result i32) (result i32)))
```

「多値対応が進められている」というのはどこかで読んだ記憶はあったけど、 https://github.com/WebAssembly/multi-value/blob/master/proposals/multi-value/Overview.md のレポジトリを見たら既に merge 済とのことだったので、それを読んでいたらしい。

試しに下記のようなモジュールで実行してみたが、Node.js では動かず。

```wat
(module
  (func $multi (result i32 i32)
    i32.const 1
    i32.const 2
  )
  (export "main" (func $multi))
)
```

`return count of 2 exceeds internal limit` というエラーが instantiate 時にスローされる。

V8 のリリースを調べてみたところ、 [多値対応が載ったのは v8.5](https://v8.dev/blog/v8-release-85) とのことだったので、Node.js を v15 に切り替えたら無事動いた。

## ClassDo

@joe_re さんから招待してもらって ClassDo 使わせてもらった。多機能で色々入ってるなーとは思うものの、逆に機能が多すぎて使うのちょっと難しいなと思ってしまった。

## Next.js

少し前に作成した、Next.js の `getServerSideProps` で Redux を動かして Preloaded State を取ってくるサンプルを GitHub に配置。

https://github.com/Quramy/next-specter-redux-example

---

# 4/13

## GraphQL

https://graphql.guide/ という本。 https://blog.graphql.guide/releasing-the-graphql-guide-d9be04747148

とりあえずポチって見ても良いのだけど。。。

## React Query

初めて触った。 devtool あるのはありがたい。

Next.js と組み合わせる場合は https://react-query.tanstack.com/guides/ssr#using-hydration を参考にすればよい。

```js
export function fetchPosts() {
  return fetch("/api/posts").then(res => res.json());
}
```

```js
import { QueryClient } from "react-query";
import { dehydrate } from "react-query/dehydration";
import { fetchPosts } from "../api-client";

export async function getServerSideProps() {
  const queryClient = new QueryClient();
  await queryClient.prefetchQuery("posts", () => fetchPosts());
  return {
    props: {
      dehydratedState: dehydrate(queryClient)
    }
  };
}
```

```jsx
import { useQuery } from "react-query";
import { fetchPosts } from "../api-client";

const usePosts = () => {
  return useQuery("posts", () => fetchPosts());
};

const Component = () => {
  { data } = usePosts();
  if(!data) return null;
  return (
    <div>{ data }</div>
  )
}

export default Component;
```

```jsx
import { QueryClient, QueryClientProvider } from "react-query";
import { Hydrate } from "react-query/hydration";

export default function MyApp({ Component, pageProps }) {
  const queryClientRef = React.useRef();
  if (!queryClientRef.current) {
    queryClientRef.current = new QueryClient();
  }

  return (
    <QueryClientProvider client={queryClientRef.current}>
      <Hydrate state={pageProps.dehydratedState}>
        <Component {...pageProps} />
      </Hydrate>
    </QueryClientProvider>
  );
}
```

これで正常系は動作するが、このままだと `/api/posts` に二重にリクエストが飛ぶことになる

SSR, Client Side Routing いずれの場合も、以下の順で処理が走る

1. gSSP により `/api/posts` へリクエスト
2. gSSP の response に React Query のキャッシュ用データを詰める
3. レンダリング時に受け取ったデータを React Query のキャッシュに展開
4. Component のレンダリング開始
5. useQuery はキャッシュにデータがあるので、これを `data` として返してレンダリングを完了する
6. キャッシュの状態は stale となるため、revalidate request として` /api/posts` へリクエストが発生

SSR の場合は 4. ~ 6. が Server Side, next/link で遷移している場合は 4. ~ 6. が Browser で発生する。

通常、1. と 6. の時間差は、通常 1sec 程度で収まるはずなので、6. の response は大概のケースで 1.と同一のものとなるので、抑止してしまいたい。

下記のように書くことで、「1.5 sec の間、cache を fresh な状態にする」という設定ができる。

```js
const usePosts = () => {
  return useQuery("posts", () => fetchPosts(), { staleTime: 1500 });
};
```

上記の 1. - 6.(もしかしたら 3.- 6.かも？）が 1.5 sec 以内であれば、revalidate が飛ばなくなる。

## WASM

線形メモリの扱いにもう少し慣れておきたい。 https://arjunsreedharan.org/post/148675821737/write-a-simple-memory-allocator に C で簡単なメモリアロケータを作成する、という記事があったので、これを読んでみることに。基本的なプランは、head + chunk をひとかたまりにして、head に次ページのアドレスをもたせておく、という形式。

`free` を実際に使うのは後回しでよいかなと思ったため、まずは可変サイズのリストを実装してみる。

生 WAT で書いてるとすぐ長くなるなぁ。。。割と長くなったので Gist に貼った。 https://gist.github.com/Quramy/44c3f80177ff1a4a08118145d9376713

今更ながら、

```wat
i32.const 1
i32.const 5
i32.add
```

の書き方だけではなくて、下記のような S 式ライクな書き方が有効であったことを知る。

```wat
(i32.add
  (i32.const 1)
  (i32.const 5)
)
```

## PicoML

以下のようなクロージャを実現するための準備が大方整ってきた。

```ocaml
let a = 100 in
let fn = x -> x * a in
fn 10
```

let 式、関数適用、自由変数をさばくための武器として、以下を WASM で実現する手立てに目安が付いた。

- 動的な関数呼び出し: `WebAssembly.Table` と `call_indirect` インストラクション
- 束縛環境: `WebAssembly.Memory` 上のランダムアクセス可能なリスト様データ構造

また、やってみて思ったが、環境に束縛を突っ込む際に、整数( `i32` 型)であれば、アドレスではなく、値そのものを突っ込んで利用する、で良さそう。逆にリストや関数はアドレス（または `Table` 上のオフセット）が環境に入る形になるので、適宜 `i32.load` や `call_indirect` を使うことになるが、これはそれぞれ `ListConstructorNode` や `FunctionApplicationNode` 側で適切なインストラクションを使うだけの話だ。以前に @brn さんから聞いた「V8 では整数とアドレスを同じように格納している」と言っていた件がちょっと理解できてきた気がする。

最適化については [MinCaml](http://esumii.github.io/min-caml/) の解説が役に立ちそう。簡約を使うっぽい。また今度にしっかり読みたい。

コンパイルするときに、メモリ管理や環境管理関連の関数はフットプリント的に突っ込むことになるのが目に見えてきた。

もともと WASM AST -> バイナリ表現 の generator は組むつもりでいたけど、コード管理のことを考えると、WAT parser もあった方が良さそう。

若干遠回り気味な気もするが、

- Combinator などの 言語と直接関係のないユーティリティの切り出し
- WAT parser 作成

からやっていくことにするか。

---

# 4/14

## OCaml

OCaml では数値演算は多重定義されていない。 浮動小数は `1.0 +. 1.0` のように、int 用の演算子の後ろに `.` を付けたトークンが別に定義されている。CPU のことを考えると優しい設計な気もするが、何でだろう？

仮に浮動小数も同じトークンを使っていたとすると、

```ocaml
fun x -> x * 2
```

のような関数が `int -> int` ではなくなって、

```ocaml
type Num = Int of int | Float of float
```

のような共用体に対して、 `Num -> Num` となる？

https://www2.lib.uchicago.edu/keith/ocaml-class/operators.html#float を見ると

> Due to static-typing

と書いてあるな。

コードを書く側の視点からするとそれでもいいような気がするが、これは多分俺が JavaScript に慣れすぎてるせいのバイアスもあるだろうな。

File Descriptor とか Array Index のような「絶対に整数じゃないとだめ」なケースで浮動小数混ざると良くない、というのはわかる。だとすると、何で signed / unsigned の区別が無いんだ？というのは気になるけど。

## Node.js

いっつも忘れるやつ。 Docker で Node.js を利用するときに、PID が 1 で立ち上がってしまい、ホスト側が SIGTERM を送信したとしても期待通りの動作にならない（アプリケーション側で SIGTERM をハンドリングする必要がある）、という問題。

2021 年時点だと、 https://text.superbrothers.dev/200328-how-to-avoid-pid-1-problem-in-kubernetes/ がわかりやすい

一番シンプルなのはコンテナ起動時に `--init` を渡す、という方法。

```sh
$ docker run --init node:14
```

ECS の場合、タスク定義で `initProcessEnabled` を設定することで同じ効果が得られる。

[ECS のタスク定義のガイド](https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/task_definition_parameters.htm://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/task_definition_parameters.html) より

## PicoML

今日から WASM コンパイラ制作作業に入る。

作業の流れは以下のイメージ。

- WAT -> WASM AST parser
- WASM AST -> binary unparser
- ML AST -> WASM AST compiler
- Browser Playground (lightweight ver)
- ML AST -> ML AST optimizer

WAT parser から作り出す。

AST Explorer の WAT parser 参考にしつつ AST の型を決めようと思ったけど、イマイチ品質が低そうなんだよな。

`(memory 1)` の 1 は memmory -> limits ノードの属性にベタで `min: 1` が来るけど、 `wat i32.const 1` の 1 は NumberLiteral ノードになってる。

どちらも利用される生成規則上は https://webassembly.github.io/spec/core/text/values.html#text-int で規定されてる `u32` か `i32` になるんだけど、方や属性、方やノード、というのは気持ちが悪い。
WASM の spec 上は BNF しか無いので、生成規則名 = parser 名 は決めやすいけど、構文木の visitor key をどうやって決めたものか。

WAT parser を作る上で、combinator に色々と足りてないパーツがあったので、parser と合わせて拡充させていく。

- 0 回以上の繰り返し: `vec` combinator を実装
- 0 回または 1 回 : `option` combinator を実装

例えば module に相当する parser は以下のようになる。

```ts
const mod: Parser<ModuleNode> = expect(
  symbolToken("("),
  option(idToken),
  keywordToken("module"),
  vec(fieldParser),
  symbolToken(")")
)(callback);
```

---

# 4/15

## PicoML

module, memory の parser だけ作ったところで、合わせてバイナリに出力する側も作り出す。

https://webassembly.studio で wat2wasm の結果も見つつ進める。

実装しながら spec を読んでいて初めて知ったが、 WASM のバイナリ表現では `Uint32` の符号化に LEB128 という形式を用いている。 https://webassembly.github.io/spec/core/binary/values.html#binary-int

https://en.wikipedia.org/wiki/LEB128

## Misc

http リクエストを mock するためのツール. まぁこの手の山のようにありそうだけど。。。

- https://www.npmjs.com/package/nock

---

# 4/16

## PicoML

昨日に引き続き、LEB128 エンコーダの実装をしていく。 https://en.wikipedia.org/wiki/LEB128 にしたがって実装したらあっさりできた。

ここまで、以下のプランで考えていたけど、関数について考えた辺りで設計の歪さに気付く。

> - WAT -> WASM AST parser
> - WASM AST -> binary unparser

端的にいうと、 [Structure](https://webassembly.github.io/spec/core/syntax/index.html) についての考慮が抜け落ちていて、中間構造を考えないとダメ。

- WAT -> WAT AST parser
- WAT AST -> WASM Structure converter
- WASM Structure -> binary unparser

なぜかというと、以下のような WAT があったとして、関数のシグネチャは、Structure として見たときはこの関数の持ち物にならない。

```wat
(module
  (func (param i32) (result i32)
    local.get 1
    i32.const 2
    i32.mul)
  )
```

https://webassembly.github.io/spec/core/text/modules.html#abbreviations に詳細が記載されているが、これは下記のような構造に対する簡略記法に過ぎない。

```wat
(module
  (func (type 0)
    local.get 1
    i32.const 2
    i32.mul)
  (type (func (param i32) (result i32)))
  )
```

Structure として考えた場合に、関数が持てるのは関数型への参照であって、シグネチャそのものでない。
とはいえ、parse 時にいきなりこの構造にするのは複雑度が高くなってしまうので、WAT の構文木 -> WASM の抽象構造 として段階を踏まえた方が確実にできそう。
どうせバイナリ表現にするときに色々構造をイジる羽目になるだろうし。

FuncType の部分を実装した辺りで「スキャンしている文字列の巻き戻し」が本格的に必要になってきた。

```wat
(func (param i32) (result i32))
```

上記のような WAT をパースする場合に、 `param` と `result` の部分はそれぞれ `vec` で定義されているため、下記のように `expect` と `vec` を組み合わせて parser が作成できる。

```ts
const param = vec(
  expect(symbolToken("("), keywordToken("param"), symbolToken(")"))(callback)
);

const result = vec(
  expect(symbolToken("("), keywordToken("result"), symbolToken(")"))(callback)
);

const funcType = expect(
  symbolToken("("),
  keywordToken("func"),
  param,
  result,
  symbolToken(")")
)(callback);
```

問題となるのは、 `param`, `result` が両方とも "(" を消費してしまう点。

先ほどの WAT を解釈する際は、 `param` parser が `(param i32)` の解釈を終えて、`vec` としての 2 つ目の要素の消費に入る。
ここで後続に `( result` という入力が並んでいることから、"(" のトークンを消費してから "result" に差し掛かって初めて `param` parser は失敗を知ることになる。

これを食い止めるために、 `tryWith` という combinator を作って以下のように `expect` を囲むようにした。「parser がエラーを出したときに、握りつぶして scanner の読み取り位置を元に巻き戻す」parser だ。

```ts
const param = vec(
  tryWith(
    expect(symbolToken("("), keywordToken("param"), symbolToken(")"))(callback)
  )
);

const result = vec(
  tryWith(
    expect(symbolToken("("), keywordToken("result"), symbolToken(")"))(callback)
  )
);
```

ML 側の parser でも、 `let a = fun x -> x in a` と `let rec a = fun x -> x in a` で同じような問題が起きたけど、あのときは "let" の消費を行ってから `oneOf` で分岐させるようにして頑張っていたが、今回の WAT については "(" が頻出するし、書きやすさ重視で行くか。
