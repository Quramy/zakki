# 4/1

## typed-css-modules

PR が来ていたのをさばく。正直中身はあんまり見ていない。Breaking Change ではないし、テスト書いてあるのでヨシ！の姿勢。

- https://github.com/Quramy/typed-css-modules/pull/102
- https://github.com/Quramy/typed-css-modules/pull/104

ついでに、TypeScript を最新版に更新しておく。

---

# 4/2

## CoPL

「エラー発生時に発生箇所を表示する」をやる。

- Syntax Error: Parser Combinator の問題
- Runtime Error: 評価器で評価中の node を発生箇所にすればよいだけ。というか現状ほとんど発生させられない（type check が効いてるため）
- Type Error: 「型エラーであること」は Unify の過程でわかるが、出現箇所ってなんだ...

現状のコードが、そもそも Unify する歳に node の位置情報を渡せていない、というよりも、「その型がどの node に由来するものか」の整理がついてない。

そもそもとして、 Type Error の場合、以下のどっちに表示すべきだ？というのもある。

```ocaml
let fn = fun x -> x * 2 in
(*                ~     *)

fn true
(* ~~~~                 *)
```

utop で試すと、 `fn true` のところでだけエラーになってくれる。ただ、 Flow type で同じようなコード書くと `x * 2` の方が主たるエラーになるのよな。Flow の方が違和感はある。

とりあえず、（言語内での）型を表す interface に「どの構文木の型か」の情報を持たせるようにしてみた。

```ts
interface TypeValue {
  kind: "Int" | "Bool" | "List"; // ...
  referenceBy: Position;
}
```

```ts
interface TypeEquation {
  lhs: TypeValue;
  rhs: TypeValue;
}
```

Unify は、上記で表される「左辺型 と 右辺型は等しい」という制約を解いていき、解無しであると判断された場合に error となるようにしているので、

- Left hand side : Actual
- Right hand side : Expected

のルールで扱うようにしておけば「実際の型は lhs だけど、期待する型は rhs だよ、ちなみに lhs に紐付いた node は x 行目の y 列だよ」というようなエラーを表示できるはず、という目論見でやってみる。

実際に実装してみて REPL を触ってみたところ、以下のようなケースになってしまって苦戦。

```ocaml
  let a = false in
(*       ~~~~~~     *)
(*  ここに出ちゃう  *)

  a + 1
(*~                 *)
(* ホントはこっちに出てほしい *)
```

let 式で型スキームの値を伝播させた際に、その出現位置まで伝播させてしまっていたのが良くなかった。型の値は束縛した対象の式の主要型であるべきだけど、その出現箇所は参照している Identifier にしておかないと読みにくくなる。

## ITP とか

https://note.com/martech/n/nef30036d405d に Apple と Google のトラッキング仕様戦争について長々と書かれているらしい。

## NPM

プロジェクトで利用しているライセンスの一覧を見るのに使える。

https://www.npmjs.com/package/license-checker

---

# 4/3

## PicoML

copl-ts のレポジトリについては、CoPL 本と同じ言語機能の状態で freeze して、fork した状態で新しく pico-ml という名前で作成する。

まずは一番簡単に実装できる比較演算子の追加を実装。秒殺。

---

# 4/5

## PicoML

そろそろ Compiler Backend のことも考えていきたい。

ターゲットとして考えられそうなものは以下あたりか。

- JavaScript transpile
- WASM
- LLVM IR

上記の中だと、WASM かな、という気持ちなので、まずは WASM の内部表現に慣れることを目標にしていく。

https://developer.mozilla.org/ja/docs/WebAssembly/Understanding_the_text_format

## WASM

WAST を実行する環境を整えるために、wabt を導入する。

https://github.com/webassembly/wabt

```sh
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .
$ make install
```

どうでもいいことだけど、今使ってる mac に cmake インストールしてなかった。衝撃。

---

# 4/6

## rtk-query

触ってみようかと思ったけど、rtk-query 自体が redux toolkit に強く依存している気配。 typescript-fsa や typescript-fsa-reducer はともかく、immer まで使いたいか、と言われると微妙なんだよなぁ。。。

react-query or swr の方がいいかも。

## Next.js

久々に Next.js の素振り

`<root>/pages` でも `<root>/src/pages` でもどっちでもよかった https://nextjs.org/docs/advanced-features/src-directory

ts-node-dev で custom server 監視するときは `ts-node-dev -P tsconfig.server.json --ignore-watch "/\.next/" src/server.ts` のように `--ignore-watch` オプションをつけること。
ただ、next.config.js を明示的に突っ込んだら、起動しなくなってしまった。仕方ないので nodemon に切り替え。

下記の構成のフィジビリを取った。

- Next.js / gSSP / custom server
- express / `@specter/specer`
- redux / redux-effects / redux-effects-steps / `@specter/redux-effects-specter`

redux-effects-steps の場合、steps で作成した action が Promise を返却するようになる。

```ts
const stepsAction = () => steps(/* */);
store.dispatch(stepsAction()); // Promiseを返すようになる
```

`getServerSideProps` でこの待ちを噛ませてから `store.getState()` すれば、preloaded state を確保できるので、これを page props に込めてやればよい。

```jsx
/* pages/SomePage.tsx */

export getServerSideProps = async ({ req }) => {
  const store = createServerSideStore(req);
  await store.dispatch(stepsAction());
  const _preloadedState = store.getState();
  return {
    props: { _preloadedState },
  }
};
```

```jsx
/* pages/_app.tsx */
const App = ({ Component, pageProps }) => {
  const { _preloadedState: partialStateToMerge, ...props } = pageProps;
  const store = createIsomorphicStore(partialStateToMerge);
  return (
    <Provider store={store}>
      <Component {...props} />
    </Provider>
  );
};
```

```ts
export function createIsomorphicStore(partialStateToMerge: PartialState) {
  if (isClient) {
    // 初回であれば store を生成し、preloadState に partialStateToMerge を利用する
    // 二回目以降であれば、生成済みの store に対して、partialStateToMerge を merge する action を dispatch する
  } else {
    // store を生成し、preloadState に partialStateToMerge を利用する
  }
}
```

Next router で routing した場合に、全 state を上書いてしまわないような仕組みは何かしら必要になるはず。 deep merge でもいいけど、そこまでしなくても、reducer の命名規約とかでも十分そう。

---

# 4/7

## Storycap

Twitter のエゴサ眺めてたら、「Storycap の patch version 上げたらスクロールある画面で結果変わった」っていうツイート見たんだけど、そんなことあり得る...?

## WASM

一昨日の続き。

手で書いた WAST からバイナリ表現を得て、Node.js で実行してみる。

```wast
(module
  (func $add (param $lhs i32) (param $rhs i32) (result i32)
        local.get $lhs
        local.get $rhs
        i32.add)
  (export "add" (func $add))
  )
```

```sh
$ wat2wasm hoge.wast -o hoge.wasm
```

Node.js で実行する場合は下記のような感じ。https://www.dynamsoft.com/codepool/use-webassembly-node-js.htm://www.dynamsoft.com/codepool/use-webassembly-node-js.html からコピペ。

```js
const fs = require("fs").promises;
const util = require("util");

async function main() {
  const source = await fs.readFile("./hoge.wasm");
  const bufferSource = new Uint8Array(source);

  const env = {
    memoryBase: 0,
    tableBase: 0,
    memory: new WebAssembly.Memory({
      initial: 256
    }),
    table: new WebAssembly.Table({
      initial: 0,
      element: "anyfunc"
    })
  };

  const { instance } = await WebAssembly.instantiate(bufferSource, { env });
  console.log(util.inspect(instance.exports, true, 0));

  console.log(instance.exports.add(1, 1));
}

main();
```

`WebAssembly.instantiate` の第二引数の意味がよく分かってない。

spec としては https://webassembly.github.io/spec/js-api/#modules なんだけど、 `memoryBase` とか `tableBase` ってどっから来たんだ？

## Vim

[OCaml 用の LSP](https://github.com/ocaml/ocaml-lsp) 突っ込んだ。公式が LSP 提供しているのはよき。

```sh
$ opam install ocaml-lsp-server
```

## OCaml

今更ながら OCaml のモジュールって何？というところに興味を持つ。「PicoML で WASM 出力しようと思ったときに、WASM としての export 対象をどう決定するか」が頭をよぎったのが切欠。

Yak shaving で OCamlMakefile などが気になってしまい、本筋の module を試すところに行き着かず。

---

# 4/8

## PicoML

すっかり抜け落ちていたけど、 `==` と `!=` の演算子が抜けてたので実装。

## iOS 開発

今使っている端末で `pod install` が叩けずにちょっと時間溶かした。

- `gem install cocoapods` -> 管理者権限じゃないよ、で怒られる
- 「Ruby の環境ちゃんと用意するかー」 -> "renv" でググる -> 正しくは "rbenv" だった orz

を数年に一回くらいの頻度でやっている気がする。成長しないなぁ。。。

## Misc

育成の文脈。「自分にとって出来て当然のこと」を他人に移管するのって難しいよな。

複数の人から「Quramy さんはどうやって成長したんですか」という意味合いのことを聞かれたけど、本当に返答に困る。というか、この質問に対してスパッと答えられる人の方が珍しいんだろうけど。

---

# 4/9

## TypeScript

4.3 の beta 出てた。しかも一週間以上前に。。。 https://devblogs.microsoft.com/typescript/announcing-typescript-4-3-beta/

ちょっと触ってみようかなと思ったけど、Playground がちゃんと plugin 読み込んでくれなくてつらたん。。。

とりあえず issue 立てた https://github.com/microsoft/TypeScript-Website/issues/1749

それはさておきとして、4.3 の機能メモ。

"Separate Write Types on Properties" の feature では、getter/setter に非対称な型を指定することができるようになった

```ts
interface Thing {
    get size(): number
    set size(value: number | string | boolean);
}
```

んー、使うかな？これ。。。

## Chrome

Prerender をもう一回やり直そう、の話があるらしい。

https://github.com/jeremyroman/alternate-loading-modes#prerendering-revamped

No State Prefetch ってどうなったんだろう？

## Misc

https://security.googleblog.com/2021/04/rust-in-android-platform.html

> In addition to memory-safe languages like Kotlin and Java, we’re excited to announce that the Android Open Source Project (AOSP) now supports the Rust programming language for developing the OS itself.

Android が OS 開発について、Rust をサポートした、となっている。同じ blog の下の方に「C/C++をすべて置き換えるのは現実的ではない」とも書いてあるので、「つまりどういうことだってばよ？」という気持ち。

## typescript-eslint-language-service

https://github.com/Quramy/typescript-eslint-language-service/issues/217 にて、「特定の typescript-eslint rule が動作しない」という報告を受けた。

ログ取ってみたらあっさり原因がわかる。

どういう風に利用されているかは定かではないが、 `options.projects` に TypeScript プロジェクトの file path を正規化した上で渡さないといけない。
これ自体は、 `parser.ts` を本家からパチってきたときに見た記憶はあったけのだけど、そのときに自分が面倒臭がったのか、「ここはコメントアウトでいいや」としていてしまった部分だった。きちんと parser.ts と同じようなコード書いたら、報告を受けた rule についても動作するようになった。

https://github.com/Quramy/typescript-eslint-language-service/pull/218

---

# 4/10

## WASM

スタックマシンとはどういうものか、という部分からおさらい。

関数は、空スタックから開始し、最後のインストラクションが完了したときのスタックから値をポップして戻り値とする。

例えば下記の場合、

```wast
(func (result i32)
  i32.const 1
)
```

- 開始時: `[]`
- `i32.const 1` : `[1]`

となるので、結果として `[1]` の末尾の値である `1` が返る。

二項演算子は、スタックから２つの値を消費して計算を行い、その結果をスタックに詰める。

i32 型の加算は `i32.add` というインストラクションで定義されており、これを使うと `1 + 2` は以下のようになる。

```wast
i32.const 1
i32.const 2
i32.add
```

スタックの動きとしては以下。

- 開始時: `[]`
- `i32.const 1` : `[1]`
- `i32.const 2` : `[1, 2]`
- `i32.add` : `[3]`

評価対象が `1 * 2 + 3` であれば、以下となる。

```wast
i32.const 1
i32.const 2
i32.mul
i32.const 3
i32.add
```

評価対象が `1 * (2 + 3)` であれば、以下となる。

```wast
i32.const 1
i32.const 2
i32.const 3
i32.add
i32.mul
```

この場合、スタックは次のような変遷をとる。

- 開始時: `[]`
- `i32.const 1` : `[1]`
- `i32.const 2` : `[1, 2]`
- `i32.const 3` : `[1, 2, 3]`
- `i32.add` : `[1, 6]`
- `i32.mul` : `[7]`

中置記法から後置記法に直すと理解しやすい。

- `1 * 2 + 3` -> `((1 2 *) 3 +)`
- `1 * (2 + 3)` -> `(1 (2 3 +) *)`

それぞれ、演算の優先度を見やすくするために `( )` で囲んだが、後置記法であればこの括弧は不要で、出てきた数値や記号をそれぞれのインストラクションに置き換えるだけで上述の WAST 命令になる。

## PicoML

先日に追加した `==` と `!=` で盛大にやらかしていたことに気付く。

- 数値前提で評価器を実装していた。ちなみに、OCaml の場合、 `[] == []` は真だが、 `[1] == [1]` は偽となる模様。
- 型検査器も、`<` などと同じく、int 値をオペランドに取る前提で作ってしまっていた。「どんな値でも許容するが、左右のオペランドの型は一緒でなくてはならない」が正しい
- `1<2==1<2` を正しく parse できていなかった。lt, le, gt, ge の比較演算子は eq, ne よりも優先度を高くしないといけなかった

上記を諸々修正。

WASM コンパイルについて少し考える。

シンプルな二項演算は簡単に AST からインストラクションに落とせそう。

```js
function getInstructions(node) {
  switch (node.kind) {
    case "NumberLiteral":
      return [`i32.const ${node.value}`];
    case "BoolLiteral":
      return [`i32.const ${node.value ? "1" : "0"}`];
    case "BinaryExpression":
      return [
        ...getInstructions(node.left),
        ...getInstructions(node.right),
        `i32.${getOpname(node.op)}`
      ];
  }
}
```

多分、簡単なのはここまでな気がする。

関数のことを考えた瞬間に疑問が色々。

```ocaml
let id = fun x -> x;;
```

この恒等関数は `'a -> 'a` と型付けされるが、WASM 側の関数定義でこういったことをどうやる？

`int`, `bool` は i32 なので、以下の関数で賄えるがそれだけだ。 `int list` や `int -> int`, `'a` などほぼすべての型でこの関数は使い物にならない。

```wast
(func $id (param $x i32) (result i32)
  local.get $x
  )
```

値を Memory 上に格納して、参照返しにする、ということも考えられるが、その場合、関数適用後のインストラクションが大きく変わってきそう。

型推論の結果を使って、うまく生成するインストラクションを切り替えたりするようなことができたりするんだろうか？（最適化の話になってしまっていそうな気もする）

環境のことも考えないといけない。

```ocaml
let main = fun z ->
  let a = 100 in
  let fn = fun x -> x * a in
  fn z
```

こんな式があるときに、 `fn` に相当する関数は環境から `a` を取り出せなくてはいけない。
これを実現しようとすると、 `let a = 100` がローカルのスタックに値を突っ込むだけではダメで、Memory 上に環境相当を用意してその offset を `fn` に相当する関数にわたす、的な実装が必要そう
