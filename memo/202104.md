# 4/1

## typed-css-modules

PR が来ていたのをさばく。正直中身はあんまり見ていない。Breaking Change ではないし、テスト書いてあるのでヨシ！の姿勢。

- https://github.com/Quramy/typed-css-modules/pull/102
- https://github.com/Quramy/typed-css-modules/pull/104

ついでに、TypeScript を最新版に更新しておく。

---

# 4/2

## CoPL

「エラー発生時に発生箇所を表示する」をやる。

- Syntax Error: Parser Combinator の問題
- Runtime Error: 評価器で評価中の node を発生箇所にすればよいだけ。というか現状ほとんど発生させられない（type check が効いてるため）
- Type Error: 「型エラーであること」は Unify の過程でわかるが、出現箇所ってなんだ...

現状のコードが、そもそも Unify する歳に node の位置情報を渡せていない、というよりも、「その型がどの node に由来するものか」の整理がついてない。

そもそもとして、 Type Error の場合、以下のどっちに表示すべきだ？というのもある。

```ocaml
let fn = fun x -> x * 2 in
(*                ~     *)

fn true
(* ~~~~                 *)
```

utop で試すと、 `fn true` のところでだけエラーになってくれる。ただ、 Flow type で同じようなコード書くと `x * 2` の方が主たるエラーになるのよな。Flow の方が違和感はある。

とりあえず、（言語内での）型を表す interface に「どの構文木の型か」の情報を持たせるようにしてみた。

```ts
interface TypeValue {
  kind: "Int" | "Bool" | "List"; // ...
  referenceBy: Position;
}
```

```ts
interface TypeEquation {
  lhs: TypeValue;
  rhs: TypeValue;
}
```

Unify は、上記で表される「左辺型 と 右辺型は等しい」という制約を解いていき、解無しであると判断された場合に error となるようにしているので、

- Left hand side : Actual
- Right hand side : Expected

のルールで扱うようにしておけば「実際の型は lhs だけど、期待する型は rhs だよ、ちなみに lhs に紐付いた node は x 行目の y 列だよ」というようなエラーを表示できるはず、という目論見でやってみる。

実際に実装してみて REPL を触ってみたところ、以下のようなケースになってしまって苦戦。

```ocaml
  let a = false in
(*       ~~~~~~     *)
(*  ここに出ちゃう  *)

  a + 1
(*~                 *)
(* ホントはこっちに出てほしい *)
```

let 式で型スキームの値を伝播させた際に、その出現位置まで伝播させてしまっていたのが良くなかった。型の値は束縛した対象の式の主要型であるべきだけど、その出現箇所は参照している Identifier にしておかないと読みにくくなる。

## ITP とか

https://note.com/martech/n/nef30036d405d に Apple と Google のトラッキング仕様戦争について長々と書かれているらしい。

## NPM

プロジェクトで利用しているライセンスの一覧を見るのに使える。

https://www.npmjs.com/package/license-checker

---

# 4/3

## PicoML

copl-ts のレポジトリについては、CoPL 本と同じ言語機能の状態で freeze して、fork した状態で新しく pico-ml という名前で作成する。

まずは一番簡単に実装できる比較演算子の追加を実装。秒殺。
